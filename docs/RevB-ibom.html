<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive BOM for KiCAD</title>
    <style type="text/css">
      :root {
        --pcb-edge-color: black;
        --pad-color: #878787;
        --pad-hole-color: #cccccc;
        --pad-color-highlight: #d04040;
        --pad-color-highlight-both: #d0d040;
        --pad-color-highlight-marked: #44a344;
        --pin1-outline-color: #ffb629;
        --pin1-outline-color-highlight: #ffb629;
        --pin1-outline-color-highlight-both: #fcbb39;
        --pin1-outline-color-highlight-marked: #fdbe41;
        --silkscreen-edge-color: #aa4;
        --silkscreen-polygon-color: #4aa;
        --silkscreen-text-color: #4aa;
        --fabrication-edge-color: #907651;
        --fabrication-polygon-color: #907651;
        --fabrication-text-color: #a27c24;
        --track-color: #def5f1;
        --track-color-highlight: #d04040;
        --zone-color: #def5f1;
        --zone-color-highlight: #d0404080;
      }

      html,
      body {
        margin: 0px;
        height: 100%;
        font-family: Verdana, sans-serif;
      }

      .dark.topmostdiv {
        --pcb-edge-color: #eee;
        --pad-color: #808080;
        --pin1-outline-color: #ffa800;
        --pin1-outline-color-highlight: #ccff00;
        --track-color: #42524f;
        --zone-color: #42524f;
        background-color: #252c30;
        color: #eee;
      }

      button {
        background-color: #eee;
        border: 1px solid #888;
        color: black;
        height: 44px;
        width: 44px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 14px;
        font-weight: bolder;
      }

      .dark button {
        /* This will be inverted */
        background-color: #c3b7b5;
      }

      button.depressed {
        background-color: #0a0;
        color: white;
      }

      .dark button.depressed {
        /* This will be inverted */
        background-color: #b3b;
      }

      button:focus {
        outline: 0;
      }

      button#tb-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.32 290.12h5.82M1.32 291.45h5.82' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 292.5v4.23M.26 292.63H8.2' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='1.35' y='295.73'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
      }

      button#lr-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.06 290.12H3.7m-2.64 1.33H3.7m-2.64 1.32H3.7m-2.64 1.3H3.7m-2.64 1.33H3.7' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 288.8v7.94m0-4.11h3.96' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='5.11' y='291.96'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
      }

      button#bom-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)' fill='none' stroke='%23000' stroke-width='.4'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' stroke-linejoin='round'/%3E%3Cpath d='M1.59 290.12h5.29M1.59 291.45h5.33M1.59 292.75h5.33M1.59 294.09h5.33M1.59 295.41h5.33'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-grouped-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m4 0h5m4 0h3M6.1 22h3m3.9 0h5m4 0h4m-16-8h4m4 0h4'/%3E%3Cpath stroke-linecap='null' d='M5 17.5h22M5 26.6h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-ungrouped-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m-4 8h3m-3 8h4'/%3E%3Cpath stroke-linecap='null' d='M5 13.5h22m-22 8h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-netlist-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg fill='none' stroke='%23000' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-width='2' d='M6 26l6-6v-8m13.8-6.3l-6 6v8'/%3E%3Ccircle cx='11.8' cy='9.5' r='2.8' stroke-width='2'/%3E%3Ccircle cx='19.8' cy='22.8' r='2.8' stroke-width='2'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#copy {
        background-image: url("data:image/svg+xml,%3Csvg height='48' viewBox='0 0 48 48' width='48' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h48v48h-48z' fill='none'/%3E%3Cpath d='M32 2h-24c-2.21 0-4 1.79-4 4v28h4v-28h24v-4zm6 8h-22c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h22c2.21 0 4-1.79 4-4v-28c0-2.21-1.79-4-4-4zm0 32h-22v-28h22v28z'/%3E%3C/svg%3E");
        background-position: 6px 6px;
        background-repeat: no-repeat;
        background-size: 26px 26px;
        border-radius: 6px;
        height: 40px;
        width: 40px;
        margin: 10px 5px;
      }

      button#copy:active {
        box-shadow: inset 0px 0px 5px #6c6c6c;
      }

      textarea.clipboard-temp {
        position: fixed;
        top: 0;
        left: 0;
        width: 2em;
        height: 2em;
        padding: 0;
        border: None;
        outline: None;
        box-shadow: None;
        background: transparent;
      }

      .left-most-button {
        border-right: 0;
        border-top-left-radius: 6px;
        border-bottom-left-radius: 6px;
      }

      .middle-button {
        border-right: 0;
      }

      .right-most-button {
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
      }

      .button-container {
        font-size: 0;
        margin: 10px 10px 10px 0px;
      }

      .dark .button-container {
        filter: invert(1);
      }

      .button-container button {
        background-size: 32px 32px;
        background-position: 5px 5px;
        background-repeat: no-repeat;
      }

      @media print {
        .hideonprint {
          display: none;
        }
      }

      canvas {
        cursor: crosshair;
      }

      canvas:active {
        cursor: grabbing;
      }

      .fileinfo {
        width: 100%;
        max-width: 1000px;
        border: none;
        padding: 5px;
      }

      .fileinfo .title {
        font-size: 20pt;
        font-weight: bold;
      }

      .fileinfo td {
        overflow: hidden;
        white-space: nowrap;
        max-width: 1px;
        width: 50%;
        text-overflow: ellipsis;
      }

      .bom {
        border-collapse: collapse;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 10pt;
        table-layout: fixed;
        width: 100%;
        margin-top: 1px;
        position: relative;
      }

      .bom th,
      .bom td {
        border: 1px solid black;
        padding: 5px;
        word-wrap: break-word;
        text-align: center;
        position: relative;
      }

      .dark .bom th,
      .dark .bom td {
        border: 1px solid #777;
      }

      .bom th {
        background-color: #cccccc;
        background-clip: padding-box;
      }

      .dark .bom th {
        background-color: #3b4749;
      }

      .bom tr.highlighted:nth-child(n) {
        background-color: #cfc;
      }

      .dark .bom tr.highlighted:nth-child(n) {
        background-color: #226022;
      }

      .bom tr:nth-child(even) {
        background-color: #f2f2f2;
      }

      .dark .bom tr:nth-child(even) {
        background-color: #313b40;
      }

      .bom tr.checked {
        color: #1cb53d;
      }

      .dark .bom tr.checked {
        color: #2cce54;
      }

      .bom tr {
        transition: background-color 0.2s;
      }

      .bom .numCol {
        width: 30px;
      }

      .bom .value {
        width: 15%;
      }

      .bom .quantity {
        width: 65px;
      }

      .bom th .sortmark {
        position: absolute;
        right: 1px;
        top: 1px;
        margin-top: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent #221 transparent;
        transform-origin: 50% 85%;
        transition:
          opacity 0.2s,
          transform 0.4s;
      }

      .dark .bom th .sortmark {
        filter: invert(1);
      }

      .bom th .sortmark.none {
        opacity: 0;
      }

      .bom th .sortmark.desc {
        transform: rotate(180deg);
      }

      .bom th:hover .sortmark.none {
        opacity: 0.5;
      }

      .bom .bom-checkbox {
        width: 30px;
        position: relative;
        user-select: none;
        -moz-user-select: none;
      }

      .bom .bom-checkbox:before {
        content: "";
        position: absolute;
        border-width: 15px;
        border-style: solid;
        border-color: #51829f transparent transparent transparent;
        visibility: hidden;
        top: -15px;
      }

      .bom .bom-checkbox:after {
        content: "Double click to set/unset all";
        position: absolute;
        color: white;
        top: -35px;
        left: -26px;
        background: #51829f;
        padding: 5px 15px;
        border-radius: 8px;
        white-space: nowrap;
        visibility: hidden;
      }

      .bom .bom-checkbox:hover:before,
      .bom .bom-checkbox:hover:after {
        visibility: visible;
        transition: visibility 0.2s linear 1s;
      }

      .split {
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: inherit;
      }

      .split.split-horizontal,
      .gutter.gutter-horizontal {
        height: 100%;
        float: left;
      }

      .gutter {
        background-color: #ddd;
        background-repeat: no-repeat;
        background-position: 50%;
        transition: background-color 0.3s;
      }

      .dark .gutter {
        background-color: #777;
      }

      .gutter.gutter-horizontal {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==");
        cursor: ew-resize;
        width: 5px;
      }

      .gutter.gutter-vertical {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABo7865AAAABlBMVEVHcEzMzMzyAv2sAAAAAXRSTlMAQObYZgAAABBJREFUeF5jOAMEEAIEEFwAn3kMwcB6I2AAAAAASUVORK5CYII=");
        cursor: ns-resize;
        height: 5px;
      }

      .searchbox {
        float: left;
        height: 40px;
        margin: 10px 5px;
        padding: 12px 32px;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 18px;
        box-sizing: border-box;
        border: 1px solid #888;
        border-radius: 6px;
        outline: none;
        background-color: #eee;
        transition:
          background-color 0.2s,
          border 0.2s;
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABNklEQVQ4T8XSMUvDQBQH8P/LElFa/AIZHcTBQSz0I/gFstTBRR2KUC4ldDxw7h0Bl3RRUATxi4iiODgoiLNrbQYp5J6cpJJqomkX33Z37/14d/dIa33MzDuYI4johOI4XhyNRteO46zNYjDzAxE1yBZprVeZ+QbAUhXEGJMA2Ox2u4+fQIa0mPmsCgCgJYQ4t7lfgF0opQYAdv9ABkKI/UnOFCClXKjX61cA1osQY8x9kiRNKeV7IWA3oyhaSdP0FkAtjxhj3hzH2RBCPOf3pzqYHCilfAAX+URm9oMguPzeWSGQvUcMYC8rOBJCHBRdqxTo9/vbRHRqi8bj8XKv1xvODbiuW2u32/bvf0SlDv4XYOY7z/Mavu+nM1+BmQ+NMc0wDF/LprP0DbTWW0T00ul0nn4b7Q87+X4Qmfiq2wAAAABJRU5ErkJggg==");
        background-position: 10px 10px;
        background-repeat: no-repeat;
      }

      .dark .searchbox {
        background-color: #111;
        color: #eee;
      }

      .searchbox::placeholder {
        color: #ccc;
      }

      .dark .searchbox::placeholder {
        color: #666;
      }

      .filter {
        width: calc(60% - 64px);
      }

      .reflookup {
        width: calc(40% - 10px);
      }

      input[type="text"]:focus {
        background-color: white;
        border: 1px solid #333;
      }

      .dark input[type="text"]:focus {
        background-color: #333;
        border: 1px solid #ccc;
      }

      mark.highlight {
        background-color: #5050ff;
        color: #fff;
        padding: 2px;
        border-radius: 6px;
      }

      .dark mark.highlight {
        background-color: #76a6da;
        color: #111;
      }

      .menubtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 20 20'%3E%3Cpath fill='none' d='M0 0h20v20H0V0z'/%3E%3Cpath d='M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z'/%3E%3C/svg%3E%0A");
        background-position: center;
        background-repeat: no-repeat;
      }

      .statsbtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg width='36' height='36' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M4 6h28v24H4V6zm0 8h28v8H4m9-16v24h10V5.8' fill='none' stroke='%23000' stroke-width='2'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
      }

      .iobtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36'%3E%3Cpath fill='none' stroke='%23000' stroke-width='2' d='M3 33v-7l6.8-7h16.5l6.7 7v7H3zM3.2 26H33M21 9l5-5.9 5 6h-2.5V15h-5V9H21zm-4.9 0l-5 6-5-6h2.5V3h5v6h2.5z'/%3E%3Cpath fill='none' stroke='%23000' d='M6.1 29.5H10'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
      }

      .visbtn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3E%3Cpath fill='none' stroke='%23333' d='M2.5 4.5h5v15h-5zM9.5 4.5h5v15h-5zM16.5 4.5h5v15h-5z'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
        padding: 15px;
      }

      #vismenu-content {
        left: 0px;
        font-family: Verdana, sans-serif;
      }

      .dark .statsbtn,
      .dark .savebtn,
      .dark .menubtn,
      .dark .iobtn,
      .dark .visbtn {
        filter: invert(1);
      }

      .flexbox {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
      }

      .savebtn {
        background-color: #d6d6d6;
        width: auto;
        height: 30px;
        flex-grow: 1;
        margin: 5px;
        border-radius: 4px;
      }

      .savebtn:active {
        background-color: #0a0;
        color: white;
      }

      .dark .savebtn:active {
        /* This will be inverted */
        background-color: #b3b;
      }

      .stats {
        border-collapse: collapse;
        font-size: 12pt;
        table-layout: fixed;
        width: 100%;
        min-width: 450px;
      }

      .dark .stats td {
        border: 1px solid #bbb;
      }

      .stats td {
        border: 1px solid black;
        padding: 5px;
        word-wrap: break-word;
        text-align: center;
        position: relative;
      }

      #checkbox-stats div {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #checkbox-stats .bar {
        background-color: rgba(28, 251, 0, 0.6);
      }

      .menu {
        position: relative;
        display: inline-block;
        margin: 10px 10px 10px 0px;
      }

      .menu-content {
        font-size: 12pt !important;
        text-align: left !important;
        font-weight: normal !important;
        display: none;
        position: absolute;
        background-color: white;
        right: 0;
        min-width: 300px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
        z-index: 100;
        padding: 8px;
      }

      .dark .menu-content {
        background-color: #111;
      }

      .menu:hover .menu-content {
        display: block;
      }

      .menu:hover .menubtn,
      .menu:hover .iobtn,
      .menu:hover .statsbtn {
        background-color: #eee;
      }

      .menu-label {
        display: inline-block;
        padding: 8px;
        border: 1px solid #ccc;
        border-top: 0;
        width: calc(100% - 18px);
      }

      .menu-label-top {
        border-top: 1px solid #ccc;
      }

      .menu-textbox {
        float: left;
        height: 24px;
        margin: 10px 5px;
        padding: 5px 5px;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 14px;
        box-sizing: border-box;
        border: 1px solid #888;
        border-radius: 4px;
        outline: none;
        background-color: #eee;
        transition:
          background-color 0.2s,
          border 0.2s;
        width: calc(100% - 10px);
      }

      .menu-textbox.invalid,
      .dark .menu-textbox.invalid {
        color: red;
      }

      .dark .menu-textbox {
        background-color: #222;
        color: #eee;
      }

      .radio-container {
        margin: 4px;
      }

      .topmostdiv {
        width: 100%;
        height: 100%;
        background-color: white;
        transition: background-color 0.3s;
      }

      #top {
        height: 78px;
        border-bottom: 2px solid black;
      }

      .dark #top {
        border-bottom: 2px solid #ccc;
      }

      #dbg {
        display: block;
      }

      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: #aaa;
      }

      ::-webkit-scrollbar-thumb {
        background: #666;
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      .slider {
        -webkit-appearance: none;
        width: 100%;
        margin: 3px 0;
        padding: 0;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 3px;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider:focus {
        outline: none;
      }

      .slider::-webkit-slider-runnable-track {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        background: #d3d3d3;
        border-radius: 3px;
        border: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
        margin-top: -4px;
      }

      .dark .slider::-webkit-slider-thumb {
        background: #3d3;
      }

      .slider::-moz-range-thumb {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
      }

      .slider::-moz-range-track {
        height: 8px;
        background: #d3d3d3;
        border-radius: 3px;
      }

      .dark .slider::-moz-range-thumb {
        background: #3d3;
      }

      .slider::-ms-track {
        width: 100%;
        height: 8px;
        border-width: 3px 0;
        background: transparent;
        border-color: transparent;
        color: transparent;
        transition: opacity 0.2s;
      }

      .slider::-ms-fill-lower {
        background: #d3d3d3;
        border: none;
        border-radius: 3px;
      }

      .slider::-ms-fill-upper {
        background: #d3d3d3;
        border: none;
        border-radius: 3px;
      }

      .slider::-ms-thumb {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
        margin: 0;
      }

      .shameless-plug {
        font-size: 0.8em;
        text-align: center;
        display: block;
      }

      a {
        color: #0278a4;
      }

      .dark a {
        color: #00b9fd;
      }

      #frontcanvas,
      #backcanvas {
        touch-action: none;
      }

      .placeholder {
        border: 1px dashed #9f9fda !important;
        background-color: #edf2f7 !important;
      }

      .dragging {
        z-index: 999;
      }

      .dark .dragging > table > tbody > tr {
        background-color: #252c30;
      }

      .dark .placeholder {
        filter: invert(1);
      }

      .column-spacer {
        top: 0;
        left: 0;
        width: calc(100% - 4px);
        position: absolute;
        cursor: pointer;
        user-select: none;
        height: 100%;
      }

      .column-width-handle {
        top: 0;
        right: 0;
        width: 4px;
        position: absolute;
        cursor: col-resize;
        user-select: none;
        height: 100%;
      }

      .column-width-handle:hover {
        background-color: #4f99bd;
      }

      .help-link {
        border: 1px solid #0278a4;
        padding-inline: 0.3rem;
        border-radius: 3px;
        cursor: pointer;
      }

      .dark .help-link {
        border: 1px solid #00b9fd;
      }
    </style>
    <script type="text/javascript">
      ///////////////////////////////////////////////
      /*
  Split.js - v1.3.5
  MIT License
  https://github.com/nathancahill/Split.js
*/
      !(function (e, t) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = t())
          : "function" == typeof define && define.amd
            ? define(t)
            : (e.Split = t());
      })(this, function () {
        "use strict";
        var e = window,
          t = e.document,
          n = "addEventListener",
          i = "removeEventListener",
          r = "getBoundingClientRect",
          s = function () {
            return !1;
          },
          o = e.attachEvent && !e[n],
          a =
            ["", "-webkit-", "-moz-", "-o-"]
              .filter(function (e) {
                var n = t.createElement("div");
                return (
                  (n.style.cssText = "width:" + e + "calc(9px)"),
                  !!n.style.length
                );
              })
              .shift() + "calc",
          l = function (e) {
            return "string" == typeof e || e instanceof String
              ? t.querySelector(e)
              : e;
          };
        return function (u, c) {
          function z(e, t, n) {
            var i = A(y, t, n);
            Object.keys(i).forEach(function (t) {
              return (e.style[t] = i[t]);
            });
          }
          function h(e, t) {
            var n = B(y, t);
            Object.keys(n).forEach(function (t) {
              return (e.style[t] = n[t]);
            });
          }
          function f(e) {
            var t = E[this.a],
              n = E[this.b],
              i = t.size + n.size;
            ((t.size = (e / this.size) * i),
              (n.size = i - (e / this.size) * i),
              z(t.element, t.size, this.aGutterSize),
              z(n.element, n.size, this.bGutterSize));
          }
          function m(e) {
            var t;
            this.dragging &&
              ((t =
                "touches" in e
                  ? e.touches[0][b] - this.start
                  : e[b] - this.start) <=
              E[this.a].minSize + M + this.aGutterSize
                ? (t = E[this.a].minSize + this.aGutterSize)
                : t >= this.size - (E[this.b].minSize + M + this.bGutterSize) &&
                  (t = this.size - (E[this.b].minSize + this.bGutterSize)),
              f.call(this, t),
              c.onDrag && c.onDrag());
          }
          function g() {
            var e = E[this.a].element,
              t = E[this.b].element;
            ((this.size =
              e[r]()[y] + t[r]()[y] + this.aGutterSize + this.bGutterSize),
              (this.start = e[r]()[G]));
          }
          function d() {
            var t = this,
              n = E[t.a].element,
              r = E[t.b].element;
            (t.dragging && c.onDragEnd && c.onDragEnd(),
              (t.dragging = !1),
              e[i]("mouseup", t.stop),
              e[i]("touchend", t.stop),
              e[i]("touchcancel", t.stop),
              t.parent[i]("mousemove", t.move),
              t.parent[i]("touchmove", t.move),
              delete t.stop,
              delete t.move,
              n[i]("selectstart", s),
              n[i]("dragstart", s),
              r[i]("selectstart", s),
              r[i]("dragstart", s),
              (n.style.userSelect = ""),
              (n.style.webkitUserSelect = ""),
              (n.style.MozUserSelect = ""),
              (n.style.pointerEvents = ""),
              (r.style.userSelect = ""),
              (r.style.webkitUserSelect = ""),
              (r.style.MozUserSelect = ""),
              (r.style.pointerEvents = ""),
              (t.gutter.style.cursor = ""),
              (t.parent.style.cursor = ""));
          }
          function S(t) {
            var i = this,
              r = E[i.a].element,
              o = E[i.b].element;
            (!i.dragging && c.onDragStart && c.onDragStart(),
              t.preventDefault(),
              (i.dragging = !0),
              (i.move = m.bind(i)),
              (i.stop = d.bind(i)),
              e[n]("mouseup", i.stop),
              e[n]("touchend", i.stop),
              e[n]("touchcancel", i.stop),
              i.parent[n]("mousemove", i.move),
              i.parent[n]("touchmove", i.move),
              r[n]("selectstart", s),
              r[n]("dragstart", s),
              o[n]("selectstart", s),
              o[n]("dragstart", s),
              (r.style.userSelect = "none"),
              (r.style.webkitUserSelect = "none"),
              (r.style.MozUserSelect = "none"),
              (r.style.pointerEvents = "none"),
              (o.style.userSelect = "none"),
              (o.style.webkitUserSelect = "none"),
              (o.style.MozUserSelect = "none"),
              (o.style.pointerEvents = "none"),
              (i.gutter.style.cursor = j),
              (i.parent.style.cursor = j),
              g.call(i));
          }
          function v(e) {
            e.forEach(function (t, n) {
              if (n > 0) {
                var i = F[n - 1],
                  r = E[i.a],
                  s = E[i.b];
                ((r.size = e[n - 1]),
                  (s.size = t),
                  z(r.element, r.size, i.aGutterSize),
                  z(s.element, s.size, i.bGutterSize));
              }
            });
          }
          function p() {
            F.forEach(function (e) {
              (e.parent.removeChild(e.gutter),
                (E[e.a].element.style[y] = ""),
                (E[e.b].element.style[y] = ""));
            });
          }
          void 0 === c && (c = {});
          var y,
            b,
            G,
            E,
            w = l(u[0]).parentNode,
            D = e.getComputedStyle(w).flexDirection,
            U =
              c.sizes ||
              u.map(function () {
                return 100 / u.length;
              }),
            k = void 0 !== c.minSize ? c.minSize : 100,
            x = Array.isArray(k)
              ? k
              : u.map(function () {
                  return k;
                }),
            L = void 0 !== c.gutterSize ? c.gutterSize : 10,
            M = void 0 !== c.snapOffset ? c.snapOffset : 30,
            O = c.direction || "horizontal",
            j = c.cursor || ("horizontal" === O ? "ew-resize" : "ns-resize"),
            C =
              c.gutter ||
              function (e, n) {
                var i = t.createElement("div");
                return ((i.className = "gutter gutter-" + n), i);
              },
            A =
              c.elementStyle ||
              function (e, t, n) {
                var i = {};
                return (
                  "string" == typeof t || t instanceof String
                    ? (i[e] = t)
                    : (i[e] = o ? t + "%" : a + "(" + t + "% - " + n + "px)"),
                  i
                );
              },
            B =
              c.gutterStyle ||
              function (e, t) {
                return ((n = {}), (n[e] = t + "px"), n);
                var n;
              };
          "horizontal" === O
            ? ((y = "width"),
              "clientWidth",
              (b = "clientX"),
              (G = "left"),
              "paddingLeft")
            : "vertical" === O &&
              ((y = "height"),
              "clientHeight",
              (b = "clientY"),
              (G = "top"),
              "paddingTop");
          var F = [];
          return (
            (E = u.map(function (e, t) {
              var i,
                s = { element: l(e), size: U[t], minSize: x[t] };
              if (
                t > 0 &&
                ((i = {
                  a: t - 1,
                  b: t,
                  dragging: !1,
                  isFirst: 1 === t,
                  isLast: t === u.length - 1,
                  direction: O,
                  parent: w,
                }),
                (i.aGutterSize = L),
                (i.bGutterSize = L),
                i.isFirst && (i.aGutterSize = L / 2),
                i.isLast && (i.bGutterSize = L / 2),
                "row-reverse" === D || "column-reverse" === D)
              ) {
                var a = i.a;
                ((i.a = i.b), (i.b = a));
              }
              if (!o && t > 0) {
                var c = C(t, O);
                (h(c, L),
                  c[n]("mousedown", S.bind(i)),
                  c[n]("touchstart", S.bind(i)),
                  w.insertBefore(c, s.element),
                  (i.gutter = c));
              }
              0 === t || t === u.length - 1
                ? z(s.element, s.size, L / 2)
                : z(s.element, s.size, L);
              var f = s.element[r]()[y];
              return (f < s.minSize && (s.minSize = f), t > 0 && F.push(i), s);
            })),
            o
              ? { setSizes: v, destroy: p }
              : {
                  setSizes: v,
                  getSizes: function () {
                    return E.map(function (e) {
                      return e.size;
                    });
                  },
                  collapse: function (e) {
                    if (e === F.length) {
                      var t = F[e - 1];
                      (g.call(t), o || f.call(t, t.size - t.bGutterSize));
                    } else {
                      var n = F[e];
                      (g.call(n), o || f.call(n, n.aGutterSize));
                    }
                  },
                  destroy: p,
                }
          );
        };
      });

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
      // This work is free. You can redistribute it and/or modify it
      // under the terms of the WTFPL, Version 2
      // For more information see LICENSE.txt or http://www.wtfpl.net/
      //
      // For more information, the home page:
      // http://pieroxy.net/blog/pages/lz-string/testing.html
      //
      // LZ-based compression algorithm, version 1.4.4
      var LZString = (function () {
        var o = String.fromCharCode,
          i = {};
        var n = {
          decompressFromBase64: function (o) {
            return null == o
              ? ""
              : "" == o
                ? null
                : n._decompress(o.length, 32, function (n) {
                    return (function (o, n) {
                      if (!i[o]) {
                        i[o] = {};
                        for (var t = 0; t < o.length; t++)
                          i[o][o.charAt(t)] = t;
                      }
                      return i[o][n];
                    })(
                      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                      o.charAt(n),
                    );
                  });
          },
          _decompress: function (i, n, t) {
            var r,
              e,
              a,
              s,
              p,
              u,
              l,
              f = [],
              c = 4,
              d = 4,
              h = 3,
              v = "",
              g = [],
              m = { val: t(0), position: n, index: 1 };
            for (r = 0; r < 3; r += 1) f[r] = r;
            for (a = 0, p = Math.pow(2, 2), u = 1; u != p; )
              ((s = m.val & m.position),
                (m.position >>= 1),
                0 == m.position && ((m.position = n), (m.val = t(m.index++))),
                (a |= (s > 0 ? 1 : 0) * u),
                (u <<= 1));
            switch (a) {
              case 0:
                for (a = 0, p = Math.pow(2, 8), u = 1; u != p; )
                  ((s = m.val & m.position),
                    (m.position >>= 1),
                    0 == m.position &&
                      ((m.position = n), (m.val = t(m.index++))),
                    (a |= (s > 0 ? 1 : 0) * u),
                    (u <<= 1));
                l = o(a);
                break;
              case 1:
                for (a = 0, p = Math.pow(2, 16), u = 1; u != p; )
                  ((s = m.val & m.position),
                    (m.position >>= 1),
                    0 == m.position &&
                      ((m.position = n), (m.val = t(m.index++))),
                    (a |= (s > 0 ? 1 : 0) * u),
                    (u <<= 1));
                l = o(a);
                break;
              case 2:
                return "";
            }
            for (f[3] = l, e = l, g.push(l); ; ) {
              if (m.index > i) return "";
              for (a = 0, p = Math.pow(2, h), u = 1; u != p; )
                ((s = m.val & m.position),
                  (m.position >>= 1),
                  0 == m.position && ((m.position = n), (m.val = t(m.index++))),
                  (a |= (s > 0 ? 1 : 0) * u),
                  (u <<= 1));
              switch ((l = a)) {
                case 0:
                  for (a = 0, p = Math.pow(2, 8), u = 1; u != p; )
                    ((s = m.val & m.position),
                      (m.position >>= 1),
                      0 == m.position &&
                        ((m.position = n), (m.val = t(m.index++))),
                      (a |= (s > 0 ? 1 : 0) * u),
                      (u <<= 1));
                  ((f[d++] = o(a)), (l = d - 1), c--);
                  break;
                case 1:
                  for (a = 0, p = Math.pow(2, 16), u = 1; u != p; )
                    ((s = m.val & m.position),
                      (m.position >>= 1),
                      0 == m.position &&
                        ((m.position = n), (m.val = t(m.index++))),
                      (a |= (s > 0 ? 1 : 0) * u),
                      (u <<= 1));
                  ((f[d++] = o(a)), (l = d - 1), c--);
                  break;
                case 2:
                  return g.join("");
              }
              if ((0 == c && ((c = Math.pow(2, h)), h++), f[l])) v = f[l];
              else {
                if (l !== d) return null;
                v = e + e.charAt(0);
              }
              (g.push(v),
                (f[d++] = e + v.charAt(0)),
                (e = v),
                0 == --c && ((c = Math.pow(2, h)), h++));
            }
          },
        };
        return n;
      })();
      "function" == typeof define && define.amd
        ? define(function () {
            return LZString;
          })
        : "undefined" != typeof module && null != module
          ? (module.exports = LZString)
          : "undefined" != typeof angular &&
            null != angular &&
            angular.module("LZString", []).factory("LZString", function () {
              return LZString;
            });
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /*!
       * PEP v0.4.3 | https://github.com/jquery/PEP
       * Copyright jQuery Foundation and other contributors | http://jquery.org/license
       */
      !(function (a, b) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = b())
          : "function" == typeof define && define.amd
            ? define(b)
            : (a.PointerEventsPolyfill = b());
      })(this, function () {
        "use strict";
        function a(a, b) {
          b = b || Object.create(null);
          var c = document.createEvent("Event");
          c.initEvent(a, b.bubbles || !1, b.cancelable || !1);
          for (var d, e = 2; e < m.length; e++)
            ((d = m[e]), (c[d] = b[d] || n[e]));
          c.buttons = b.buttons || 0;
          var f = 0;
          return (
            (f = b.pressure && c.buttons ? b.pressure : c.buttons ? 0.5 : 0),
            (c.x = c.clientX),
            (c.y = c.clientY),
            (c.pointerId = b.pointerId || 0),
            (c.width = b.width || 0),
            (c.height = b.height || 0),
            (c.pressure = f),
            (c.tiltX = b.tiltX || 0),
            (c.tiltY = b.tiltY || 0),
            (c.twist = b.twist || 0),
            (c.tangentialPressure = b.tangentialPressure || 0),
            (c.pointerType = b.pointerType || ""),
            (c.hwTimestamp = b.hwTimestamp || 0),
            (c.isPrimary = b.isPrimary || !1),
            c
          );
        }
        function b() {
          ((this.array = []), (this.size = 0));
        }
        function c(a, b, c, d) {
          ((this.addCallback = a.bind(d)),
            (this.removeCallback = b.bind(d)),
            (this.changedCallback = c.bind(d)),
            A && (this.observer = new A(this.mutationWatcher.bind(this))));
        }
        function d(a) {
          return "body /shadow-deep/ " + e(a);
        }
        function e(a) {
          return '[touch-action="' + a + '"]';
        }
        function f(a) {
          return "{ -ms-touch-action: " + a + "; touch-action: " + a + "; }";
        }
        function g() {
          if (F) {
            D.forEach(function (a) {
              String(a) === a
                ? ((E += e(a) + f(a) + "\n"), G && (E += d(a) + f(a) + "\n"))
                : ((E += a.selectors.map(e) + f(a.rule) + "\n"),
                  G && (E += a.selectors.map(d) + f(a.rule) + "\n"));
            });
            var a = document.createElement("style");
            ((a.textContent = E), document.head.appendChild(a));
          }
        }
        function h() {
          if (!window.PointerEvent) {
            if (
              ((window.PointerEvent = a), window.navigator.msPointerEnabled)
            ) {
              var b = window.navigator.msMaxTouchPoints;
              (Object.defineProperty(window.navigator, "maxTouchPoints", {
                value: b,
                enumerable: !0,
              }),
                u.registerSource("ms", _));
            } else
              (Object.defineProperty(window.navigator, "maxTouchPoints", {
                value: 0,
                enumerable: !0,
              }),
                u.registerSource("mouse", N),
                void 0 !== window.ontouchstart && u.registerSource("touch", V));
            u.register(document);
          }
        }
        function i(a) {
          if (!u.pointermap.has(a)) {
            var b = new Error("InvalidPointerId");
            throw ((b.name = "InvalidPointerId"), b);
          }
        }
        function j(a) {
          for (var b = a.parentNode; b && b !== a.ownerDocument; )
            b = b.parentNode;
          if (!b) {
            var c = new Error("InvalidStateError");
            throw ((c.name = "InvalidStateError"), c);
          }
        }
        function k(a) {
          var b = u.pointermap.get(a);
          return 0 !== b.buttons;
        }
        function l() {
          window.Element &&
            !Element.prototype.setPointerCapture &&
            Object.defineProperties(Element.prototype, {
              setPointerCapture: { value: W },
              releasePointerCapture: { value: X },
              hasPointerCapture: { value: Y },
            });
        }
        var m = [
            "bubbles",
            "cancelable",
            "view",
            "detail",
            "screenX",
            "screenY",
            "clientX",
            "clientY",
            "ctrlKey",
            "altKey",
            "shiftKey",
            "metaKey",
            "button",
            "relatedTarget",
            "pageX",
            "pageY",
          ],
          n = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0],
          o = window.Map && window.Map.prototype.forEach,
          p = o ? Map : b;
        b.prototype = {
          set: function (a, b) {
            return void 0 === b
              ? this["delete"](a)
              : (this.has(a) || this.size++, void (this.array[a] = b));
          },
          has: function (a) {
            return void 0 !== this.array[a];
          },
          delete: function (a) {
            this.has(a) && (delete this.array[a], this.size--);
          },
          get: function (a) {
            return this.array[a];
          },
          clear: function () {
            ((this.array.length = 0), (this.size = 0));
          },
          forEach: function (a, b) {
            return this.array.forEach(function (c, d) {
              a.call(b, c, d, this);
            }, this);
          },
        };
        var q = [
            "bubbles",
            "cancelable",
            "view",
            "detail",
            "screenX",
            "screenY",
            "clientX",
            "clientY",
            "ctrlKey",
            "altKey",
            "shiftKey",
            "metaKey",
            "button",
            "relatedTarget",
            "buttons",
            "pointerId",
            "width",
            "height",
            "pressure",
            "tiltX",
            "tiltY",
            "pointerType",
            "hwTimestamp",
            "isPrimary",
            "type",
            "target",
            "currentTarget",
            "which",
            "pageX",
            "pageY",
            "timeStamp",
          ],
          r = [
            !1,
            !1,
            null,
            null,
            0,
            0,
            0,
            0,
            !1,
            !1,
            !1,
            !1,
            0,
            null,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            "",
            0,
            !1,
            "",
            null,
            null,
            0,
            0,
            0,
            0,
          ],
          s = {
            pointerover: 1,
            pointerout: 1,
            pointerenter: 1,
            pointerleave: 1,
          },
          t = "undefined" != typeof SVGElementInstance,
          u = {
            pointermap: new p(),
            eventMap: Object.create(null),
            captureInfo: Object.create(null),
            eventSources: Object.create(null),
            eventSourceList: [],
            registerSource: function (a, b) {
              var c = b,
                d = c.events;
              d &&
                (d.forEach(function (a) {
                  c[a] && (this.eventMap[a] = c[a].bind(c));
                }, this),
                (this.eventSources[a] = c),
                this.eventSourceList.push(c));
            },
            register: function (a) {
              for (
                var b, c = this.eventSourceList.length, d = 0;
                d < c && (b = this.eventSourceList[d]);
                d++
              )
                b.register.call(b, a);
            },
            unregister: function (a) {
              for (
                var b, c = this.eventSourceList.length, d = 0;
                d < c && (b = this.eventSourceList[d]);
                d++
              )
                b.unregister.call(b, a);
            },
            contains: function (a, b) {
              try {
                return a.contains(b);
              } catch (c) {
                return !1;
              }
            },
            down: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerdown", a));
            },
            move: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointermove", a));
            },
            up: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerup", a));
            },
            enter: function (a) {
              ((a.bubbles = !1), this.fireEvent("pointerenter", a));
            },
            leave: function (a) {
              ((a.bubbles = !1), this.fireEvent("pointerleave", a));
            },
            over: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerover", a));
            },
            out: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerout", a));
            },
            cancel: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointercancel", a));
            },
            leaveOut: function (a) {
              (this.out(a), this.propagate(a, this.leave, !1));
            },
            enterOver: function (a) {
              (this.over(a), this.propagate(a, this.enter, !0));
            },
            eventHandler: function (a) {
              if (!a._handledByPE) {
                var b = a.type,
                  c = this.eventMap && this.eventMap[b];
                (c && c(a), (a._handledByPE = !0));
              }
            },
            listen: function (a, b) {
              b.forEach(function (b) {
                this.addEvent(a, b);
              }, this);
            },
            unlisten: function (a, b) {
              b.forEach(function (b) {
                this.removeEvent(a, b);
              }, this);
            },
            addEvent: function (a, b) {
              a.addEventListener(b, this.boundHandler);
            },
            removeEvent: function (a, b) {
              a.removeEventListener(b, this.boundHandler);
            },
            makeEvent: function (b, c) {
              this.captureInfo[c.pointerId] && (c.relatedTarget = null);
              var d = new a(b, c);
              return (
                c.preventDefault && (d.preventDefault = c.preventDefault),
                (d._target = d._target || c.target),
                d
              );
            },
            fireEvent: function (a, b) {
              var c = this.makeEvent(a, b);
              return this.dispatchEvent(c);
            },
            cloneEvent: function (a) {
              for (var b, c = Object.create(null), d = 0; d < q.length; d++)
                ((b = q[d]),
                  (c[b] = a[b] || r[d]),
                  !t ||
                    ("target" !== b && "relatedTarget" !== b) ||
                    (c[b] instanceof SVGElementInstance &&
                      (c[b] = c[b].correspondingUseElement)));
              return (
                a.preventDefault &&
                  (c.preventDefault = function () {
                    a.preventDefault();
                  }),
                c
              );
            },
            getTarget: function (a) {
              var b = this.captureInfo[a.pointerId];
              return b
                ? a._target !== b && a.type in s
                  ? void 0
                  : b
                : a._target;
            },
            propagate: function (a, b, c) {
              for (
                var d = a.target, e = [];
                d !== document && !d.contains(a.relatedTarget);

              )
                if ((e.push(d), (d = d.parentNode), !d)) return;
              (c && e.reverse(),
                e.forEach(function (c) {
                  ((a.target = c), b.call(this, a));
                }, this));
            },
            setCapture: function (b, c, d) {
              (this.captureInfo[b] && this.releaseCapture(b, d),
                (this.captureInfo[b] = c),
                (this.implicitRelease = this.releaseCapture.bind(this, b, d)),
                document.addEventListener("pointerup", this.implicitRelease),
                document.addEventListener(
                  "pointercancel",
                  this.implicitRelease,
                ));
              var e = new a("gotpointercapture");
              ((e.pointerId = b),
                (e._target = c),
                d || this.asyncDispatchEvent(e));
            },
            releaseCapture: function (b, c) {
              var d = this.captureInfo[b];
              if (d) {
                ((this.captureInfo[b] = void 0),
                  document.removeEventListener(
                    "pointerup",
                    this.implicitRelease,
                  ),
                  document.removeEventListener(
                    "pointercancel",
                    this.implicitRelease,
                  ));
                var e = new a("lostpointercapture");
                ((e.pointerId = b),
                  (e._target = d),
                  c || this.asyncDispatchEvent(e));
              }
            },
            dispatchEvent: /*scope.external.dispatchEvent || */ function (a) {
              var b = this.getTarget(a);
              if (b) return b.dispatchEvent(a);
            },
            asyncDispatchEvent: function (a) {
              requestAnimationFrame(this.dispatchEvent.bind(this, a));
            },
          };
        u.boundHandler = u.eventHandler.bind(u);
        var v = {
            shadow: function (a) {
              if (a) return a.shadowRoot || a.webkitShadowRoot;
            },
            canTarget: function (a) {
              return a && Boolean(a.elementFromPoint);
            },
            targetingShadow: function (a) {
              var b = this.shadow(a);
              if (this.canTarget(b)) return b;
            },
            olderShadow: function (a) {
              var b = a.olderShadowRoot;
              if (!b) {
                var c = a.querySelector("shadow");
                c && (b = c.olderShadowRoot);
              }
              return b;
            },
            allShadows: function (a) {
              for (var b = [], c = this.shadow(a); c; )
                (b.push(c), (c = this.olderShadow(c)));
              return b;
            },
            searchRoot: function (a, b, c) {
              if (a) {
                var d,
                  e,
                  f = a.elementFromPoint(b, c);
                for (e = this.targetingShadow(f); e; ) {
                  if ((d = e.elementFromPoint(b, c))) {
                    var g = this.targetingShadow(d);
                    return this.searchRoot(g, b, c) || d;
                  }
                  e = this.olderShadow(e);
                }
                return f;
              }
            },
            owner: function (a) {
              for (var b = a; b.parentNode; ) b = b.parentNode;
              return (
                b.nodeType !== Node.DOCUMENT_NODE &&
                  b.nodeType !== Node.DOCUMENT_FRAGMENT_NODE &&
                  (b = document),
                b
              );
            },
            findTarget: function (a) {
              var b = a.clientX,
                c = a.clientY,
                d = this.owner(a.target);
              return (
                d.elementFromPoint(b, c) || (d = document),
                this.searchRoot(d, b, c)
              );
            },
          },
          w = Array.prototype.forEach.call.bind(Array.prototype.forEach),
          x = Array.prototype.map.call.bind(Array.prototype.map),
          y = Array.prototype.slice.call.bind(Array.prototype.slice),
          z = Array.prototype.filter.call.bind(Array.prototype.filter),
          A = window.MutationObserver || window.WebKitMutationObserver,
          B = "[touch-action]",
          C = {
            subtree: !0,
            childList: !0,
            attributes: !0,
            attributeOldValue: !0,
            attributeFilter: ["touch-action"],
          };
        c.prototype = {
          watchSubtree: function (a) {
            //
            this.observer && v.canTarget(a) && this.observer.observe(a, C);
          },
          enableOnSubtree: function (a) {
            (this.watchSubtree(a),
              a === document && "complete" !== document.readyState
                ? this.installOnLoad()
                : this.installNewSubtree(a));
          },
          installNewSubtree: function (a) {
            w(this.findElements(a), this.addElement, this);
          },
          findElements: function (a) {
            return a.querySelectorAll ? a.querySelectorAll(B) : [];
          },
          removeElement: function (a) {
            this.removeCallback(a);
          },
          addElement: function (a) {
            this.addCallback(a);
          },
          elementChanged: function (a, b) {
            this.changedCallback(a, b);
          },
          concatLists: function (a, b) {
            return a.concat(y(b));
          },
          installOnLoad: function () {
            document.addEventListener(
              "readystatechange",
              function () {
                "complete" === document.readyState &&
                  this.installNewSubtree(document);
              }.bind(this),
            );
          },
          isElement: function (a) {
            return a.nodeType === Node.ELEMENT_NODE;
          },
          flattenMutationTree: function (a) {
            var b = x(a, this.findElements, this);
            return (
              b.push(z(a, this.isElement)),
              b.reduce(this.concatLists, [])
            );
          },
          mutationWatcher: function (a) {
            a.forEach(this.mutationHandler, this);
          },
          mutationHandler: function (a) {
            if ("childList" === a.type) {
              var b = this.flattenMutationTree(a.addedNodes);
              b.forEach(this.addElement, this);
              var c = this.flattenMutationTree(a.removedNodes);
              c.forEach(this.removeElement, this);
            } else
              "attributes" === a.type &&
                this.elementChanged(a.target, a.oldValue);
          },
        };
        var D = [
            "none",
            "auto",
            "pan-x",
            "pan-y",
            { rule: "pan-x pan-y", selectors: ["pan-x pan-y", "pan-y pan-x"] },
          ],
          E = "",
          F = window.PointerEvent || window.MSPointerEvent,
          G = !window.ShadowDOMPolyfill && document.head.createShadowRoot,
          H = u.pointermap,
          I = 25,
          J = [1, 4, 2, 8, 16],
          K = !1;
        try {
          K = 1 === new MouseEvent("test", { buttons: 1 }).buttons;
        } catch (L) {}
        var M,
          N = {
            POINTER_ID: 1,
            POINTER_TYPE: "mouse",
            events: [
              "mousedown",
              "mousemove",
              "mouseup",
              "mouseover",
              "mouseout",
            ],
            register: function (a) {
              u.listen(a, this.events);
            },
            unregister: function (a) {
              u.unlisten(a, this.events);
            },
            lastTouches: [],
            isEventSimulatedFromTouch: function (a) {
              for (
                var b,
                  c = this.lastTouches,
                  d = a.clientX,
                  e = a.clientY,
                  f = 0,
                  g = c.length;
                f < g && (b = c[f]);
                f++
              ) {
                var h = Math.abs(d - b.x),
                  i = Math.abs(e - b.y);
                if (h <= I && i <= I) return !0;
              }
            },
            prepareEvent: function (a) {
              var b = u.cloneEvent(a),
                c = b.preventDefault;
              return (
                (b.preventDefault = function () {
                  (a.preventDefault(), c());
                }),
                (b.pointerId = this.POINTER_ID),
                (b.isPrimary = !0),
                (b.pointerType = this.POINTER_TYPE),
                b
              );
            },
            prepareButtonsForMove: function (a, b) {
              var c = H.get(this.POINTER_ID);
              (0 !== b.which && c ? (a.buttons = c.buttons) : (a.buttons = 0),
                (b.buttons = a.buttons));
            },
            mousedown: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = H.get(this.POINTER_ID),
                  c = this.prepareEvent(a);
                (K ||
                  ((c.buttons = J[c.button]),
                  b && (c.buttons |= b.buttons),
                  (a.buttons = c.buttons)),
                  H.set(this.POINTER_ID, a),
                  b && 0 !== b.buttons ? u.move(c) : u.down(c));
              }
            },
            mousemove: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  H.set(this.POINTER_ID, a),
                  u.move(b));
              }
            },
            mouseup: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = H.get(this.POINTER_ID),
                  c = this.prepareEvent(a);
                if (!K) {
                  var d = J[c.button];
                  ((c.buttons = b ? b.buttons & ~d : 0),
                    (a.buttons = c.buttons));
                }
                (H.set(this.POINTER_ID, a),
                  (c.buttons &= ~J[c.button]),
                  0 === c.buttons ? u.up(c) : u.move(c));
              }
            },
            mouseover: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  H.set(this.POINTER_ID, a),
                  u.enterOver(b));
              }
            },
            mouseout: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  u.leaveOut(b));
              }
            },
            cancel: function (a) {
              var b = this.prepareEvent(a);
              (u.cancel(b), this.deactivateMouse());
            },
            deactivateMouse: function () {
              H["delete"](this.POINTER_ID);
            },
          },
          O = u.captureInfo,
          P = v.findTarget.bind(v),
          Q = v.allShadows.bind(v),
          R = u.pointermap,
          S = 2500,
          T = 200,
          U = "touch-action",
          V = {
            events: ["touchstart", "touchmove", "touchend", "touchcancel"],
            register: function (a) {
              M.enableOnSubtree(a);
            },
            unregister: function () {},
            elementAdded: function (a) {
              var b = a.getAttribute(U),
                c = this.touchActionToScrollType(b);
              c &&
                ((a._scrollType = c),
                u.listen(a, this.events),
                Q(a).forEach(function (a) {
                  ((a._scrollType = c), u.listen(a, this.events));
                }, this));
            },
            elementRemoved: function (a) {
              ((a._scrollType = void 0),
                u.unlisten(a, this.events),
                Q(a).forEach(function (a) {
                  ((a._scrollType = void 0), u.unlisten(a, this.events));
                }, this));
            },
            elementChanged: function (a, b) {
              var c = a.getAttribute(U),
                d = this.touchActionToScrollType(c),
                e = this.touchActionToScrollType(b);
              d && e
                ? ((a._scrollType = d),
                  Q(a).forEach(function (a) {
                    a._scrollType = d;
                  }, this))
                : e
                  ? this.elementRemoved(a)
                  : d && this.elementAdded(a);
            },
            scrollTypes: {
              EMITTER: "none",
              XSCROLLER: "pan-x",
              YSCROLLER: "pan-y",
              SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/,
            },
            touchActionToScrollType: function (a) {
              var b = a,
                c = this.scrollTypes;
              return "none" === b
                ? "none"
                : b === c.XSCROLLER
                  ? "X"
                  : b === c.YSCROLLER
                    ? "Y"
                    : c.SCROLLER.exec(b)
                      ? "XY"
                      : void 0;
            },
            POINTER_TYPE: "touch",
            firstTouch: null,
            isPrimaryTouch: function (a) {
              return this.firstTouch === a.identifier;
            },
            setPrimaryTouch: function (a) {
              (0 === R.size || (1 === R.size && R.has(1))) &&
                ((this.firstTouch = a.identifier),
                (this.firstXY = { X: a.clientX, Y: a.clientY }),
                (this.scrolling = !1),
                this.cancelResetClickCount());
            },
            removePrimaryPointer: function (a) {
              a.isPrimary &&
                ((this.firstTouch = null),
                (this.firstXY = null),
                this.resetClickCount());
            },
            clickCount: 0,
            resetId: null,
            resetClickCount: function () {
              var a = function () {
                ((this.clickCount = 0), (this.resetId = null));
              }.bind(this);
              this.resetId = setTimeout(a, T);
            },
            cancelResetClickCount: function () {
              this.resetId && clearTimeout(this.resetId);
            },
            typeToButtons: function (a) {
              var b = 0;
              return (("touchstart" !== a && "touchmove" !== a) || (b = 1), b);
            },
            touchToPointer: function (a) {
              var b = this.currentTouchEvent,
                c = u.cloneEvent(a),
                d = (c.pointerId = a.identifier + 2);
              ((c.target = O[d] || P(c)),
                (c.bubbles = !0),
                (c.cancelable = !0),
                (c.detail = this.clickCount),
                (c.button = 0),
                (c.buttons = this.typeToButtons(b.type)),
                (c.width = 2 * (a.radiusX || a.webkitRadiusX || 0)),
                (c.height = 2 * (a.radiusY || a.webkitRadiusY || 0)),
                (c.pressure = a.force || a.webkitForce || 0.5),
                (c.isPrimary = this.isPrimaryTouch(a)),
                (c.pointerType = this.POINTER_TYPE),
                (c.altKey = b.altKey),
                (c.ctrlKey = b.ctrlKey),
                (c.metaKey = b.metaKey),
                (c.shiftKey = b.shiftKey));
              var e = this;
              return (
                (c.preventDefault = function () {
                  ((e.scrolling = !1), (e.firstXY = null), b.preventDefault());
                }),
                c
              );
            },
            processTouches: function (a, b) {
              var c = a.changedTouches;
              this.currentTouchEvent = a;
              for (var d, e = 0; e < c.length; e++)
                ((d = c[e]), b.call(this, this.touchToPointer(d)));
            },
            shouldScroll: function (a) {
              if (this.firstXY) {
                var b,
                  c = a.currentTarget._scrollType;
                if ("none" === c) b = !1;
                else if ("XY" === c) b = !0;
                else {
                  var d = a.changedTouches[0],
                    e = c,
                    f = "Y" === c ? "X" : "Y",
                    g = Math.abs(d["client" + e] - this.firstXY[e]),
                    h = Math.abs(d["client" + f] - this.firstXY[f]);
                  b = g >= h;
                }
                return ((this.firstXY = null), b);
              }
            },
            findTouch: function (a, b) {
              for (var c, d = 0, e = a.length; d < e && (c = a[d]); d++)
                if (c.identifier === b) return !0;
            },
            vacuumTouches: function (a) {
              var b = a.touches;
              if (R.size >= b.length) {
                var c = [];
                (R.forEach(function (a, d) {
                  if (1 !== d && !this.findTouch(b, d - 2)) {
                    var e = a.out;
                    c.push(e);
                  }
                }, this),
                  c.forEach(this.cancelOut, this));
              }
            },
            touchstart: function (a) {
              (this.vacuumTouches(a),
                this.setPrimaryTouch(a.changedTouches[0]),
                this.dedupSynthMouse(a),
                this.scrolling ||
                  (this.clickCount++, this.processTouches(a, this.overDown)));
            },
            overDown: function (a) {
              (R.set(a.pointerId, {
                target: a.target,
                out: a,
                outTarget: a.target,
              }),
                u.enterOver(a),
                u.down(a));
            },
            touchmove: function (a) {
              this.scrolling ||
                (this.shouldScroll(a)
                  ? ((this.scrolling = !0), this.touchcancel(a))
                  : (a.preventDefault(),
                    this.processTouches(a, this.moveOverOut)));
            },
            moveOverOut: function (a) {
              var b = a,
                c = R.get(b.pointerId);
              if (c) {
                var d = c.out,
                  e = c.outTarget;
                (u.move(b),
                  d &&
                    e !== b.target &&
                    ((d.relatedTarget = b.target),
                    (b.relatedTarget = e),
                    (d.target = e),
                    b.target
                      ? (u.leaveOut(d), u.enterOver(b))
                      : ((b.target = e),
                        (b.relatedTarget = null),
                        this.cancelOut(b))),
                  (c.out = b),
                  (c.outTarget = b.target));
              }
            },
            touchend: function (a) {
              (this.dedupSynthMouse(a), this.processTouches(a, this.upOut));
            },
            upOut: function (a) {
              (this.scrolling || (u.up(a), u.leaveOut(a)),
                this.cleanUpPointer(a));
            },
            touchcancel: function (a) {
              this.processTouches(a, this.cancelOut);
            },
            cancelOut: function (a) {
              (u.cancel(a), u.leaveOut(a), this.cleanUpPointer(a));
            },
            cleanUpPointer: function (a) {
              (R["delete"](a.pointerId), this.removePrimaryPointer(a));
            },
            dedupSynthMouse: function (a) {
              var b = N.lastTouches,
                c = a.changedTouches[0];
              if (this.isPrimaryTouch(c)) {
                var d = { x: c.clientX, y: c.clientY };
                b.push(d);
                var e = function (a, b) {
                  var c = a.indexOf(b);
                  c > -1 && a.splice(c, 1);
                }.bind(null, b, d);
                setTimeout(e, S);
              }
            },
          };
        M = new c(V.elementAdded, V.elementRemoved, V.elementChanged, V);
        var W,
          X,
          Y,
          Z = u.pointermap,
          $ =
            window.MSPointerEvent &&
            "number" == typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,
          _ = {
            events: [
              "MSPointerDown",
              "MSPointerMove",
              "MSPointerUp",
              "MSPointerOut",
              "MSPointerOver",
              "MSPointerCancel",
              "MSGotPointerCapture",
              "MSLostPointerCapture",
            ],
            register: function (a) {
              u.listen(a, this.events);
            },
            unregister: function (a) {
              u.unlisten(a, this.events);
            },
            POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
            prepareEvent: function (a) {
              var b = a;
              return (
                $ &&
                  ((b = u.cloneEvent(a)),
                  (b.pointerType = this.POINTER_TYPES[a.pointerType])),
                b
              );
            },
            cleanup: function (a) {
              Z["delete"](a);
            },
            MSPointerDown: function (a) {
              Z.set(a.pointerId, a);
              var b = this.prepareEvent(a);
              u.down(b);
            },
            MSPointerMove: function (a) {
              var b = this.prepareEvent(a);
              u.move(b);
            },
            MSPointerUp: function (a) {
              var b = this.prepareEvent(a);
              (u.up(b), this.cleanup(a.pointerId));
            },
            MSPointerOut: function (a) {
              var b = this.prepareEvent(a);
              u.leaveOut(b);
            },
            MSPointerOver: function (a) {
              var b = this.prepareEvent(a);
              u.enterOver(b);
            },
            MSPointerCancel: function (a) {
              var b = this.prepareEvent(a);
              (u.cancel(b), this.cleanup(a.pointerId));
            },
            MSLostPointerCapture: function (a) {
              var b = u.makeEvent("lostpointercapture", a);
              u.dispatchEvent(b);
            },
            MSGotPointerCapture: function (a) {
              var b = u.makeEvent("gotpointercapture", a);
              u.dispatchEvent(b);
            },
          },
          aa = window.navigator;
        (aa.msPointerEnabled
          ? ((W = function (a) {
              (i(a),
                j(this),
                k(a) &&
                  (u.setCapture(a, this, !0), this.msSetPointerCapture(a)));
            }),
            (X = function (a) {
              (i(a), u.releaseCapture(a, !0), this.msReleasePointerCapture(a));
            }))
          : ((W = function (a) {
              (i(a), j(this), k(a) && u.setCapture(a, this));
            }),
            (X = function (a) {
              (i(a), u.releaseCapture(a));
            })),
          (Y = function (a) {
            return !!u.captureInfo[a];
          }),
          g(),
          h(),
          l());
        var ba = {
          dispatcher: u,
          Installer: c,
          PointerEvent: a,
          PointerMap: p,
          targetFinding: v,
        };
        return ba;
      });

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      var config = {
        dark_mode: false,
        show_pads: true,
        show_fabrication: false,
        show_silkscreen: true,
        highlight_pin1: true,
        redraw_on_drag: true,
        board_rotation: 0,
        checkboxes: "Sourced,Placed",
        bom_view: "left-right",
        layer_view: "FB",
        fields: ["Value", "Footprint"],
      };
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      var pcbdata = JSON.parse(
        LZString.decompressFromBase64(
          "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",
        ),
      );
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* Utility functions */

      var storagePrefix =
        "KiCad_HTML_BOM__" +
        pcbdata.metadata.title +
        "__" +
        pcbdata.metadata.revision +
        "__#";
      var storage;

      function initStorage(key) {
        try {
          window.localStorage.getItem("blank");
          storage = window.localStorage;
        } catch (e) {
          // localStorage not available
        }
        if (!storage) {
          try {
            window.sessionStorage.getItem("blank");
            storage = window.sessionStorage;
          } catch (e) {
            // sessionStorage also not available
          }
        }
      }

      function readStorage(key) {
        if (storage) {
          return storage.getItem(storagePrefix + key);
        } else {
          return null;
        }
      }

      function writeStorage(key, value) {
        if (storage) {
          storage.setItem(storagePrefix + key, value);
        }
      }

      function fancyDblClickHandler(el, onsingle, ondouble) {
        return function () {
          if (el.getAttribute("data-dblclick") == null) {
            el.setAttribute("data-dblclick", 1);
            setTimeout(function () {
              if (el.getAttribute("data-dblclick") == 1) {
                onsingle();
              }
              el.removeAttribute("data-dblclick");
            }, 200);
          } else {
            el.removeAttribute("data-dblclick");
            ondouble();
          }
        };
      }

      function smoothScrollToRow(rowid) {
        document.getElementById(rowid).scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest",
        });
      }

      function focusInputField(input) {
        input.scrollIntoView(false);
        input.focus();
        input.select();
      }

      function saveBomTable(output) {
        var text = "";
        for (var node of bomhead.childNodes[0].childNodes) {
          if (node.firstChild) {
            text +=
              output == "csv"
                ? `"${node.firstChild.nodeValue}"`
                : node.firstChild.nodeValue;
          }
          if (node != bomhead.childNodes[0].lastChild) {
            text += output == "csv" ? "," : "\t";
          }
        }
        text += "\n";
        for (var row of bombody.childNodes) {
          for (var cell of row.childNodes) {
            let val = "";
            for (var node of cell.childNodes) {
              if (node.nodeName == "INPUT") {
                if (node.checked) {
                  val += "";
                }
              } else if (node.nodeName == "MARK") {
                val += node.firstChild.nodeValue;
              } else {
                val += node.nodeValue;
              }
            }
            if (output == "csv") {
              val = val.replace(/\"/g, '""'); // pair of double-quote characters
              if (isNumeric(val)) {
                val = +val; // use number
              } else {
                val = `"${val}"`; // enclosed within double-quote
              }
            }
            text += val;
            if (cell != row.lastChild) {
              text += output == "csv" ? "," : "\t";
            }
          }
          text += "\n";
        }

        if (output != "clipboard") {
          // To file: csv or txt
          var blob = new Blob([text], {
            type: `text/${output}`,
          });
          saveFile(`${pcbdata.metadata.title}.${output}`, blob);
        } else {
          // To clipboard
          var textArea = document.createElement("textarea");
          textArea.classList.add("clipboard-temp");
          textArea.value = text;

          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();

          try {
            if (document.execCommand("copy")) {
              console.log("Bom copied to clipboard.");
            }
          } catch (err) {
            console.log("Can not copy to clipboard.");
          }

          document.body.removeChild(textArea);
        }
      }

      function isNumeric(str) {
        /* https://stackoverflow.com/a/175787 */
        return typeof str != "string"
          ? false
          : !isNaN(str) && !isNaN(parseFloat(str));
      }

      function removeGutterNode(node) {
        for (var i = 0; i < node.childNodes.length; i++) {
          if (
            node.childNodes[i].classList &&
            node.childNodes[i].classList.contains("gutter")
          ) {
            node.removeChild(node.childNodes[i]);
            break;
          }
        }
      }

      function cleanGutters() {
        removeGutterNode(document.getElementById("bot"));
        removeGutterNode(document.getElementById("canvasdiv"));
      }

      var units = {
        prefixes: {
          giga: ["G", "g", "giga", "Giga", "GIGA"],
          mega: ["M", "mega", "Mega", "MEGA"],
          kilo: ["K", "k", "kilo", "Kilo", "KILO"],
          milli: ["m", "milli", "Milli", "MILLI"],
          micro: ["U", "u", "micro", "Micro", "MICRO", "", ""], // different utf8 
          nano: ["N", "n", "nano", "Nano", "NANO"],
          pico: ["P", "p", "pico", "Pico", "PICO"],
        },
        unitsShort: ["R", "r", "", "F", "f", "H", "h"],
        unitsLong: [
          "OHM",
          "Ohm",
          "ohm",
          "ohms",
          "FARAD",
          "Farad",
          "farad",
          "HENRY",
          "Henry",
          "henry",
        ],
        getMultiplier: function (s) {
          if (this.prefixes.giga.includes(s)) return 1e9;
          if (this.prefixes.mega.includes(s)) return 1e6;
          if (this.prefixes.kilo.includes(s)) return 1e3;
          if (this.prefixes.milli.includes(s)) return 1e-3;
          if (this.prefixes.micro.includes(s)) return 1e-6;
          if (this.prefixes.nano.includes(s)) return 1e-9;
          if (this.prefixes.pico.includes(s)) return 1e-12;
          return 1;
        },
        valueRegex: null,
      };

      function initUtils() {
        var allPrefixes = units.prefixes.giga
          .concat(units.prefixes.mega)
          .concat(units.prefixes.kilo)
          .concat(units.prefixes.milli)
          .concat(units.prefixes.micro)
          .concat(units.prefixes.nano)
          .concat(units.prefixes.pico);
        var allUnits = units.unitsShort.concat(units.unitsLong);
        units.valueRegex = new RegExp(
          "^([0-9\.]+)" +
            "\\s*(" +
            allPrefixes.join("|") +
            ")?" +
            "(" +
            allUnits.join("|") +
            ")?" +
            "(\\b.*)?$",
          "",
        );
        units.valueAltRegex = new RegExp(
          "^([0-9]*)" +
            "(" +
            units.unitsShort.join("|") +
            ")?" +
            "([GgMmKkUuNnPp])?" +
            "([0-9]*)" +
            "(\\b.*)?$",
          "",
        );
        if (config.fields.includes("Value")) {
          var index = config.fields.indexOf("Value");
          pcbdata.bom["parsedValues"] = {};
          for (var id in pcbdata.bom.fields) {
            pcbdata.bom.parsedValues[id] = parseValue(
              pcbdata.bom.fields[id][index],
            );
          }
        }
      }

      function parseValue(val, ref) {
        var inferUnit = (unit, ref) => {
          if (unit) {
            unit = unit.toLowerCase();
            if (unit == "" || unit == "ohm" || unit == "ohms") {
              unit = "r";
            }
            unit = unit[0];
          } else {
            ref = /^([a-z]+)\d+$/i.exec(ref);
            if (ref) {
              ref = ref[1].toLowerCase();
              if (ref == "c") unit = "f";
              else if (ref == "l") unit = "h";
              else if (ref == "r" || ref == "rv") unit = "r";
              else unit = null;
            }
          }
          return unit;
        };
        val = val.replace(/,/g, "");
        var match = units.valueRegex.exec(val);
        var unit;
        if (match) {
          val = parseFloat(match[1]);
          if (match[2]) {
            val = val * units.getMultiplier(match[2]);
          }
          unit = inferUnit(match[3], ref);
          if (!unit) return null;
          else
            return {
              val: val,
              unit: unit,
              extra: match[4],
            };
        }
        match = units.valueAltRegex.exec(val);
        if (match && (match[1] || match[4])) {
          val = parseFloat(match[1] + "." + match[4]);
          if (match[3]) {
            val = val * units.getMultiplier(match[3]);
          }
          unit = inferUnit(match[2], ref);
          if (!unit) return null;
          else
            return {
              val: val,
              unit: unit,
              extra: match[5],
            };
        }
        return null;
      }

      function valueCompare(a, b, stra, strb) {
        if (a === null && b === null) {
          // Failed to parse both values, compare them as strings.
          if (stra != strb) return stra > strb ? 1 : -1;
          else return 0;
        } else if (a === null) {
          return 1;
        } else if (b === null) {
          return -1;
        } else {
          if (a.unit != b.unit) return a.unit > b.unit ? 1 : -1;
          else if (a.val != b.val) return a.val > b.val ? 1 : -1;
          else if (a.extra != b.extra) return a.extra > b.extra ? 1 : -1;
          else return 0;
        }
      }

      function validateSaveImgDimension(element) {
        var valid = false;
        var intValue = 0;
        if (/^[1-9]\d*$/.test(element.value)) {
          intValue = parseInt(element.value);
          if (intValue <= 16000) {
            valid = true;
          }
        }
        if (valid) {
          element.classList.remove("invalid");
        } else {
          element.classList.add("invalid");
        }
        return intValue;
      }

      function saveImage(layer) {
        var width = validateSaveImgDimension(
          document.getElementById("render-save-width"),
        );
        var height = validateSaveImgDimension(
          document.getElementById("render-save-height"),
        );
        var bgcolor = null;
        if (!document.getElementById("render-save-transparent").checked) {
          var style = getComputedStyle(topmostdiv);
          bgcolor = style.getPropertyValue("background-color");
        }
        if (!width || !height) return;

        // Prepare image
        var canvas = document.createElement("canvas");
        var layerdict = {
          transform: {
            x: 0,
            y: 0,
            s: 1,
            panx: 0,
            pany: 0,
            zoom: 1,
          },
          bg: canvas,
          fab: canvas,
          silk: canvas,
          highlight: canvas,
          layer: layer,
        };
        // Do the rendering
        recalcLayerScale(layerdict, width, height);
        prepareLayer(layerdict);
        clearCanvas(canvas, bgcolor);
        drawBackground(layerdict, false);
        drawHighlightsOnLayer(layerdict, false);

        // Save image
        var imgdata = canvas.toDataURL("image/png");

        var filename = pcbdata.metadata.title;
        if (pcbdata.metadata.revision) {
          filename += `.${pcbdata.metadata.revision}`;
        }
        filename += `.${layer}.png`;
        saveFile(filename, dataURLtoBlob(imgdata));
      }

      function saveSettings() {
        var data = {
          type: "InteractiveHtmlBom settings",
          version: 1,
          pcbmetadata: pcbdata.metadata,
          settings: settings,
        };
        var blob = new Blob([JSON.stringify(data, null, 4)], {
          type: "application/json",
        });
        saveFile(`${pcbdata.metadata.title}.settings.json`, blob);
      }

      function loadSettings() {
        var input = document.createElement("input");
        input.type = "file";
        input.accept = ".settings.json";
        input.onchange = function (e) {
          var file = e.target.files[0];
          var reader = new FileReader();
          reader.onload = (readerEvent) => {
            var content = readerEvent.target.result;
            var newSettings;
            try {
              newSettings = JSON.parse(content);
            } catch (e) {
              alert("Selected file is not InteractiveHtmlBom settings file.");
              return;
            }
            if (newSettings.type != "InteractiveHtmlBom settings") {
              alert("Selected file is not InteractiveHtmlBom settings file.");
              return;
            }
            var metadataMatches = newSettings.hasOwnProperty("pcbmetadata");
            if (metadataMatches) {
              for (var k in pcbdata.metadata) {
                if (
                  !newSettings.pcbmetadata.hasOwnProperty(k) ||
                  newSettings.pcbmetadata[k] != pcbdata.metadata[k]
                ) {
                  metadataMatches = false;
                }
              }
            }
            if (!metadataMatches) {
              var currentMetadata = JSON.stringify(pcbdata.metadata, null, 4);
              var fileMetadata = JSON.stringify(
                newSettings.pcbmetadata,
                null,
                4,
              );
              if (
                !confirm(
                  `Settins file metadata does not match current metadata.\n\n` +
                    `Page metadata:\n${currentMetadata}\n\n` +
                    `Settings file metadata:\n${fileMetadata}\n\n` +
                    `Press OK if you would like to import settings anyway.`,
                )
              ) {
                return;
              }
            }
            overwriteSettings(newSettings.settings);
          };
          reader.readAsText(file, "UTF-8");
        };
        input.click();
      }

      function overwriteSettings(newSettings) {
        initDone = false;
        Object.assign(settings, newSettings);
        writeStorage("bomlayout", settings.bomlayout);
        writeStorage("bommode", settings.bommode);
        writeStorage("canvaslayout", settings.canvaslayout);
        writeStorage("bomCheckboxes", settings.checkboxes.join(","));
        document.getElementById("bomCheckboxes").value =
          settings.checkboxes.join(",");
        for (var checkbox of settings.checkboxes) {
          writeStorage(
            "checkbox_" + checkbox,
            settings.checkboxStoredRefs[checkbox],
          );
        }
        writeStorage("markWhenChecked", settings.markWhenChecked);
        padsVisible(settings.renderPads);
        document.getElementById("padsCheckbox").checked = settings.renderPads;
        fabricationVisible(settings.renderFabrication);
        document.getElementById("fabricationCheckbox").checked =
          settings.renderFabrication;
        silkscreenVisible(settings.renderSilkscreen);
        document.getElementById("silkscreenCheckbox").checked =
          settings.renderSilkscreen;
        referencesVisible(settings.renderReferences);
        document.getElementById("referencesCheckbox").checked =
          settings.renderReferences;
        valuesVisible(settings.renderValues);
        document.getElementById("valuesCheckbox").checked =
          settings.renderValues;
        tracksVisible(settings.renderTracks);
        document.getElementById("tracksCheckbox").checked =
          settings.renderTracks;
        zonesVisible(settings.renderZones);
        document.getElementById("zonesCheckbox").checked = settings.renderZones;
        dnpOutline(settings.renderDnpOutline);
        document.getElementById("dnpOutlineCheckbox").checked =
          settings.renderDnpOutline;
        setRedrawOnDrag(settings.redrawOnDrag);
        document.getElementById("dragCheckbox").checked = settings.redrawOnDrag;
        setDarkMode(settings.darkMode);
        document.getElementById("darkmodeCheckbox").checked = settings.darkMode;
        setHighlightPin1(settings.highlightpin1);
        document.getElementById("highlightpin1Checkbox").checked =
          settings.highlightpin1;
        showFootprints(settings.show_footprints);
        writeStorage("boardRotation", settings.boardRotation);
        document.getElementById("boardRotation").value =
          settings.boardRotation / 5;
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
        initDone = true;
        prepCheckboxes();
        changeBomLayout(settings.bomlayout);
      }

      function saveFile(filename, blob) {
        var link = document.createElement("a");
        var objurl = URL.createObjectURL(blob);
        link.download = filename;
        link.href = objurl;
        link.click();
      }

      function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(","),
          mime = arr[0].match(/:(.*?);/)[1],
          bstr = atob(arr[1]),
          n = bstr.length,
          u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {
          type: mime,
        });
      }

      var settings = {
        canvaslayout: "default",
        bomlayout: "default",
        bommode: "grouped",
        checkboxes: [],
        checkboxStoredRefs: {},
        darkMode: false,
        highlightpin1: false,
        redrawOnDrag: true,
        boardRotation: 0,
        renderPads: true,
        renderReferences: true,
        renderValues: true,
        renderSilkscreen: true,
        renderFabrication: true,
        renderDnpOutline: false,
        renderTracks: true,
        renderZones: true,
        columnOrder: [],
        hiddenColumns: [],
      };

      function initDefaults() {
        settings.bomlayout = readStorage("bomlayout");
        if (settings.bomlayout === null) {
          settings.bomlayout = config.bom_view;
        }
        if (
          !["bom-only", "left-right", "top-bottom"].includes(settings.bomlayout)
        ) {
          settings.bomlayout = config.bom_view;
        }
        settings.bommode = readStorage("bommode");
        if (settings.bommode === null) {
          settings.bommode = "grouped";
        }
        if (!["grouped", "ungrouped", "netlist"].includes(settings.bommode)) {
          settings.bommode = "grouped";
        }
        settings.canvaslayout = readStorage("canvaslayout");
        if (settings.canvaslayout === null) {
          settings.canvaslayout = config.layer_view;
        }
        var bomCheckboxes = readStorage("bomCheckboxes");
        if (bomCheckboxes === null) {
          bomCheckboxes = config.checkboxes;
        }
        settings.checkboxes = bomCheckboxes.split(",").filter((e) => e);
        document.getElementById("bomCheckboxes").value = bomCheckboxes;

        settings.markWhenChecked = readStorage("markWhenChecked") || "";
        populateMarkWhenCheckedOptions();

        function initBooleanSetting(storageString, def, elementId, func) {
          var b = readStorage(storageString);
          if (b === null) {
            b = def;
          } else {
            b = b == "true";
          }
          document.getElementById(elementId).checked = b;
          func(b);
        }

        initBooleanSetting(
          "padsVisible",
          config.show_pads,
          "padsCheckbox",
          padsVisible,
        );
        initBooleanSetting(
          "fabricationVisible",
          config.show_fabrication,
          "fabricationCheckbox",
          fabricationVisible,
        );
        initBooleanSetting(
          "silkscreenVisible",
          config.show_silkscreen,
          "silkscreenCheckbox",
          silkscreenVisible,
        );
        initBooleanSetting(
          "referencesVisible",
          true,
          "referencesCheckbox",
          referencesVisible,
        );
        initBooleanSetting(
          "valuesVisible",
          true,
          "valuesCheckbox",
          valuesVisible,
        );
        if ("tracks" in pcbdata) {
          initBooleanSetting(
            "tracksVisible",
            true,
            "tracksCheckbox",
            tracksVisible,
          );
          initBooleanSetting(
            "zonesVisible",
            true,
            "zonesCheckbox",
            zonesVisible,
          );
        } else {
          document.getElementById("tracksAndZonesCheckboxes").style.display =
            "none";
          tracksVisible(false);
          zonesVisible(false);
        }
        initBooleanSetting(
          "dnpOutline",
          false,
          "dnpOutlineCheckbox",
          dnpOutline,
        );
        initBooleanSetting(
          "redrawOnDrag",
          config.redraw_on_drag,
          "dragCheckbox",
          setRedrawOnDrag,
        );
        initBooleanSetting(
          "darkmode",
          config.dark_mode,
          "darkmodeCheckbox",
          setDarkMode,
        );
        initBooleanSetting(
          "highlightpin1",
          config.highlight_pin1,
          "highlightpin1Checkbox",
          setHighlightPin1,
        );

        var fields = ["checkboxes", "References"]
          .concat(config.fields)
          .concat(["Quantity"]);
        var hcols = JSON.parse(readStorage("hiddenColumns"));
        if (hcols === null) {
          hcols = [];
        }
        settings.hiddenColumns = hcols.filter((e) => fields.includes(e));

        var cord = JSON.parse(readStorage("columnOrder"));
        if (cord === null) {
          cord = fields;
        } else {
          cord = cord.filter((e) => fields.includes(e));
          if (cord.length != fields.length) cord = fields;
        }
        settings.columnOrder = cord;

        settings.boardRotation = readStorage("boardRotation");
        if (settings.boardRotation === null) {
          settings.boardRotation = config.board_rotation * 5;
        } else {
          settings.boardRotation = parseInt(settings.boardRotation);
        }
        document.getElementById("boardRotation").value =
          settings.boardRotation / 5;
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
      }

      // Helper classes for user js callbacks.

      const IBOM_EVENT_TYPES = {
        ALL: "all",
        HIGHLIGHT_EVENT: "highlightEvent",
        CHECKBOX_CHANGE_EVENT: "checkboxChangeEvent",
        BOM_BODY_CHANGE_EVENT: "bomBodyChangeEvent",
      };

      const EventHandler = {
        callbacks: {},
        init: function () {
          for (eventType of Object.values(IBOM_EVENT_TYPES))
            this.callbacks[eventType] = [];
        },
        registerCallback: function (eventType, callback) {
          this.callbacks[eventType].push(callback);
        },
        emitEvent: function (eventType, eventArgs) {
          event = {
            eventType: eventType,
            args: eventArgs,
          };
          var callback;
          for (callback of this.callbacks[eventType]) callback(event);
          for (callback of this.callbacks[IBOM_EVENT_TYPES.ALL])
            callback(event);
        },
      };
      EventHandler.init();

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* PCB rendering code */

      var emptyContext2d = document.createElement("canvas").getContext("2d");

      function deg2rad(deg) {
        return (deg * Math.PI) / 180;
      }

      function calcFontPoint(linepoint, text, offsetx, offsety, tilt) {
        var point = [
          linepoint[0] * text.width + offsetx,
          linepoint[1] * text.height + offsety,
        ];
        // This approximates pcbnew behavior with how text tilts depending on horizontal justification
        point[0] -=
          (linepoint[1] + 0.5 * (1 + text.justify[0])) * text.height * tilt;
        return point;
      }

      function drawText(ctx, text, color) {
        if ("ref" in text && !settings.renderReferences) return;
        if ("val" in text && !settings.renderValues) return;
        ctx.save();
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = text.thickness;
        if ("svgpath" in text) {
          ctx.stroke(new Path2D(text.svgpath));
          ctx.restore();
          return;
        }
        if ("polygons" in text) {
          ctx.fill(getPolygonsPath(text));
          ctx.restore();
          return;
        }
        ctx.translate(...text.pos);
        ctx.translate(text.thickness * 0.5, 0);
        var angle = -text.angle;
        if (text.attr.includes("mirrored")) {
          ctx.scale(-1, 1);
          angle = -angle;
        }
        var tilt = 0;
        if (text.attr.includes("italic")) {
          tilt = 0.125;
        }
        var interline = text.height * 1.5 + text.thickness;
        var txt = text.text.split("\n");
        // KiCad ignores last empty line.
        if (txt[txt.length - 1] == "") txt.pop();
        ctx.rotate(deg2rad(angle));
        var offsety = ((1 - text.justify[1]) / 2) * text.height; // One line offset
        offsety -= (((txt.length - 1) * (text.justify[1] + 1)) / 2) * interline; // Multiline offset
        for (var i in txt) {
          var lineWidth = text.thickness + (interline / 2) * tilt;
          for (var j = 0; j < txt[i].length; j++) {
            if (txt[i][j] == "\t") {
              var fourSpaces = 4 * pcbdata.font_data[" "].w * text.width;
              lineWidth += fourSpaces - (lineWidth % fourSpaces);
            } else {
              if (txt[i][j] == "~") {
                j++;
                if (j == txt[i].length) break;
              }
              lineWidth += pcbdata.font_data[txt[i][j]].w * text.width;
            }
          }
          var offsetx = (-lineWidth * (text.justify[0] + 1)) / 2;
          var inOverbar = false;
          for (var j = 0; j < txt[i].length; j++) {
            if (txt[i][j] == "\t") {
              var fourSpaces = 4 * pcbdata.font_data[" "].w * text.width;
              offsetx += fourSpaces - (offsetx % fourSpaces);
              continue;
            } else if (txt[i][j] == "~") {
              j++;
              if (j == txt[i].length) break;
              if (txt[i][j] != "~") {
                inOverbar = !inOverbar;
              }
            }
            var glyph = pcbdata.font_data[txt[i][j]];
            if (inOverbar) {
              var overbarStart = [offsetx, -text.height * 1.4 + offsety];
              var overbarEnd = [
                offsetx + text.width * glyph.w,
                overbarStart[1],
              ];

              if (!lastHadOverbar) {
                overbarStart[0] += text.height * 1.4 * tilt;
                lastHadOverbar = true;
              }
              ctx.beginPath();
              ctx.moveTo(...overbarStart);
              ctx.lineTo(...overbarEnd);
              ctx.stroke();
            } else {
              lastHadOverbar = false;
            }
            for (var line of glyph.l) {
              ctx.beginPath();
              ctx.moveTo(
                ...calcFontPoint(line[0], text, offsetx, offsety, tilt),
              );
              for (var k = 1; k < line.length; k++) {
                ctx.lineTo(
                  ...calcFontPoint(line[k], text, offsetx, offsety, tilt),
                );
              }
              ctx.stroke();
            }
            offsetx += glyph.w * text.width;
          }
          offsety += interline;
        }
        ctx.restore();
      }

      function drawedge(ctx, scalefactor, edge, color) {
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = Math.max(1 / scalefactor, edge.width);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        if ("svgpath" in edge) {
          ctx.stroke(new Path2D(edge.svgpath));
        } else {
          ctx.beginPath();
          if (edge.type == "segment") {
            ctx.moveTo(...edge.start);
            ctx.lineTo(...edge.end);
          }
          if (edge.type == "rect") {
            ctx.moveTo(...edge.start);
            ctx.lineTo(edge.start[0], edge.end[1]);
            ctx.lineTo(...edge.end);
            ctx.lineTo(edge.end[0], edge.start[1]);
            ctx.lineTo(...edge.start);
          }
          if (edge.type == "arc") {
            ctx.arc(
              ...edge.start,
              edge.radius,
              deg2rad(edge.startangle),
              deg2rad(edge.endangle),
            );
          }
          if (edge.type == "circle") {
            ctx.arc(...edge.start, edge.radius, 0, 2 * Math.PI);
            ctx.closePath();
          }
          if (edge.type == "curve") {
            ctx.moveTo(...edge.start);
            ctx.bezierCurveTo(...edge.cpa, ...edge.cpb, ...edge.end);
          }
          if ("filled" in edge && edge.filled) ctx.fill();
          else ctx.stroke();
        }
      }

      function getChamferedRectPath(size, radius, chamfpos, chamfratio) {
        // chamfpos is a bitmask, left = 1, right = 2, bottom left = 4, bottom right = 8
        var path = new Path2D();
        var width = size[0];
        var height = size[1];
        var x = width * -0.5;
        var y = height * -0.5;
        var chamfOffset = Math.min(width, height) * chamfratio;
        path.moveTo(x, 0);
        if (chamfpos & 4) {
          path.lineTo(x, y + height - chamfOffset);
          path.lineTo(x + chamfOffset, y + height);
          path.lineTo(0, y + height);
        } else {
          path.arcTo(x, y + height, x + width, y + height, radius);
        }
        if (chamfpos & 8) {
          path.lineTo(x + width - chamfOffset, y + height);
          path.lineTo(x + width, y + height - chamfOffset);
          path.lineTo(x + width, 0);
        } else {
          path.arcTo(x + width, y + height, x + width, y, radius);
        }
        if (chamfpos & 2) {
          path.lineTo(x + width, y + chamfOffset);
          path.lineTo(x + width - chamfOffset, y);
          path.lineTo(0, y);
        } else {
          path.arcTo(x + width, y, x, y, radius);
        }
        if (chamfpos & 1) {
          path.lineTo(x + chamfOffset, y);
          path.lineTo(x, y + chamfOffset);
          path.lineTo(x, 0);
        } else {
          path.arcTo(x, y, x, y + height, radius);
        }
        path.closePath();
        return path;
      }

      function getOblongPath(size) {
        return getChamferedRectPath(size, Math.min(size[0], size[1]) / 2, 0, 0);
      }

      function getPolygonsPath(shape) {
        if (shape.path2d) {
          return shape.path2d;
        }
        if ("svgpath" in shape) {
          shape.path2d = new Path2D(shape.svgpath);
        } else {
          var path = new Path2D();
          for (var polygon of shape.polygons) {
            path.moveTo(...polygon[0]);
            for (var i = 1; i < polygon.length; i++) {
              path.lineTo(...polygon[i]);
            }
            path.closePath();
          }
          shape.path2d = path;
        }
        return shape.path2d;
      }

      function drawPolygonShape(ctx, scalefactor, shape, color) {
        ctx.save();
        if (!("svgpath" in shape)) {
          ctx.translate(...shape.pos);
          ctx.rotate(deg2rad(-shape.angle));
        }
        if ("filled" in shape && !shape.filled) {
          ctx.strokeStyle = color;
          ctx.lineWidth = Math.max(1 / scalefactor, shape.width);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.stroke(getPolygonsPath(shape));
        } else {
          ctx.fillStyle = color;
          ctx.fill(getPolygonsPath(shape));
        }
        ctx.restore();
      }

      function drawDrawing(ctx, scalefactor, drawing, color) {
        if (
          ["segment", "arc", "circle", "curve", "rect"].includes(drawing.type)
        ) {
          drawedge(ctx, scalefactor, drawing, color);
        } else if (drawing.type == "polygon") {
          drawPolygonShape(ctx, scalefactor, drawing, color);
        } else {
          drawText(ctx, drawing, color);
        }
      }

      function getCirclePath(radius) {
        var path = new Path2D();
        path.arc(0, 0, radius, 0, 2 * Math.PI);
        path.closePath();
        return path;
      }

      function getCachedPadPath(pad) {
        if (!pad.path2d) {
          // if path2d is not set, build one and cache it on pad object
          if (pad.shape == "rect") {
            pad.path2d = new Path2D();
            pad.path2d.rect(...pad.size.map((c) => -c * 0.5), ...pad.size);
          } else if (pad.shape == "oval") {
            pad.path2d = getOblongPath(pad.size);
          } else if (pad.shape == "circle") {
            pad.path2d = getCirclePath(pad.size[0] / 2);
          } else if (pad.shape == "roundrect") {
            pad.path2d = getChamferedRectPath(pad.size, pad.radius, 0, 0);
          } else if (pad.shape == "chamfrect") {
            pad.path2d = getChamferedRectPath(
              pad.size,
              pad.radius,
              pad.chamfpos,
              pad.chamfratio,
            );
          } else if (pad.shape == "custom") {
            pad.path2d = getPolygonsPath(pad);
          }
        }
        return pad.path2d;
      }

      function drawPad(ctx, pad, color, outline) {
        ctx.save();
        ctx.translate(...pad.pos);
        ctx.rotate(-deg2rad(pad.angle));
        if (pad.offset) {
          ctx.translate(...pad.offset);
        }
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        var path = getCachedPadPath(pad);
        if (outline) {
          ctx.stroke(path);
        } else {
          ctx.fill(path);
        }
        ctx.restore();
      }

      function drawPadHole(ctx, pad, padHoleColor) {
        if (pad.type != "th") return;
        ctx.save();
        ctx.translate(...pad.pos);
        ctx.rotate(-deg2rad(pad.angle));
        ctx.fillStyle = padHoleColor;
        if (pad.drillshape == "oblong") {
          ctx.fill(getOblongPath(pad.drillsize));
        } else {
          ctx.fill(getCirclePath(pad.drillsize[0] / 2));
        }
        ctx.restore();
      }

      function drawFootprint(
        ctx,
        layer,
        scalefactor,
        footprint,
        colors,
        highlight,
        outline,
      ) {
        if (highlight) {
          // draw bounding box
          if (footprint.layer == layer) {
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.translate(...footprint.bbox.pos);
            ctx.rotate(deg2rad(-footprint.bbox.angle));
            ctx.translate(...footprint.bbox.relpos);
            ctx.fillStyle = colors.pad;
            ctx.fillRect(0, 0, ...footprint.bbox.size);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = colors.pad;
            ctx.strokeRect(0, 0, ...footprint.bbox.size);
            ctx.restore();
          }
        }
        // draw drawings
        for (var drawing of footprint.drawings) {
          if (drawing.layer == layer) {
            drawDrawing(ctx, scalefactor, drawing.drawing, colors.pad);
          }
        }
        // draw pads
        if (settings.renderPads) {
          for (var pad of footprint.pads) {
            if (pad.layers.includes(layer)) {
              drawPad(ctx, pad, colors.pad, outline);
              if (pad.pin1 && settings.highlightpin1) {
                drawPad(ctx, pad, colors.outline, true);
              }
            }
          }
          for (var pad of footprint.pads) {
            drawPadHole(ctx, pad, colors.padHole);
          }
        }
      }

      function drawEdgeCuts(canvas, scalefactor) {
        var ctx = canvas.getContext("2d");
        var edgecolor =
          getComputedStyle(topmostdiv).getPropertyValue("--pcb-edge-color");
        for (var edge of pcbdata.edges) {
          drawDrawing(ctx, scalefactor, edge, edgecolor);
        }
      }

      function drawFootprints(canvas, layer, scalefactor, highlight) {
        var ctx = canvas.getContext("2d");
        ctx.lineWidth = 3 / scalefactor;
        var style = getComputedStyle(topmostdiv);

        var colors = {
          pad: style.getPropertyValue("--pad-color"),
          padHole: style.getPropertyValue("--pad-hole-color"),
          outline: style.getPropertyValue("--pin1-outline-color"),
        };

        for (var i = 0; i < pcbdata.footprints.length; i++) {
          var mod = pcbdata.footprints[i];
          var outline =
            settings.renderDnpOutline && pcbdata.bom.skipped.includes(i);
          var h = highlightedFootprints.includes(i);
          var d = markedFootprints.has(i);
          if (highlight) {
            if (h && d) {
              colors.pad = style.getPropertyValue("--pad-color-highlight-both");
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight-both",
              );
            } else if (h) {
              colors.pad = style.getPropertyValue("--pad-color-highlight");
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight",
              );
            } else if (d) {
              colors.pad = style.getPropertyValue(
                "--pad-color-highlight-marked",
              );
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight-marked",
              );
            }
          }
          if (h || d || !highlight) {
            drawFootprint(
              ctx,
              layer,
              scalefactor,
              mod,
              colors,
              highlight,
              outline,
            );
          }
        }
      }

      function drawBgLayer(
        layername,
        canvas,
        layer,
        scalefactor,
        edgeColor,
        polygonColor,
        textColor,
      ) {
        var ctx = canvas.getContext("2d");
        for (var d of pcbdata.drawings[layername][layer]) {
          if (["segment", "arc", "circle", "curve", "rect"].includes(d.type)) {
            drawedge(ctx, scalefactor, d, edgeColor);
          } else if (d.type == "polygon") {
            drawPolygonShape(ctx, scalefactor, d, polygonColor);
          } else {
            drawText(ctx, d, textColor);
          }
        }
      }

      function drawTracks(canvas, layer, color, highlight) {
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = color;
        ctx.lineCap = "round";
        for (var track of pcbdata.tracks[layer]) {
          if (highlight && highlightedNet != track.net) continue;
          ctx.lineWidth = track.width;
          ctx.beginPath();
          if ("radius" in track) {
            ctx.arc(
              ...track.center,
              track.radius,
              deg2rad(track.startangle),
              deg2rad(track.endangle),
            );
          } else {
            ctx.moveTo(...track.start);
            ctx.lineTo(...track.end);
          }
          ctx.stroke();
        }
      }

      function drawZones(canvas, layer, color, highlight) {
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineJoin = "round";
        for (var zone of pcbdata.zones[layer]) {
          if (!zone.path2d) {
            zone.path2d = getPolygonsPath(zone);
          }
          if (highlight && highlightedNet != zone.net) continue;
          ctx.fill(zone.path2d);
          if (zone.width > 0) {
            ctx.lineWidth = zone.width;
            ctx.stroke(zone.path2d);
          }
        }
      }

      function clearCanvas(canvas, color = null) {
        var ctx = canvas.getContext("2d");
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (color) {
          ctx.fillStyle = color;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          if (!window.matchMedia("print").matches)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
      }

      function drawNets(canvas, layer, highlight) {
        var style = getComputedStyle(topmostdiv);
        if (settings.renderTracks) {
          var trackColor = style.getPropertyValue(
            highlight ? "--track-color-highlight" : "--track-color",
          );
          drawTracks(canvas, layer, trackColor, highlight);
        }
        if (settings.renderZones) {
          var zoneColor = style.getPropertyValue(
            highlight ? "--zone-color-highlight" : "--zone-color",
          );
          drawZones(canvas, layer, zoneColor, highlight);
        }
        if (highlight && settings.renderPads) {
          var padColor = style.getPropertyValue("--pad-color-highlight");
          var padHoleColor = style.getPropertyValue("--pad-hole-color");
          var ctx = canvas.getContext("2d");
          for (var footprint of pcbdata.footprints) {
            // draw pads
            var padDrawn = false;
            for (var pad of footprint.pads) {
              if (highlightedNet != pad.net) continue;
              if (pad.layers.includes(layer)) {
                drawPad(ctx, pad, padColor, false);
                padDrawn = true;
              }
            }
            if (padDrawn) {
              // redraw all pad holes because some pads may overlap
              for (var pad of footprint.pads) {
                drawPadHole(ctx, pad, padHoleColor);
              }
            }
          }
        }
      }

      function drawHighlightsOnLayer(canvasdict, clear = true) {
        if (clear) {
          clearCanvas(canvasdict.highlight);
        }
        if (markedFootprints.size > 0 || highlightedFootprints.length > 0) {
          drawFootprints(
            canvasdict.highlight,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            true,
          );
        }
        if (highlightedNet !== null) {
          drawNets(canvasdict.highlight, canvasdict.layer, true);
        }
      }

      function drawHighlights() {
        drawHighlightsOnLayer(allcanvas.front);
        drawHighlightsOnLayer(allcanvas.back);
      }

      function drawBackground(canvasdict, clear = true) {
        if (clear) {
          clearCanvas(canvasdict.bg);
          clearCanvas(canvasdict.fab);
          clearCanvas(canvasdict.silk);
        }

        drawNets(canvasdict.bg, canvasdict.layer, false);
        drawFootprints(
          canvasdict.bg,
          canvasdict.layer,
          canvasdict.transform.s * canvasdict.transform.zoom,
          false,
        );

        drawEdgeCuts(
          canvasdict.bg,
          canvasdict.transform.s * canvasdict.transform.zoom,
        );

        var style = getComputedStyle(topmostdiv);
        var edgeColor = style.getPropertyValue("--silkscreen-edge-color");
        var polygonColor = style.getPropertyValue("--silkscreen-polygon-color");
        var textColor = style.getPropertyValue("--silkscreen-text-color");
        if (settings.renderSilkscreen) {
          drawBgLayer(
            "silkscreen",
            canvasdict.silk,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            edgeColor,
            polygonColor,
            textColor,
          );
        }
        edgeColor = style.getPropertyValue("--fabrication-edge-color");
        polygonColor = style.getPropertyValue("--fabrication-polygon-color");
        textColor = style.getPropertyValue("--fabrication-text-color");
        if (settings.renderFabrication) {
          drawBgLayer(
            "fabrication",
            canvasdict.fab,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            edgeColor,
            polygonColor,
            textColor,
          );
        }
      }

      function prepareCanvas(canvas, flip, transform) {
        var ctx = canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(transform.zoom, transform.zoom);
        ctx.translate(transform.panx, transform.pany);
        if (flip) {
          ctx.scale(-1, 1);
        }
        ctx.translate(transform.x, transform.y);
        ctx.rotate(deg2rad(settings.boardRotation));
        ctx.scale(transform.s, transform.s);
      }

      function prepareLayer(canvasdict) {
        var flip = canvasdict.layer == "B";
        for (var c of ["bg", "fab", "silk", "highlight"]) {
          prepareCanvas(canvasdict[c], flip, canvasdict.transform);
        }
      }

      function rotateVector(v, angle) {
        angle = deg2rad(angle);
        return [
          v[0] * Math.cos(angle) - v[1] * Math.sin(angle),
          v[0] * Math.sin(angle) + v[1] * Math.cos(angle),
        ];
      }

      function applyRotation(bbox) {
        var corners = [
          [bbox.minx, bbox.miny],
          [bbox.minx, bbox.maxy],
          [bbox.maxx, bbox.miny],
          [bbox.maxx, bbox.maxy],
        ];
        corners = corners.map((v) => rotateVector(v, settings.boardRotation));
        return {
          minx: corners.reduce((a, v) => Math.min(a, v[0]), Infinity),
          miny: corners.reduce((a, v) => Math.min(a, v[1]), Infinity),
          maxx: corners.reduce((a, v) => Math.max(a, v[0]), -Infinity),
          maxy: corners.reduce((a, v) => Math.max(a, v[1]), -Infinity),
        };
      }

      function recalcLayerScale(layerdict, width, height) {
        var bbox = applyRotation(pcbdata.edges_bbox);
        var scalefactor =
          0.98 *
          Math.min(
            width / (bbox.maxx - bbox.minx),
            height / (bbox.maxy - bbox.miny),
          );
        if (scalefactor < 0.1) {
          scalefactor = 1;
        }
        layerdict.transform.s = scalefactor;
        var flip = layerdict.layer == "B";
        if (flip) {
          layerdict.transform.x =
            -((bbox.maxx + bbox.minx) * scalefactor + width) * 0.5;
        } else {
          layerdict.transform.x =
            -((bbox.maxx + bbox.minx) * scalefactor - width) * 0.5;
        }
        layerdict.transform.y =
          -((bbox.maxy + bbox.miny) * scalefactor - height) * 0.5;
        for (var c of ["bg", "fab", "silk", "highlight"]) {
          canvas = layerdict[c];
          canvas.width = width;
          canvas.height = height;
          canvas.style.width = width / devicePixelRatio + "px";
          canvas.style.height = height / devicePixelRatio + "px";
        }
      }

      function redrawCanvas(layerdict) {
        prepareLayer(layerdict);
        drawBackground(layerdict);
        drawHighlightsOnLayer(layerdict);
      }

      function resizeCanvas(layerdict) {
        var canvasdivid = {
          F: "frontcanvas",
          B: "backcanvas",
        }[layerdict.layer];
        var width =
          document.getElementById(canvasdivid).clientWidth * devicePixelRatio;
        var height =
          document.getElementById(canvasdivid).clientHeight * devicePixelRatio;
        recalcLayerScale(layerdict, width, height);
        redrawCanvas(layerdict);
      }

      function resizeAll() {
        resizeCanvas(allcanvas.front);
        resizeCanvas(allcanvas.back);
      }

      function pointWithinDistanceToSegment(x, y, x1, y1, x2, y2, d) {
        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var dx, dy;
        if (len_sq == 0) {
          // start and end of the segment coincide
          dx = x - x1;
          dy = y - y1;
        } else {
          var param = dot / len_sq;
          var xx, yy;
          if (param < 0) {
            xx = x1;
            yy = y1;
          } else if (param > 1) {
            xx = x2;
            yy = y2;
          } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
          }
          dx = x - xx;
          dy = y - yy;
        }
        return dx * dx + dy * dy <= d * d;
      }

      function modulo(n, mod) {
        return ((n % mod) + mod) % mod;
      }

      function pointWithinDistanceToArc(
        x,
        y,
        xc,
        yc,
        radius,
        startangle,
        endangle,
        d,
      ) {
        var dx = x - xc;
        var dy = y - yc;
        var r_sq = dx * dx + dy * dy;
        var rmin = Math.max(0, radius - d);
        var rmax = radius + d;

        if (r_sq < rmin * rmin || r_sq > rmax * rmax) return false;

        var angle1 = modulo(deg2rad(startangle), 2 * Math.PI);
        var dx1 = xc + radius * Math.cos(angle1) - x;
        var dy1 = yc + radius * Math.sin(angle1) - y;
        if (dx1 * dx1 + dy1 * dy1 <= d * d) return true;

        var angle2 = modulo(deg2rad(endangle), 2 * Math.PI);
        var dx2 = xc + radius * Math.cos(angle2) - x;
        var dy2 = yc + radius * Math.sin(angle2) - y;
        if (dx2 * dx2 + dy2 * dy2 <= d * d) return true;

        var angle = modulo(Math.atan2(dy, dx), 2 * Math.PI);
        if (angle1 > angle2) return angle >= angle2 || angle <= angle1;
        else return angle >= angle1 && angle <= angle2;
      }

      function pointWithinPad(x, y, pad) {
        var v = [x - pad.pos[0], y - pad.pos[1]];
        v = rotateVector(v, pad.angle);
        if (pad.offset) {
          v[0] -= pad.offset[0];
          v[1] -= pad.offset[1];
        }
        return emptyContext2d.isPointInPath(getCachedPadPath(pad), ...v);
      }

      function netHitScan(layer, x, y) {
        // Check track segments
        if (settings.renderTracks && pcbdata.tracks) {
          for (var track of pcbdata.tracks[layer]) {
            if ("radius" in track) {
              if (
                pointWithinDistanceToArc(
                  x,
                  y,
                  ...track.center,
                  track.radius,
                  track.startangle,
                  track.endangle,
                  track.width / 2,
                )
              ) {
                return track.net;
              }
            } else {
              if (
                pointWithinDistanceToSegment(
                  x,
                  y,
                  ...track.start,
                  ...track.end,
                  track.width / 2,
                )
              ) {
                return track.net;
              }
            }
          }
        }
        // Check pads
        if (settings.renderPads) {
          for (var footprint of pcbdata.footprints) {
            for (var pad of footprint.pads) {
              if (pad.layers.includes(layer) && pointWithinPad(x, y, pad)) {
                return pad.net;
              }
            }
          }
        }
        return null;
      }

      function pointWithinFootprintBbox(x, y, bbox) {
        var v = [x - bbox.pos[0], y - bbox.pos[1]];
        v = rotateVector(v, bbox.angle);
        return (
          bbox.relpos[0] <= v[0] &&
          v[0] <= bbox.relpos[0] + bbox.size[0] &&
          bbox.relpos[1] <= v[1] &&
          v[1] <= bbox.relpos[1] + bbox.size[1]
        );
      }

      function bboxHitScan(layer, x, y) {
        var result = [];
        for (var i = 0; i < pcbdata.footprints.length; i++) {
          var footprint = pcbdata.footprints[i];
          if (footprint.layer == layer) {
            if (pointWithinFootprintBbox(x, y, footprint.bbox)) {
              result.push(i);
            }
          }
        }
        return result;
      }

      function handlePointerDown(e, layerdict) {
        if (e.button != 0 && e.button != 1) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();

        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        layerdict.pointerStates[e.pointerId] = {
          distanceTravelled: 0,
          lastX: e.offsetX,
          lastY: e.offsetY,
          downTime: Date.now(),
        };
      }

      function handleMouseClick(e, layerdict) {
        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        var x = e.offsetX;
        var y = e.offsetY;
        var t = layerdict.transform;
        if (layerdict.layer == "B") {
          x = ((devicePixelRatio * x) / t.zoom - t.panx + t.x) / -t.s;
        } else {
          x = ((devicePixelRatio * x) / t.zoom - t.panx - t.x) / t.s;
        }
        y = ((devicePixelRatio * y) / t.zoom - t.y - t.pany) / t.s;
        var v = rotateVector([x, y], -settings.boardRotation);
        if ("nets" in pcbdata) {
          var net = netHitScan(layerdict.layer, ...v);
          if (net !== highlightedNet) {
            netClicked(net);
          }
        }
        if (highlightedNet === null) {
          var footprints = bboxHitScan(layerdict.layer, ...v);
          if (footprints.length > 0) {
            footprintsClicked(footprints);
          }
        }
      }

      function handlePointerLeave(e, layerdict) {
        e.preventDefault();
        e.stopPropagation();

        if (!settings.redrawOnDrag) {
          redrawCanvas(layerdict);
        }

        delete layerdict.pointerStates[e.pointerId];
      }

      function resetTransform(layerdict) {
        layerdict.transform.panx = 0;
        layerdict.transform.pany = 0;
        layerdict.transform.zoom = 1;
        redrawCanvas(layerdict);
      }

      function handlePointerUp(e, layerdict) {
        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        e.preventDefault();
        e.stopPropagation();

        if (e.button == 2) {
          // Reset pan and zoom on right click.
          resetTransform(layerdict);
          layerdict.anotherPointerTapped = false;
          return;
        }

        // We haven't necessarily had a pointermove event since the interaction started, so make sure we update this now
        var ptr = layerdict.pointerStates[e.pointerId];
        ptr.distanceTravelled +=
          Math.abs(e.offsetX - ptr.lastX) + Math.abs(e.offsetY - ptr.lastY);

        if (
          e.button == 0 &&
          ptr.distanceTravelled < 10 &&
          Date.now() - ptr.downTime <= 500
        ) {
          if (Object.keys(layerdict.pointerStates).length == 1) {
            if (layerdict.anotherPointerTapped) {
              // This is the second pointer coming off of a two-finger tap
              resetTransform(layerdict);
            } else {
              // This is just a regular tap
              handleMouseClick(e, layerdict);
            }
            layerdict.anotherPointerTapped = false;
          } else {
            // This is the first finger coming off of what could become a two-finger tap
            layerdict.anotherPointerTapped = true;
          }
        } else {
          if (!settings.redrawOnDrag) {
            redrawCanvas(layerdict);
          }
          layerdict.anotherPointerTapped = false;
        }

        delete layerdict.pointerStates[e.pointerId];
      }

      function handlePointerMove(e, layerdict) {
        if (!layerdict.pointerStates.hasOwnProperty(e.pointerId)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();

        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        var thisPtr = layerdict.pointerStates[e.pointerId];

        var dx = e.offsetX - thisPtr.lastX;
        var dy = e.offsetY - thisPtr.lastY;

        // If this number is low on pointer up, we count the action as a click
        thisPtr.distanceTravelled += Math.abs(dx) + Math.abs(dy);

        if (Object.keys(layerdict.pointerStates).length == 1) {
          // This is a simple drag
          layerdict.transform.panx +=
            (devicePixelRatio * dx) / layerdict.transform.zoom;
          layerdict.transform.pany +=
            (devicePixelRatio * dy) / layerdict.transform.zoom;
        } else if (Object.keys(layerdict.pointerStates).length == 2) {
          var otherPtr = Object.values(layerdict.pointerStates).filter(
            (ptr) => ptr != thisPtr,
          )[0];

          var oldDist = Math.sqrt(
            Math.pow(thisPtr.lastX - otherPtr.lastX, 2) +
              Math.pow(thisPtr.lastY - otherPtr.lastY, 2),
          );
          var newDist = Math.sqrt(
            Math.pow(e.offsetX - otherPtr.lastX, 2) +
              Math.pow(e.offsetY - otherPtr.lastY, 2),
          );

          var scaleFactor = newDist / oldDist;

          if (scaleFactor != NaN) {
            layerdict.transform.zoom *= scaleFactor;

            var zoomd = (1 - scaleFactor) / layerdict.transform.zoom;
            layerdict.transform.panx +=
              devicePixelRatio * otherPtr.lastX * zoomd;
            layerdict.transform.pany +=
              devicePixelRatio * otherPtr.lastY * zoomd;
          }
        }

        thisPtr.lastX = e.offsetX;
        thisPtr.lastY = e.offsetY;

        if (settings.redrawOnDrag) {
          redrawCanvas(layerdict);
        }
      }

      function handleMouseWheel(e, layerdict) {
        e.preventDefault();
        e.stopPropagation();
        var t = layerdict.transform;
        var wheeldelta = e.deltaY;
        if (e.deltaMode == 1) {
          // FF only, scroll by lines
          wheeldelta *= 30;
        } else if (e.deltaMode == 2) {
          wheeldelta *= 300;
        }
        var m = Math.pow(1.1, -wheeldelta / 40);
        // Limit amount of zoom per tick.
        if (m > 2) {
          m = 2;
        } else if (m < 0.5) {
          m = 0.5;
        }
        t.zoom *= m;
        var zoomd = (1 - m) / t.zoom;
        t.panx += devicePixelRatio * e.offsetX * zoomd;
        t.pany += devicePixelRatio * e.offsetY * zoomd;
        redrawCanvas(layerdict);
      }

      function addMouseHandlers(div, layerdict) {
        div.addEventListener("pointerdown", function (e) {
          handlePointerDown(e, layerdict);
        });
        div.addEventListener("pointermove", function (e) {
          handlePointerMove(e, layerdict);
        });
        div.addEventListener("pointerup", function (e) {
          handlePointerUp(e, layerdict);
        });
        var pointerleave = function (e) {
          handlePointerLeave(e, layerdict);
        };
        div.addEventListener("pointercancel", pointerleave);
        div.addEventListener("pointerleave", pointerleave);
        div.addEventListener("pointerout", pointerleave);

        div.onwheel = function (e) {
          handleMouseWheel(e, layerdict);
        };
        for (var element of [
          div,
          layerdict.bg,
          layerdict.fab,
          layerdict.silk,
          layerdict.highlight,
        ]) {
          element.addEventListener(
            "contextmenu",
            function (e) {
              e.preventDefault();
            },
            false,
          );
        }
      }

      function setRedrawOnDrag(value) {
        settings.redrawOnDrag = value;
        writeStorage("redrawOnDrag", value);
      }

      function setBoardRotation(value) {
        settings.boardRotation = value * 5;
        writeStorage("boardRotation", settings.boardRotation);
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
        resizeAll();
      }

      function initRender() {
        allcanvas = {
          front: {
            transform: {
              x: 0,
              y: 0,
              s: 1,
              panx: 0,
              pany: 0,
              zoom: 1,
            },
            pointerStates: {},
            anotherPointerTapped: false,
            bg: document.getElementById("F_bg"),
            fab: document.getElementById("F_fab"),
            silk: document.getElementById("F_slk"),
            highlight: document.getElementById("F_hl"),
            layer: "F",
          },
          back: {
            transform: {
              x: 0,
              y: 0,
              s: 1,
              panx: 0,
              pany: 0,
              zoom: 1,
            },
            pointerStates: {},
            anotherPointerTapped: false,
            bg: document.getElementById("B_bg"),
            fab: document.getElementById("B_fab"),
            silk: document.getElementById("B_slk"),
            highlight: document.getElementById("B_hl"),
            layer: "B",
          },
        };
        addMouseHandlers(
          document.getElementById("frontcanvas"),
          allcanvas.front,
        );
        addMouseHandlers(document.getElementById("backcanvas"), allcanvas.back);
      }

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /*
       * Table reordering via Drag'n'Drop
       * Inspired by: https://htmldom.dev/drag-and-drop-table-column
       */

      function setBomHandlers() {
        const bom = document.getElementById("bomtable");

        let dragName;
        let placeHolderElements;
        let draggingElement;
        let forcePopulation;
        let xOffset;
        let yOffset;
        let wasDragged;

        const mouseUpHandler = function (e) {
          // Delete dragging element
          draggingElement.remove();

          // Make BOM selectable again
          bom.style.removeProperty("userSelect");

          // Remove listeners
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);

          if (wasDragged) {
            // Redraw whole BOM
            populateBomTable();
          }
        };

        const mouseMoveHandler = function (e) {
          // Notice the dragging
          wasDragged = true;

          // Make the dragged element visible
          draggingElement.style.removeProperty("display");

          // Set elements position to mouse position
          draggingElement.style.left = `${e.screenX - xOffset}px`;
          draggingElement.style.top = `${e.screenY - yOffset}px`;

          // Forced redrawing of BOM table
          if (forcePopulation) {
            forcePopulation = false;
            // Copy array
            phe = Array.from(placeHolderElements);
            // populate BOM table again
            populateBomHeader(dragName, phe);
            populateBomBody(dragName, phe);
          }

          // Set up array of hidden columns
          var hiddenColumns = Array.from(settings.hiddenColumns);
          // In the ungrouped mode, quantity don't exist
          if (settings.bommode === "ungrouped") hiddenColumns.push("Quantity");
          // If no checkbox fields can be found, we consider them hidden
          if (settings.checkboxes.length == 0) hiddenColumns.push("checkboxes");

          // Get table headers and group them into checkboxes, extrafields and normal headers
          const bh = document.getElementById("bomhead");
          headers = Array.from(bh.querySelectorAll("th"));
          headers.shift(); // numCol is not part of the columnOrder
          headerGroups = [];
          lastCompoundClass = null;
          for (i = 0; i < settings.columnOrder.length; i++) {
            cElem = settings.columnOrder[i];
            if (hiddenColumns.includes(cElem)) {
              // Hidden columns appear as a dummy element
              headerGroups.push([]);
              continue;
            }
            elem = headers.filter((e) => getColumnOrderName(e) === cElem)[0];
            if (elem.classList.contains("bom-checkbox")) {
              if (lastCompoundClass === "bom-checkbox") {
                cbGroup = headerGroups.pop();
                cbGroup.push(elem);
                headerGroups.push(cbGroup);
              } else {
                lastCompoundClass = "bom-checkbox";
                headerGroups.push([elem]);
              }
            } else {
              headerGroups.push([elem]);
            }
          }

          // Copy settings.columnOrder
          var columns = Array.from(settings.columnOrder);

          // Set up array with indices of hidden columns
          var hiddenIndices = hiddenColumns.map((e) =>
            settings.columnOrder.indexOf(e),
          );
          var dragIndex = columns.indexOf(dragName);
          var swapIndex = dragIndex;
          var swapDone = false;

          // Check if the current dragged element is swapable with the left or right element
          if (dragIndex > 0) {
            // Get left headers boundingbox
            swapIndex = dragIndex - 1;
            while (hiddenIndices.includes(swapIndex) && swapIndex > 0)
              swapIndex--;
            if (!hiddenIndices.includes(swapIndex)) {
              box = getBoundingClientRectFromMultiple(headerGroups[swapIndex]);
              if (e.clientX < box.left + window.scrollX + box.width / 2) {
                swapElement = columns[dragIndex];
                columns.splice(dragIndex, 1);
                columns.splice(swapIndex, 0, swapElement);
                forcePopulation = true;
                swapDone = true;
              }
            }
          }
          if (!swapDone && dragIndex < headerGroups.length - 1) {
            // Get right headers boundingbox
            swapIndex = dragIndex + 1;
            while (hiddenIndices.includes(swapIndex)) swapIndex++;
            if (swapIndex < headerGroups.length) {
              box = getBoundingClientRectFromMultiple(headerGroups[swapIndex]);
              if (e.clientX > box.left + window.scrollX + box.width / 2) {
                swapElement = columns[dragIndex];
                columns.splice(dragIndex, 1);
                columns.splice(swapIndex, 0, swapElement);
                forcePopulation = true;
                swapDone = true;
              }
            }
          }

          // Write back change to storage
          if (swapDone) {
            settings.columnOrder = columns;
            writeStorage("columnOrder", JSON.stringify(columns));
          }
        };

        const mouseDownHandler = function (e) {
          var target = e.target;
          if (target.tagName.toLowerCase() != "td")
            target = target.parentElement;

          // Used to check if a dragging has ever happened
          wasDragged = false;

          // Create new element which will be displayed as the dragged column
          draggingElement = document.createElement("div");
          draggingElement.classList.add("dragging");
          draggingElement.style.display = "none";
          draggingElement.style.position = "absolute";
          draggingElement.style.overflow = "hidden";

          // Get bomhead and bombody elements
          const bh = document.getElementById("bomhead");
          const bb = document.getElementById("bombody");

          // Get all compound headers for the current column
          var compoundHeaders;
          if (target.classList.contains("bom-checkbox")) {
            compoundHeaders = Array.from(
              bh.querySelectorAll("th.bom-checkbox"),
            );
          } else {
            compoundHeaders = [target];
          }

          // Create new table which will display the column
          var newTable = document.createElement("table");
          newTable.classList.add("bom");
          newTable.style.background = "white";
          draggingElement.append(newTable);

          // Create new header element
          var newHeader = document.createElement("thead");
          newTable.append(newHeader);

          // Set up array for storing all placeholder elements
          placeHolderElements = [];

          // Add all compound headers to the new thead element and placeholders
          compoundHeaders.forEach(function (h) {
            clone = cloneElementWithDimensions(h);
            newHeader.append(clone);
            placeHolderElements.push(clone);
          });

          // Create new body element
          var newBody = document.createElement("tbody");
          newTable.append(newBody);

          // Get indices for compound headers
          var idxs = compoundHeaders.map((e) => getBomTableHeaderIndex(e));

          // For each row in the BOM body...
          var rows = bb.querySelectorAll("tr");
          rows.forEach(function (row) {
            // ..get the cells for the compound column
            const tds = row.querySelectorAll("td");
            var copytds = idxs.map((i) => tds[i]);
            // Add them to the new element and the placeholders
            var newRow = document.createElement("tr");
            copytds.forEach(function (td) {
              clone = cloneElementWithDimensions(td);
              newRow.append(clone);
              placeHolderElements.push(clone);
            });
            newBody.append(newRow);
          });

          // Compute width for compound header
          var width = compoundHeaders.reduce(
            (acc, x) => acc + x.clientWidth,
            0,
          );
          draggingElement.style.width = `${width}px`;

          // Insert the new dragging element and disable selection on BOM
          bom.insertBefore(draggingElement, null);
          bom.style.userSelect = "none";

          // Determine the mouse position offset
          xOffset =
            e.screenX -
            compoundHeaders.reduce(
              (acc, x) => Math.min(acc, x.offsetLeft),
              compoundHeaders[0].offsetLeft,
            );
          yOffset = e.screenY - compoundHeaders[0].offsetTop;

          // Get name for the column in settings.columnOrder
          dragName = getColumnOrderName(target);

          // Change text and class for placeholder elements
          placeHolderElements = placeHolderElements.map(function (e) {
            newElem = cloneElementWithDimensions(e);
            newElem.textContent = "";
            newElem.classList.add("placeholder");
            return newElem;
          });

          // On next mouse move, the whole BOM needs to be redrawn to show the placeholders
          forcePopulation = true;

          // Add listeners for move and up on mouse
          document.addEventListener("mousemove", mouseMoveHandler);
          document.addEventListener("mouseup", mouseUpHandler);
        };

        // In netlist mode, there is nothing to reorder
        if (settings.bommode === "netlist") return;

        // Add mouseDownHandler to every column except the numCol
        bom.querySelectorAll("th").forEach(function (head) {
          if (!head.classList.contains("numCol")) {
            head.onmousedown = mouseDownHandler;
          }
        });
      }

      function getBoundingClientRectFromMultiple(elements) {
        var elems = Array.from(elements);

        if (elems.length == 0) return null;

        var box = elems.shift().getBoundingClientRect();

        elems.forEach(function (elem) {
          var elembox = elem.getBoundingClientRect();
          box.left = Math.min(elembox.left, box.left);
          box.top = Math.min(elembox.top, box.top);
          box.width += elembox.width;
          box.height = Math.max(elembox.height, box.height);
        });

        return box;
      }

      function cloneElementWithDimensions(elem) {
        var newElem = elem.cloneNode(true);
        newElem.style.height = window.getComputedStyle(elem).height;
        newElem.style.width = window.getComputedStyle(elem).width;
        return newElem;
      }

      function getBomTableHeaderIndex(elem) {
        const bh = document.getElementById("bomhead");
        const ths = Array.from(bh.querySelectorAll("th"));
        return ths.indexOf(elem);
      }

      function getColumnOrderName(elem) {
        var cname = elem.getAttribute("col_name");
        if (cname === "bom-checkbox") return "checkboxes";
        else return cname;
      }

      function resizableGrid(tablehead) {
        var cols = tablehead.firstElementChild.children;
        var rowWidth = tablehead.offsetWidth;

        for (var i = 1; i < cols.length; i++) {
          if (cols[i].classList.contains("bom-checkbox")) continue;
          cols[i].style.width =
            ((cols[i].clientWidth - paddingDiff(cols[i])) * 100) / rowWidth +
            "%";
        }

        for (var i = 1; i < cols.length - 1; i++) {
          var div = document.createElement("div");
          div.className = "column-width-handle";
          cols[i].appendChild(div);
          setListeners(div);
        }

        function setListeners(div) {
          var startX, curCol, nxtCol, curColWidth, nxtColWidth, rowWidth;

          div.addEventListener("mousedown", function (e) {
            e.preventDefault();
            e.stopPropagation();

            curCol = e.target.parentElement;
            nxtCol = curCol.nextElementSibling;
            startX = e.pageX;

            var padding = paddingDiff(curCol);

            rowWidth = curCol.parentElement.offsetWidth;
            curColWidth = curCol.clientWidth - padding;
            nxtColWidth = nxtCol.clientWidth - padding;
          });

          document.addEventListener("mousemove", function (e) {
            if (startX) {
              var diffX = e.pageX - startX;
              diffX = -Math.min(-diffX, curColWidth - 20);
              diffX = Math.min(diffX, nxtColWidth - 20);

              curCol.style.width =
                ((curColWidth + diffX) * 100) / rowWidth + "%";
              nxtCol.style.width =
                ((nxtColWidth - diffX) * 100) / rowWidth + "%";
              console.log(
                `${curColWidth + nxtColWidth} ${
                  ((curColWidth + diffX) * 100) / rowWidth +
                  ((nxtColWidth - diffX) * 100) / rowWidth
                }`,
              );
            }
          });

          document.addEventListener("mouseup", function (e) {
            curCol = undefined;
            nxtCol = undefined;
            startX = undefined;
            nxtColWidth = undefined;
            curColWidth = undefined;
          });
        }

        function paddingDiff(col) {
          if (getStyleVal(col, "box-sizing") == "border-box") {
            return 0;
          }

          var padLeft = getStyleVal(col, "padding-left");
          var padRight = getStyleVal(col, "padding-right");
          return parseInt(padLeft) + parseInt(padRight);
        }

        function getStyleVal(elm, css) {
          return window.getComputedStyle(elm, null).getPropertyValue(css);
        }
      }

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* DOM manipulation and misc code */

      var bomsplit;
      var canvassplit;
      var initDone = false;
      var bomSortFunction = null;
      var currentSortColumn = null;
      var currentSortOrder = null;
      var currentHighlightedRowId;
      var highlightHandlers = [];
      var footprintIndexToHandler = {};
      var netsToHandler = {};
      var markedFootprints = new Set();
      var highlightedFootprints = [];
      var highlightedNet = null;
      var lastClicked;

      function dbg(html) {
        dbgdiv.innerHTML = html;
      }

      function redrawIfInitDone() {
        if (initDone) {
          redrawCanvas(allcanvas.front);
          redrawCanvas(allcanvas.back);
        }
      }

      function padsVisible(value) {
        writeStorage("padsVisible", value);
        settings.renderPads = value;
        redrawIfInitDone();
      }

      function referencesVisible(value) {
        writeStorage("referencesVisible", value);
        settings.renderReferences = value;
        redrawIfInitDone();
      }

      function valuesVisible(value) {
        writeStorage("valuesVisible", value);
        settings.renderValues = value;
        redrawIfInitDone();
      }

      function tracksVisible(value) {
        writeStorage("tracksVisible", value);
        settings.renderTracks = value;
        redrawIfInitDone();
      }

      function zonesVisible(value) {
        writeStorage("zonesVisible", value);
        settings.renderZones = value;
        redrawIfInitDone();
      }

      function dnpOutline(value) {
        writeStorage("dnpOutline", value);
        settings.renderDnpOutline = value;
        redrawIfInitDone();
      }

      function setDarkMode(value) {
        if (value) {
          topmostdiv.classList.add("dark");
        } else {
          topmostdiv.classList.remove("dark");
        }
        writeStorage("darkmode", value);
        settings.darkMode = value;
        redrawIfInitDone();
      }

      function setShowBOMColumn(field, value) {
        if (field === "references") {
          var rl = document.getElementById("reflookup");
          rl.disabled = !value;
          if (!value) {
            rl.value = "";
            updateRefLookup("");
          }
        }

        var n = settings.hiddenColumns.indexOf(field);
        if (value) {
          if (n != -1) {
            settings.hiddenColumns.splice(n, 1);
          }
        } else {
          if (n == -1) {
            settings.hiddenColumns.push(field);
          }
        }

        writeStorage("hiddenColumns", JSON.stringify(settings.hiddenColumns));

        if (initDone) {
          populateBomTable();
        }

        redrawIfInitDone();
      }

      function setFullscreen(value) {
        if (value) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }

      function fabricationVisible(value) {
        writeStorage("fabricationVisible", value);
        settings.renderFabrication = value;
        redrawIfInitDone();
      }

      function silkscreenVisible(value) {
        writeStorage("silkscreenVisible", value);
        settings.renderSilkscreen = value;
        redrawIfInitDone();
      }

      function setHighlightPin1(value) {
        writeStorage("highlightpin1", value);
        settings.highlightpin1 = value;
        redrawIfInitDone();
      }

      function getStoredCheckboxRefs(checkbox) {
        function convert(ref) {
          var intref = parseInt(ref);
          if (isNaN(intref)) {
            for (var i = 0; i < pcbdata.footprints.length; i++) {
              if (pcbdata.footprints[i].ref == ref) {
                return i;
              }
            }
            return -1;
          } else {
            return intref;
          }
        }
        if (!(checkbox in settings.checkboxStoredRefs)) {
          var val = readStorage("checkbox_" + checkbox);
          settings.checkboxStoredRefs[checkbox] = val ? val : "";
        }
        if (!settings.checkboxStoredRefs[checkbox]) {
          return new Set();
        } else {
          return new Set(
            settings.checkboxStoredRefs[checkbox]
              .split(",")
              .map((r) => convert(r))
              .filter((a) => a >= 0),
          );
        }
      }

      function getCheckboxState(checkbox, references) {
        var storedRefsSet = getStoredCheckboxRefs(checkbox);
        var currentRefsSet = new Set(references.map((r) => r[1]));
        // Get difference of current - stored
        var difference = new Set(currentRefsSet);
        for (ref of storedRefsSet) {
          difference.delete(ref);
        }
        if (difference.size == 0) {
          // All the current refs are stored
          return "checked";
        } else if (difference.size == currentRefsSet.size) {
          // None of the current refs are stored
          return "unchecked";
        } else {
          // Some of the refs are stored
          return "indeterminate";
        }
      }

      function setBomCheckboxState(checkbox, element, references) {
        var state = getCheckboxState(checkbox, references);
        element.checked = state == "checked";
        element.indeterminate = state == "indeterminate";
      }

      function createCheckboxChangeHandler(checkbox, references, row) {
        return function () {
          refsSet = getStoredCheckboxRefs(checkbox);
          var markWhenChecked = settings.markWhenChecked == checkbox;
          eventArgs = {
            checkbox: checkbox,
            refs: references,
          };
          if (this.checked) {
            // checkbox ticked
            for (var ref of references) {
              refsSet.add(ref[1]);
            }
            if (markWhenChecked) {
              row.classList.add("checked");
              for (var ref of references) {
                markedFootprints.add(ref[1]);
              }
              drawHighlights();
            }
            eventArgs.state = "checked";
          } else {
            // checkbox unticked
            for (var ref of references) {
              refsSet.delete(ref[1]);
            }
            if (markWhenChecked) {
              row.classList.remove("checked");
              for (var ref of references) {
                markedFootprints.delete(ref[1]);
              }
              drawHighlights();
            }
            eventArgs.state = "unchecked";
          }
          settings.checkboxStoredRefs[checkbox] = [...refsSet].join(",");
          writeStorage(
            "checkbox_" + checkbox,
            settings.checkboxStoredRefs[checkbox],
          );
          updateCheckboxStats(checkbox);
          EventHandler.emitEvent(
            IBOM_EVENT_TYPES.CHECKBOX_CHANGE_EVENT,
            eventArgs,
          );
        };
      }

      function clearHighlightedFootprints() {
        if (currentHighlightedRowId) {
          document
            .getElementById(currentHighlightedRowId)
            .classList.remove("highlighted");
          currentHighlightedRowId = null;
          highlightedFootprints = [];
          highlightedNet = null;
        }
      }

      function createRowHighlightHandler(rowid, refs, net) {
        return function () {
          if (currentHighlightedRowId) {
            if (currentHighlightedRowId == rowid) {
              return;
            }
            document
              .getElementById(currentHighlightedRowId)
              .classList.remove("highlighted");
          }
          document.getElementById(rowid).classList.add("highlighted");
          currentHighlightedRowId = rowid;
          highlightedFootprints = refs ? refs.map((r) => r[1]) : [];
          highlightedNet = net;
          drawHighlights();
          EventHandler.emitEvent(IBOM_EVENT_TYPES.HIGHLIGHT_EVENT, {
            rowid: rowid,
            refs: refs,
            net: net,
          });
        };
      }

      function entryMatches(entry) {
        if (settings.bommode == "netlist") {
          // entry is just a net name
          return entry.toLowerCase().indexOf(filter) >= 0;
        }
        // check refs
        if (!settings.hiddenColumns.includes("references")) {
          for (var ref of entry) {
            if (ref[0].toLowerCase().indexOf(filter) >= 0) {
              return true;
            }
          }
        }
        // check fields
        for (var i in config.fields) {
          var f = config.fields[i];
          if (!settings.hiddenColumns.includes(f)) {
            for (var ref of entry) {
              if (
                pcbdata.bom.fields[ref[1]][i].toLowerCase().indexOf(filter) >= 0
              ) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function findRefInEntry(entry) {
        return entry.filter((r) => r[0].toLowerCase() == reflookup);
      }

      function highlightFilter(s) {
        if (!filter) {
          return s;
        }
        var parts = s.toLowerCase().split(filter);
        if (parts.length == 1) {
          return s;
        }
        var r = "";
        var pos = 0;
        for (var i in parts) {
          if (i > 0) {
            r +=
              '<mark class="highlight">' +
              s.substring(pos, pos + filter.length) +
              "</mark>";
            pos += filter.length;
          }
          r += s.substring(pos, pos + parts[i].length);
          pos += parts[i].length;
        }
        return r;
      }

      function checkboxSetUnsetAllHandler(checkboxname) {
        return function () {
          var checkboxnum = 0;
          while (
            checkboxnum < settings.checkboxes.length &&
            settings.checkboxes[checkboxnum].toLowerCase() !=
              checkboxname.toLowerCase()
          ) {
            checkboxnum++;
          }
          if (checkboxnum >= settings.checkboxes.length) {
            return;
          }
          var allset = true;
          var checkbox;
          var row;
          for (row of bombody.childNodes) {
            checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
            if (!checkbox.checked || checkbox.indeterminate) {
              allset = false;
              break;
            }
          }
          for (row of bombody.childNodes) {
            checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
            checkbox.checked = !allset;
            checkbox.indeterminate = false;
            checkbox.onchange();
          }
        };
      }

      function createColumnHeader(name, cls, comparator, is_checkbox = false) {
        var th = document.createElement("TH");
        th.innerHTML = name;
        th.classList.add(cls);
        if (is_checkbox) th.setAttribute("col_name", "bom-checkbox");
        else th.setAttribute("col_name", name);
        var span = document.createElement("SPAN");
        span.classList.add("sortmark");
        span.classList.add("none");
        th.appendChild(span);
        var spacer = document.createElement("div");
        spacer.className = "column-spacer";
        th.appendChild(spacer);
        spacer.onclick = function () {
          if (currentSortColumn && th !== currentSortColumn) {
            // Currently sorted by another column
            currentSortColumn.childNodes[1].classList.remove(currentSortOrder);
            currentSortColumn.childNodes[1].classList.add("none");
            currentSortColumn = null;
            currentSortOrder = null;
          }
          if (currentSortColumn && th === currentSortColumn) {
            // Already sorted by this column
            if (currentSortOrder == "asc") {
              // Sort by this column, descending order
              bomSortFunction = function (a, b) {
                return -comparator(a, b);
              };
              currentSortColumn.childNodes[1].classList.remove("asc");
              currentSortColumn.childNodes[1].classList.add("desc");
              currentSortOrder = "desc";
            } else {
              // Unsort
              bomSortFunction = null;
              currentSortColumn.childNodes[1].classList.remove("desc");
              currentSortColumn.childNodes[1].classList.add("none");
              currentSortColumn = null;
              currentSortOrder = null;
            }
          } else {
            // Sort by this column, ascending order
            bomSortFunction = comparator;
            currentSortColumn = th;
            currentSortColumn.childNodes[1].classList.remove("none");
            currentSortColumn.childNodes[1].classList.add("asc");
            currentSortOrder = "asc";
          }
          populateBomBody();
        };
        if (is_checkbox) {
          spacer.onclick = fancyDblClickHandler(
            spacer,
            spacer.onclick,
            checkboxSetUnsetAllHandler(name),
          );
        }
        return th;
      }

      function populateBomHeader(
        placeHolderColumn = null,
        placeHolderElements = null,
      ) {
        while (bomhead.firstChild) {
          bomhead.removeChild(bomhead.firstChild);
        }
        var tr = document.createElement("TR");
        var th = document.createElement("TH");
        th.classList.add("numCol");

        var vismenu = document.createElement("div");
        vismenu.id = "vismenu";
        vismenu.classList.add("menu");

        var visbutton = document.createElement("div");
        visbutton.classList.add("visbtn");
        visbutton.classList.add("hideonprint");

        var viscontent = document.createElement("div");
        viscontent.classList.add("menu-content");
        viscontent.id = "vismenu-content";

        settings.columnOrder.forEach((column) => {
          if (typeof column !== "string") return;

          // Skip empty columns
          if (column === "checkboxes" && settings.checkboxes.length == 0)
            return;
          else if (column === "Quantity" && settings.bommode == "ungrouped")
            return;

          var label = document.createElement("label");
          label.classList.add("menu-label");

          var input = document.createElement("input");
          input.classList.add("visibility_checkbox");
          input.type = "checkbox";
          input.onchange = function (e) {
            setShowBOMColumn(column, e.target.checked);
          };
          input.checked = !settings.hiddenColumns.includes(column);

          label.appendChild(input);
          if (column.length > 0)
            label.append(column[0].toUpperCase() + column.slice(1));

          viscontent.appendChild(label);
        });

        viscontent.childNodes[0].classList.add("menu-label-top");

        vismenu.appendChild(visbutton);
        if (settings.bommode != "netlist") {
          vismenu.appendChild(viscontent);
          th.appendChild(vismenu);
        }
        tr.appendChild(th);

        var checkboxCompareClosure = function (checkbox) {
          return (a, b) => {
            var stateA = getCheckboxState(checkbox, a);
            var stateB = getCheckboxState(checkbox, b);
            if (stateA > stateB) return -1;
            if (stateA < stateB) return 1;
            return 0;
          };
        };
        var stringFieldCompareClosure = function (fieldIndex) {
          return (a, b) => {
            var fa = pcbdata.bom.fields[a[0][1]][fieldIndex];
            var fb = pcbdata.bom.fields[b[0][1]][fieldIndex];
            if (fa != fb) return fa > fb ? 1 : -1;
            else return 0;
          };
        };
        var referenceRegex = /(?<prefix>[^0-9]+)(?<number>[0-9]+)/;
        var compareRefs = (a, b) => {
          var ra = referenceRegex.exec(a);
          var rb = referenceRegex.exec(b);
          if (ra === null || rb === null) {
            if (a != b) return a > b ? 1 : -1;
            return 0;
          } else {
            if (ra.groups.prefix != rb.groups.prefix) {
              return ra.groups.prefix > rb.groups.prefix ? 1 : -1;
            }
            if (ra.groups.number != rb.groups.number) {
              return parseInt(ra.groups.number) > parseInt(rb.groups.number)
                ? 1
                : -1;
            }
            return 0;
          }
        };
        if (settings.bommode == "netlist") {
          th = createColumnHeader("Net name", "bom-netname", (a, b) => {
            if (a > b) return -1;
            if (a < b) return 1;
            return 0;
          });
          tr.appendChild(th);
        } else {
          // Filter hidden columns
          var columns = settings.columnOrder.filter(
            (e) => !settings.hiddenColumns.includes(e),
          );
          var valueIndex = config.fields.indexOf("Value");
          var footprintIndex = config.fields.indexOf("Footprint");
          columns.forEach((column) => {
            if (column === placeHolderColumn) {
              var n = 1;
              if (column === "checkboxes") n = settings.checkboxes.length;
              for (i = 0; i < n; i++) {
                td = placeHolderElements.shift();
                tr.appendChild(td);
              }
              return;
            } else if (column === "checkboxes") {
              for (var checkbox of settings.checkboxes) {
                th = createColumnHeader(
                  checkbox,
                  "bom-checkbox",
                  checkboxCompareClosure(checkbox),
                  true,
                );
                tr.appendChild(th);
              }
            } else if (column === "References") {
              tr.appendChild(
                createColumnHeader("References", "references", (a, b) => {
                  var i = 0;
                  while (i < a.length && i < b.length) {
                    if (a[i] != b[i]) return compareRefs(a[i][0], b[i][0]);
                    i++;
                  }
                  return a.length - b.length;
                }),
              );
            } else if (column === "Value") {
              tr.appendChild(
                createColumnHeader("Value", "value", (a, b) => {
                  var ra = a[0][1],
                    rb = b[0][1];
                  return valueCompare(
                    pcbdata.bom.parsedValues[ra],
                    pcbdata.bom.parsedValues[rb],
                    pcbdata.bom.fields[ra][valueIndex],
                    pcbdata.bom.fields[rb][valueIndex],
                  );
                }),
              );
              return;
            } else if (column === "Footprint") {
              tr.appendChild(
                createColumnHeader(
                  "Footprint",
                  "footprint",
                  stringFieldCompareClosure(footprintIndex),
                ),
              );
            } else if (column === "Quantity" && settings.bommode == "grouped") {
              tr.appendChild(
                createColumnHeader("Quantity", "quantity", (a, b) => {
                  return a.length - b.length;
                }),
              );
            } else {
              // Other fields
              var i = config.fields.indexOf(column);
              if (i < 0) return;
              tr.appendChild(
                createColumnHeader(
                  column,
                  `field${i + 1}`,
                  stringFieldCompareClosure(i),
                ),
              );
            }
          });
        }
        bomhead.appendChild(tr);
      }

      function populateBomBody(
        placeholderColumn = null,
        placeHolderElements = null,
      ) {
        while (bom.firstChild) {
          bom.removeChild(bom.firstChild);
        }
        highlightHandlers = [];
        footprintIndexToHandler = {};
        netsToHandler = {};
        currentHighlightedRowId = null;
        var first = true;
        if (settings.bommode == "netlist") {
          bomtable = pcbdata.nets.slice();
        } else {
          switch (settings.canvaslayout) {
            case "F":
              bomtable = pcbdata.bom.F.slice();
              break;
            case "FB":
              bomtable = pcbdata.bom.both.slice();
              break;
            case "B":
              bomtable = pcbdata.bom.B.slice();
              break;
          }
          if (settings.bommode == "ungrouped") {
            // expand bom table
            expandedTable = [];
            for (var bomentry of bomtable) {
              for (var ref of bomentry) {
                expandedTable.push([ref]);
              }
            }
            bomtable = expandedTable;
          }
        }
        if (bomSortFunction) {
          bomtable = bomtable.sort(bomSortFunction);
        }
        for (var i in bomtable) {
          var bomentry = bomtable[i];
          if (filter && !entryMatches(bomentry)) {
            continue;
          }
          var references = null;
          var netname = null;
          var tr = document.createElement("TR");
          var td = document.createElement("TD");
          var rownum = +i + 1;
          tr.id = "bomrow" + rownum;
          td.textContent = rownum;
          tr.appendChild(td);
          if (settings.bommode == "netlist") {
            netname = bomentry;
            td = document.createElement("TD");
            td.innerHTML = highlightFilter(
              netname ? netname : "&lt;no net&gt;",
            );
            tr.appendChild(td);
          } else {
            if (reflookup) {
              references = findRefInEntry(bomentry);
              if (references.length == 0) {
                continue;
              }
            } else {
              references = bomentry;
            }
            // Filter hidden columns
            var columns = settings.columnOrder.filter(
              (e) => !settings.hiddenColumns.includes(e),
            );
            columns.forEach((column) => {
              if (column === placeholderColumn) {
                var n = 1;
                if (column === "checkboxes") n = settings.checkboxes.length;
                for (i = 0; i < n; i++) {
                  td = placeHolderElements.shift();
                  tr.appendChild(td);
                }
                return;
              } else if (column === "checkboxes") {
                for (var checkbox of settings.checkboxes) {
                  if (checkbox) {
                    td = document.createElement("TD");
                    var input = document.createElement("input");
                    input.type = "checkbox";
                    input.onchange = createCheckboxChangeHandler(
                      checkbox,
                      references,
                      tr,
                    );
                    setBomCheckboxState(checkbox, input, references);
                    if (input.checked && settings.markWhenChecked == checkbox) {
                      tr.classList.add("checked");
                    }
                    td.appendChild(input);
                    tr.appendChild(td);
                  }
                }
              } else if (column === "References") {
                td = document.createElement("TD");
                td.innerHTML = highlightFilter(
                  references.map((r) => r[0]).join(", "),
                );
                tr.appendChild(td);
              } else if (
                column === "Quantity" &&
                settings.bommode == "grouped"
              ) {
                // Quantity
                td = document.createElement("TD");
                td.textContent = references.length;
                tr.appendChild(td);
              } else {
                // All the other fields
                var field_index = config.fields.indexOf(column);
                if (field_index < 0) return;
                var valueSet = new Set();
                references
                  .map((r) => r[1])
                  .forEach((id) =>
                    valueSet.add(pcbdata.bom.fields[id][field_index]),
                  );
                td = document.createElement("TD");
                td.innerHTML = highlightFilter(Array.from(valueSet).join(", "));
                tr.appendChild(td);
              }
            });
          }
          bom.appendChild(tr);
          var handler = createRowHighlightHandler(tr.id, references, netname);
          tr.onmousemove = handler;
          highlightHandlers.push({
            id: tr.id,
            handler: handler,
          });
          if (references !== null) {
            for (var refIndex of references.map((r) => r[1])) {
              footprintIndexToHandler[refIndex] = handler;
            }
          }
          if (netname !== null) {
            netsToHandler[netname] = handler;
          }
          if ((filter || reflookup) && first) {
            handler();
            first = false;
          }
        }
        EventHandler.emitEvent(IBOM_EVENT_TYPES.BOM_BODY_CHANGE_EVENT, {
          filter: filter,
          reflookup: reflookup,
          checkboxes: settings.checkboxes,
          bommode: settings.bommode,
        });
      }

      function highlightPreviousRow() {
        if (!currentHighlightedRowId) {
          highlightHandlers[highlightHandlers.length - 1].handler();
        } else {
          if (
            highlightHandlers.length > 1 &&
            highlightHandlers[0].id == currentHighlightedRowId
          ) {
            highlightHandlers[highlightHandlers.length - 1].handler();
          } else {
            for (var i = 0; i < highlightHandlers.length - 1; i++) {
              if (highlightHandlers[i + 1].id == currentHighlightedRowId) {
                highlightHandlers[i].handler();
                break;
              }
            }
          }
        }
        smoothScrollToRow(currentHighlightedRowId);
      }

      function highlightNextRow() {
        if (!currentHighlightedRowId) {
          highlightHandlers[0].handler();
        } else {
          if (
            highlightHandlers.length > 1 &&
            highlightHandlers[highlightHandlers.length - 1].id ==
              currentHighlightedRowId
          ) {
            highlightHandlers[0].handler();
          } else {
            for (var i = 1; i < highlightHandlers.length; i++) {
              if (highlightHandlers[i - 1].id == currentHighlightedRowId) {
                highlightHandlers[i].handler();
                break;
              }
            }
          }
        }
        smoothScrollToRow(currentHighlightedRowId);
      }

      function populateBomTable() {
        populateBomHeader();
        populateBomBody();
        setBomHandlers();
        resizableGrid(bomhead);
      }

      function footprintsClicked(footprintIndexes) {
        var lastClickedIndex = footprintIndexes.indexOf(lastClicked);
        for (var i = 1; i <= footprintIndexes.length; i++) {
          var refIndex =
            footprintIndexes[(lastClickedIndex + i) % footprintIndexes.length];
          if (refIndex in footprintIndexToHandler) {
            lastClicked = refIndex;
            footprintIndexToHandler[refIndex]();
            smoothScrollToRow(currentHighlightedRowId);
            break;
          }
        }
      }

      function netClicked(net) {
        if (net in netsToHandler) {
          netsToHandler[net]();
          smoothScrollToRow(currentHighlightedRowId);
        } else {
          clearHighlightedFootprints();
          highlightedNet = net;
          drawHighlights();
        }
      }

      function updateFilter(input) {
        filter = input.toLowerCase();
        populateBomTable();
      }

      function updateRefLookup(input) {
        reflookup = input.toLowerCase();
        populateBomTable();
      }

      function changeCanvasLayout(layout) {
        document.getElementById("fl-btn").classList.remove("depressed");
        document.getElementById("fb-btn").classList.remove("depressed");
        document.getElementById("bl-btn").classList.remove("depressed");
        switch (layout) {
          case "F":
            document.getElementById("fl-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.collapse(1);
            }
            break;
          case "B":
            document.getElementById("bl-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.collapse(0);
            }
            break;
          default:
            document.getElementById("fb-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.setSizes([50, 50]);
            }
        }
        settings.canvaslayout = layout;
        writeStorage("canvaslayout", layout);
        resizeAll();
        changeBomMode(settings.bommode);
      }

      function populateMetadata() {
        document.getElementById("title").innerHTML = pcbdata.metadata.title;
        document.getElementById("revision").innerHTML =
          "Rev: " + pcbdata.metadata.revision;
        document.getElementById("company").innerHTML = pcbdata.metadata.company;
        document.getElementById("filedate").innerHTML = pcbdata.metadata.date;
        if (pcbdata.metadata.title != "") {
          document.title = pcbdata.metadata.title + " BOM";
        }
        // Calculate board stats
        var fp_f = 0,
          fp_b = 0,
          pads_f = 0,
          pads_b = 0,
          pads_th = 0;
        for (var i = 0; i < pcbdata.footprints.length; i++) {
          if (pcbdata.bom.skipped.includes(i)) continue;
          var mod = pcbdata.footprints[i];
          if (mod.layer == "F") {
            fp_f++;
          } else {
            fp_b++;
          }
          for (var pad of mod.pads) {
            if (pad.type == "th") {
              pads_th++;
            } else {
              if (pad.layers.includes("F")) {
                pads_f++;
              }
              if (pad.layers.includes("B")) {
                pads_b++;
              }
            }
          }
        }
        document.getElementById("stats-components-front").innerHTML = fp_f;
        document.getElementById("stats-components-back").innerHTML = fp_b;
        document.getElementById("stats-components-total").innerHTML =
          fp_f + fp_b;
        document.getElementById("stats-groups-front").innerHTML =
          pcbdata.bom.F.length;
        document.getElementById("stats-groups-back").innerHTML =
          pcbdata.bom.B.length;
        document.getElementById("stats-groups-total").innerHTML =
          pcbdata.bom.both.length;
        document.getElementById("stats-smd-pads-front").innerHTML = pads_f;
        document.getElementById("stats-smd-pads-back").innerHTML = pads_b;
        document.getElementById("stats-smd-pads-total").innerHTML =
          pads_f + pads_b;
        document.getElementById("stats-th-pads").innerHTML = pads_th;
        // Update version string
        document.getElementById("github-link").innerHTML =
          "InteractiveHtmlBom&nbsp;" +
          /^v\d+\.\d+/.exec(pcbdata.ibom_version)[0];
      }

      function changeBomLayout(layout) {
        document.getElementById("bom-btn").classList.remove("depressed");
        document.getElementById("lr-btn").classList.remove("depressed");
        document.getElementById("tb-btn").classList.remove("depressed");
        switch (layout) {
          case "bom-only":
            document.getElementById("bom-btn").classList.add("depressed");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            document.getElementById("frontcanvas").style.display = "none";
            document.getElementById("backcanvas").style.display = "none";
            document.getElementById("bot").style.height = "";
            break;
          case "top-bottom":
            document.getElementById("tb-btn").classList.add("depressed");
            document.getElementById("frontcanvas").style.display = "";
            document.getElementById("backcanvas").style.display = "";
            document.getElementById("bot").style.height = "calc(100% - 80px)";
            document
              .getElementById("bomdiv")
              .classList.remove("split-horizontal");
            document
              .getElementById("canvasdiv")
              .classList.remove("split-horizontal");
            document
              .getElementById("frontcanvas")
              .classList.add("split-horizontal");
            document
              .getElementById("backcanvas")
              .classList.add("split-horizontal");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            bomsplit = Split(["#bomdiv", "#canvasdiv"], {
              sizes: [50, 50],
              onDragEnd: resizeAll,
              direction: "vertical",
              gutterSize: 5,
            });
            canvassplit = Split(["#frontcanvas", "#backcanvas"], {
              sizes: [50, 50],
              gutterSize: 5,
              onDragEnd: resizeAll,
            });
            break;
          case "left-right":
            document.getElementById("lr-btn").classList.add("depressed");
            document.getElementById("frontcanvas").style.display = "";
            document.getElementById("backcanvas").style.display = "";
            document.getElementById("bot").style.height = "calc(100% - 80px)";
            document.getElementById("bomdiv").classList.add("split-horizontal");
            document
              .getElementById("canvasdiv")
              .classList.add("split-horizontal");
            document
              .getElementById("frontcanvas")
              .classList.remove("split-horizontal");
            document
              .getElementById("backcanvas")
              .classList.remove("split-horizontal");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            bomsplit = Split(["#bomdiv", "#canvasdiv"], {
              sizes: [50, 50],
              onDragEnd: resizeAll,
              gutterSize: 5,
            });
            canvassplit = Split(["#frontcanvas", "#backcanvas"], {
              sizes: [50, 50],
              gutterSize: 5,
              direction: "vertical",
              onDragEnd: resizeAll,
            });
        }
        settings.bomlayout = layout;
        writeStorage("bomlayout", layout);
        changeCanvasLayout(settings.canvaslayout);
      }

      function changeBomMode(mode) {
        document
          .getElementById("bom-grouped-btn")
          .classList.remove("depressed");
        document
          .getElementById("bom-ungrouped-btn")
          .classList.remove("depressed");
        document
          .getElementById("bom-netlist-btn")
          .classList.remove("depressed");
        var chkbxs = document.getElementsByClassName("visibility_checkbox");

        switch (mode) {
          case "grouped":
            document
              .getElementById("bom-grouped-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = false;
            }
            break;
          case "ungrouped":
            document
              .getElementById("bom-ungrouped-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = false;
            }
            break;
          case "netlist":
            document
              .getElementById("bom-netlist-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = true;
            }
        }

        writeStorage("bommode", mode);
        if (mode != settings.bommode) {
          settings.bommode = mode;
          bomSortFunction = null;
          currentSortColumn = null;
          currentSortOrder = null;
          clearHighlightedFootprints();
        }
        populateBomTable();
      }

      function focusFilterField() {
        focusInputField(document.getElementById("filter"));
      }

      function focusRefLookupField() {
        focusInputField(document.getElementById("reflookup"));
      }

      function toggleBomCheckbox(bomrowid, checkboxnum) {
        if (!bomrowid || checkboxnum > settings.checkboxes.length) {
          return;
        }
        var bomrow = document.getElementById(bomrowid);
        var checkbox = bomrow.childNodes[checkboxnum].childNodes[0];
        checkbox.checked = !checkbox.checked;
        checkbox.indeterminate = false;
        checkbox.onchange();
      }

      function checkBomCheckbox(bomrowid, checkboxname) {
        var checkboxnum = 0;
        while (
          checkboxnum < settings.checkboxes.length &&
          settings.checkboxes[checkboxnum].toLowerCase() !=
            checkboxname.toLowerCase()
        ) {
          checkboxnum++;
        }
        if (!bomrowid || checkboxnum >= settings.checkboxes.length) {
          return;
        }
        var bomrow = document.getElementById(bomrowid);
        var checkbox = bomrow.childNodes[checkboxnum + 1].childNodes[0];
        checkbox.checked = true;
        checkbox.indeterminate = false;
        checkbox.onchange();
      }

      function setBomCheckboxes(value) {
        writeStorage("bomCheckboxes", value);
        settings.checkboxes = value
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e);
        prepCheckboxes();
        populateMarkWhenCheckedOptions();
        setMarkWhenChecked(settings.markWhenChecked);
      }

      function setMarkWhenChecked(value) {
        writeStorage("markWhenChecked", value);
        settings.markWhenChecked = value;
        markedFootprints.clear();
        for (var ref of value ? getStoredCheckboxRefs(value) : []) {
          markedFootprints.add(ref);
        }
        populateBomTable();
        drawHighlights();
      }

      function prepCheckboxes() {
        var table = document.getElementById("checkbox-stats");
        while (table.childElementCount > 1) {
          table.removeChild(table.lastChild);
        }
        if (settings.checkboxes.length) {
          table.style.display = "";
        } else {
          table.style.display = "none";
        }
        for (var checkbox of settings.checkboxes) {
          var tr = document.createElement("TR");
          var td = document.createElement("TD");
          td.innerHTML = checkbox;
          tr.appendChild(td);
          td = document.createElement("TD");
          td.id = "checkbox-stats-" + checkbox;
          var progressbar = document.createElement("div");
          progressbar.classList.add("bar");
          td.appendChild(progressbar);
          var text = document.createElement("div");
          text.classList.add("text");
          td.appendChild(text);
          tr.appendChild(td);
          table.appendChild(tr);
          updateCheckboxStats(checkbox);
        }
      }

      function populateMarkWhenCheckedOptions() {
        var container = document.getElementById("markWhenCheckedContainer");

        if (settings.checkboxes.length == 0) {
          container.parentElement.style.display = "none";
          return;
        }

        container.innerHTML = "";
        container.parentElement.style.display = "inline-block";

        function createOption(name, displayName) {
          var id = "markWhenChecked-" + name;

          var div = document.createElement("div");
          div.classList.add("radio-container");

          var input = document.createElement("input");
          input.type = "radio";
          input.name = "markWhenChecked";
          input.value = name;
          input.id = id;
          input.onchange = () => setMarkWhenChecked(name);
          div.appendChild(input);

          // Preserve the selected element when the checkboxes change
          if (name == settings.markWhenChecked) {
            input.checked = true;
          }

          var label = document.createElement("label");
          label.innerHTML = displayName;
          label.htmlFor = id;
          div.appendChild(label);

          container.appendChild(div);
        }
        createOption("", "None");
        for (var checkbox of settings.checkboxes) {
          createOption(checkbox, checkbox);
        }
      }

      function updateCheckboxStats(checkbox) {
        var checked = getStoredCheckboxRefs(checkbox).size;
        var total = pcbdata.footprints.length - pcbdata.bom.skipped.length;
        var percent = (checked * 100.0) / total;
        var td = document.getElementById("checkbox-stats-" + checkbox);
        td.firstChild.style.width = percent + "%";
        td.lastChild.innerHTML =
          checked + "/" + total + " (" + Math.round(percent) + "%)";
      }

      function constrain(number, min, max) {
        return Math.min(Math.max(parseInt(number), min), max);
      }

      document.onkeydown = function (e) {
        switch (e.key) {
          case "n":
            if (document.activeElement.type == "text") {
              return;
            }
            if (currentHighlightedRowId !== null) {
              checkBomCheckbox(currentHighlightedRowId, "placed");
              highlightNextRow();
              e.preventDefault();
            }
            break;
          case "ArrowUp":
            highlightPreviousRow();
            e.preventDefault();
            break;
          case "ArrowDown":
            highlightNextRow();
            e.preventDefault();
            break;
          case "ArrowLeft":
          case "ArrowRight":
            if (document.activeElement.type != "text") {
              e.preventDefault();
              let boardRotationElement =
                document.getElementById("boardRotation");
              settings.boardRotation = parseInt(boardRotationElement.value); // degrees / 5
              if (e.key == "ArrowLeft") {
                settings.boardRotation += 3; // 15 degrees
              } else {
                settings.boardRotation -= 3;
              }
              settings.boardRotation = constrain(
                settings.boardRotation,
                boardRotationElement.min,
                boardRotationElement.max,
              );
              boardRotationElement.value = settings.boardRotation;
              setBoardRotation(settings.boardRotation);
            }
            break;
          default:
            break;
        }
        if (e.altKey) {
          switch (e.key) {
            case "f":
              focusFilterField();
              e.preventDefault();
              break;
            case "r":
              focusRefLookupField();
              e.preventDefault();
              break;
            case "z":
              changeBomLayout("bom-only");
              e.preventDefault();
              break;
            case "x":
              changeBomLayout("left-right");
              e.preventDefault();
              break;
            case "c":
              changeBomLayout("top-bottom");
              e.preventDefault();
              break;
            case "v":
              changeCanvasLayout("F");
              e.preventDefault();
              break;
            case "b":
              changeCanvasLayout("FB");
              e.preventDefault();
              break;
            case "n":
              changeCanvasLayout("B");
              e.preventDefault();
              break;
            default:
              break;
          }
          if (e.key >= "1" && e.key <= "9") {
            toggleBomCheckbox(currentHighlightedRowId, parseInt(e.key));
            e.preventDefault();
          }
        }
      };

      function hideNetlistButton() {
        document
          .getElementById("bom-ungrouped-btn")
          .classList.remove("middle-button");
        document
          .getElementById("bom-ungrouped-btn")
          .classList.add("right-most-button");
        document.getElementById("bom-netlist-btn").style.display = "none";
      }

      window.onload = function (e) {
        initUtils();
        initRender();
        initStorage();
        initDefaults();
        cleanGutters();
        populateMetadata();
        dbgdiv = document.getElementById("dbg");
        bom = document.getElementById("bombody");
        bomhead = document.getElementById("bomhead");
        filter = "";
        reflookup = "";
        if (!("nets" in pcbdata)) {
          hideNetlistButton();
        }
        initDone = true;
        setBomCheckboxes(document.getElementById("bomCheckboxes").value);
        // Triggers render
        changeBomLayout(settings.bomlayout);

        // Users may leave fullscreen without touching the checkbox. Uncheck.
        document.addEventListener("fullscreenchange", () => {
          if (!document.fullscreenElement)
            document.getElementById("fullscreenCheckbox").checked = false;
        });
      };

      window.onresize = resizeAll;
      window.matchMedia("print").addListener(resizeAll);

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
    </script>
  </head>

  <body>
    <div id="topmostdiv" class="topmostdiv">
      <div id="top">
        <div style="float: right; height: 100%">
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="menubtn"></button>
            <div class="menu-content">
              <label
                class="menu-label menu-label-top"
                style="width: calc(50% - 18px)"
              >
                <input
                  id="darkmodeCheckbox"
                  type="checkbox"
                  onchange="setDarkMode(this.checked)"
                />
                Dark mode </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label menu-label-top"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="fullscreenCheckbox"
                  type="checkbox"
                  onchange="setFullscreen(this.checked)"
                />
                Full Screen
              </label>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="fabricationCheckbox"
                  type="checkbox"
                  checked
                  onchange="fabricationVisible(this.checked)"
                />
                Fab layer </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="silkscreenCheckbox"
                  type="checkbox"
                  checked
                  onchange="silkscreenVisible(this.checked)"
                />
                Silkscreen
              </label>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="referencesCheckbox"
                  type="checkbox"
                  checked
                  onchange="referencesVisible(this.checked)"
                />
                References </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="valuesCheckbox"
                  type="checkbox"
                  checked
                  onchange="valuesVisible(this.checked)"
                />
                Values
              </label>
              <div id="tracksAndZonesCheckboxes">
                <label class="menu-label" style="width: calc(50% - 18px)">
                  <input
                    id="tracksCheckbox"
                    type="checkbox"
                    checked
                    onchange="tracksVisible(this.checked)"
                  />
                  Tracks </label
                ><!-- This comment eats space! All of it!
            --><label
                  class="menu-label"
                  style="width: calc(50% - 17px); border-left: 0"
                >
                  <input
                    id="zonesCheckbox"
                    type="checkbox"
                    checked
                    onchange="zonesVisible(this.checked)"
                  />
                  Zones
                </label>
              </div>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="padsCheckbox"
                  type="checkbox"
                  checked
                  onchange="padsVisible(this.checked)"
                />
                Pads </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="dnpOutlineCheckbox"
                  type="checkbox"
                  checked
                  onchange="dnpOutline(this.checked)"
                />
                DNP outlined
              </label>
              <label class="menu-label">
                <input
                  id="highlightpin1Checkbox"
                  type="checkbox"
                  onchange="setHighlightPin1(this.checked)"
                />
                Highlight first pin
              </label>
              <label class="menu-label">
                <input
                  id="dragCheckbox"
                  type="checkbox"
                  checked
                  onchange="setRedrawOnDrag(this.checked)"
                />
                Continuous redraw on drag
              </label>
              <label class="menu-label">
                <span>Board rotation</span>
                <span style="float: right"
                  ><span id="rotationDegree">0</span>&#176;</span
                >
                <input
                  id="boardRotation"
                  type="range"
                  min="-36"
                  max="36"
                  value="0"
                  class="slider"
                  oninput="setBoardRotation(this.value)"
                />
              </label>
              <label class="menu-label">
                <div style="margin-left: 5px">Bom checkboxes</div>
                <input
                  id="bomCheckboxes"
                  class="menu-textbox"
                  type="text"
                  oninput="setBomCheckboxes(this.value)"
                />
              </label>
              <label class="menu-label">
                <div style="margin-left: 5px">Mark when checked</div>
                <div id="markWhenCheckedContainer"></div>
              </label>
              <label class="menu-label">
                <span class="shameless-plug">
                  <span>Created using</span>
                  <a
                    id="github-link"
                    target="blank"
                    href="https://github.com/openscopeproject/InteractiveHtmlBom"
                    >InteractiveHtmlBom</a
                  >
                  <a
                    target="blank"
                    title="Mouse and keyboard help"
                    href="https://github.com/openscopeproject/InteractiveHtmlBom/wiki/Usage#bom-page-mouse-actions"
                    style="text-decoration: none"
                    ><label class="help-link">?</label></a
                  >
                </span>
              </label>
            </div>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="fl-btn"
              class="left-most-button"
              onclick="changeCanvasLayout('F')"
              title="Front only"
            >
              F
            </button>
            <button
              id="fb-btn"
              class="middle-button"
              onclick="changeCanvasLayout('FB')"
              title="Front and Back"
            >
              FB
            </button>
            <button
              id="bl-btn"
              class="right-most-button"
              onclick="changeCanvasLayout('B')"
              title="Back only"
            >
              B
            </button>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="bom-btn"
              class="left-most-button"
              onclick="changeBomLayout('bom-only')"
              title="BOM only"
            ></button>
            <button
              id="lr-btn"
              class="middle-button"
              onclick="changeBomLayout('left-right')"
              title="BOM left, drawings right"
            ></button>
            <button
              id="tb-btn"
              class="right-most-button"
              onclick="changeBomLayout('top-bottom')"
              title="BOM top, drawings bot"
            ></button>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="bom-grouped-btn"
              class="left-most-button"
              onclick="changeBomMode('grouped')"
              title="Grouped BOM"
            ></button>
            <button
              id="bom-ungrouped-btn"
              class="middle-button"
              onclick="changeBomMode('ungrouped')"
              title="Ungrouped BOM"
            ></button>
            <button
              id="bom-netlist-btn"
              class="right-most-button"
              onclick="changeBomMode('netlist')"
              title="Netlist"
            ></button>
          </div>
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="statsbtn"></button>
            <div class="menu-content">
              <table class="stats">
                <tbody>
                  <tr>
                    <td width="40%">Board stats</td>
                    <td>Front</td>
                    <td>Back</td>
                    <td>Total</td>
                  </tr>
                  <tr>
                    <td>Components</td>
                    <td id="stats-components-front">~</td>
                    <td id="stats-components-back">~</td>
                    <td id="stats-components-total">~</td>
                  </tr>
                  <tr>
                    <td>Groups</td>
                    <td id="stats-groups-front">~</td>
                    <td id="stats-groups-back">~</td>
                    <td id="stats-groups-total">~</td>
                  </tr>
                  <tr>
                    <td>SMD pads</td>
                    <td id="stats-smd-pads-front">~</td>
                    <td id="stats-smd-pads-back">~</td>
                    <td id="stats-smd-pads-total">~</td>
                  </tr>
                  <tr>
                    <td>TH pads</td>
                    <td colspan="3" id="stats-th-pads">~</td>
                  </tr>
                </tbody>
              </table>
              <table class="stats">
                <col width="40%" />
                <col />
                <tbody id="checkbox-stats">
                  <tr>
                    <td colspan="2" style="border-top: 0">Checkboxes</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="iobtn"></button>
            <div class="menu-content">
              <div class="menu-label menu-label-top">
                <div style="margin-left: 5px">Save board image</div>
                <div class="flexbox">
                  <input
                    id="render-save-width"
                    class="menu-textbox"
                    type="text"
                    value="1000"
                    placeholder="Width"
                    style="flex-grow: 1; width: 50px"
                    oninput="validateSaveImgDimension(this)"
                  />
                  <span>X</span>
                  <input
                    id="render-save-height"
                    class="menu-textbox"
                    type="text"
                    value="1000"
                    placeholder="Height"
                    style="flex-grow: 1; width: 50px"
                    oninput="validateSaveImgDimension(this)"
                  />
                </div>
                <label>
                  <input id="render-save-transparent" type="checkbox" />
                  Transparent background
                </label>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveImage('F')">
                    Front
                  </button>
                  <button class="savebtn" onclick="saveImage('B')">Back</button>
                </div>
              </div>
              <div class="menu-label">
                <span style="margin-left: 5px">Config and checkbox state</span>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveSettings()">
                    Export
                  </button>
                  <button class="savebtn" onclick="loadSettings()">
                    Import
                  </button>
                </div>
              </div>
              <div class="menu-label">
                <span style="margin-left: 5px">Save bom table as</span>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveBomTable('csv')">
                    csv
                  </button>
                  <button class="savebtn" onclick="saveBomTable('txt')">
                    txt
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="fileinfodiv" style="overflow: auto">
          <table class="fileinfo">
            <tbody>
              <tr>
                <td id="title" class="title" style="width: 70%">Title</td>
                <td id="revision" class="title" style="width: 30%">Revision</td>
              </tr>
              <tr>
                <td id="company">Company</td>
                <td id="filedate">Date</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div id="bot" class="split" style="height: calc(100% - 80px)">
        <div id="bomdiv" class="split split-horizontal">
          <div style="width: 100%">
            <input
              id="reflookup"
              class="textbox searchbox reflookup hideonprint"
              type="text"
              placeholder="Ref lookup"
              oninput="updateRefLookup(this.value)"
            />
            <input
              id="filter"
              class="textbox searchbox filter hideonprint"
              type="text"
              placeholder="Filter"
              oninput="updateFilter(this.value)"
            />
            <div
              class="button-container hideonprint"
              style="float: left; margin: 0"
            >
              <button
                id="copy"
                title="Copy bom table to clipboard"
                onclick="saveBomTable('clipboard')"
              ></button>
            </div>
          </div>
          <div id="dbg"></div>
          <table class="bom" id="bomtable">
            <thead id="bomhead"></thead>
            <tbody id="bombody"></tbody>
          </table>
        </div>
        <div id="canvasdiv" class="split split-horizontal">
          <div
            id="frontcanvas"
            class="split"
            touch-action="none"
            style="overflow: hidden"
          >
            <div style="position: relative; width: 100%; height: 100%">
              <canvas
                id="F_bg"
                style="position: absolute; left: 0; top: 0; z-index: 0"
              ></canvas>
              <canvas
                id="F_fab"
                style="position: absolute; left: 0; top: 0; z-index: 1"
              ></canvas>
              <canvas
                id="F_slk"
                style="position: absolute; left: 0; top: 0; z-index: 2"
              ></canvas>
              <canvas
                id="F_hl"
                style="position: absolute; left: 0; top: 0; z-index: 3"
              ></canvas>
            </div>
          </div>
          <div
            id="backcanvas"
            class="split"
            touch-action="none"
            style="overflow: hidden"
          >
            <div style="position: relative; width: 100%; height: 100%">
              <canvas
                id="B_bg"
                style="position: absolute; left: 0; top: 0; z-index: 0"
              ></canvas>
              <canvas
                id="B_fab"
                style="position: absolute; left: 0; top: 0; z-index: 1"
              ></canvas>
              <canvas
                id="B_slk"
                style="position: absolute; left: 0; top: 0; z-index: 2"
              ></canvas>
              <canvas
                id="B_hl"
                style="position: absolute; left: 0; top: 0; z-index: 3"
              ></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
