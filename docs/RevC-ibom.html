<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive BOM for KiCAD</title>
    <style type="text/css">
      :root {
        --pcb-edge-color: black;
        --pad-color: #878787;
        --pad-hole-color: #cccccc;
        --pad-color-highlight: #d04040;
        --pad-color-highlight-both: #d0d040;
        --pad-color-highlight-marked: #44a344;
        --pin1-outline-color: #ffb629;
        --pin1-outline-color-highlight: #ffb629;
        --pin1-outline-color-highlight-both: #fcbb39;
        --pin1-outline-color-highlight-marked: #fdbe41;
        --silkscreen-edge-color: #aa4;
        --silkscreen-polygon-color: #4aa;
        --silkscreen-text-color: #4aa;
        --fabrication-edge-color: #907651;
        --fabrication-polygon-color: #907651;
        --fabrication-text-color: #a27c24;
        --track-color: #def5f1;
        --track-color-highlight: #d04040;
        --zone-color: #def5f1;
        --zone-color-highlight: #d0404080;
      }

      html,
      body {
        margin: 0px;
        height: 100%;
        font-family: Verdana, sans-serif;
      }

      .dark.topmostdiv {
        --pcb-edge-color: #eee;
        --pad-color: #808080;
        --pin1-outline-color: #ffa800;
        --pin1-outline-color-highlight: #ccff00;
        --track-color: #42524f;
        --zone-color: #42524f;
        background-color: #252c30;
        color: #eee;
      }

      button {
        background-color: #eee;
        border: 1px solid #888;
        color: black;
        height: 44px;
        width: 44px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 14px;
        font-weight: bolder;
      }

      .dark button {
        /* This will be inverted */
        background-color: #c3b7b5;
      }

      button.depressed {
        background-color: #0a0;
        color: white;
      }

      .dark button.depressed {
        /* This will be inverted */
        background-color: #b3b;
      }

      button:focus {
        outline: 0;
      }

      button#tb-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.32 290.12h5.82M1.32 291.45h5.82' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 292.5v4.23M.26 292.63H8.2' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='1.35' y='295.73'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
      }

      button#lr-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' fill='none' stroke='%23000' stroke-width='.4' stroke-linejoin='round'/%3E%3Cpath d='M1.06 290.12H3.7m-2.64 1.33H3.7m-2.64 1.32H3.7m-2.64 1.3H3.7m-2.64 1.33H3.7' fill='none' stroke='%23000' stroke-width='.4'/%3E%3Cpath d='M4.37 288.8v7.94m0-4.11h3.96' fill='none' stroke='%23000' stroke-width='.3'/%3E%3Ctext font-weight='700' font-size='3.17' font-family='sans-serif'%3E%3Ctspan x='5.11' y='291.96'%3EF%3C/tspan%3E%3Ctspan x='5.03' y='295.68'%3EB%3C/tspan%3E%3C/text%3E%3C/g%3E%3C/svg%3E%0A");
      }

      button#bom-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8.47 8.47'%3E%3Crect transform='translate(0 -288.53)' ry='1.17' y='288.8' x='.27' height='7.94' width='7.94' fill='%23f9f9f9'/%3E%3Cg transform='translate(0 -288.53)' fill='none' stroke='%23000' stroke-width='.4'%3E%3Crect width='7.94' height='7.94' x='.27' y='288.8' ry='1.17' stroke-linejoin='round'/%3E%3Cpath d='M1.59 290.12h5.29M1.59 291.45h5.33M1.59 292.75h5.33M1.59 294.09h5.33M1.59 295.41h5.33'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-grouped-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m4 0h5m4 0h3M6.1 22h3m3.9 0h5m4 0h4m-16-8h4m4 0h4'/%3E%3Cpath stroke-linecap='null' d='M5 17.5h22M5 26.6h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-ungrouped-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg stroke='%23000' stroke-linejoin='round' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-linecap='square' stroke-width='2' d='M6 10h4m-4 8h3m-3 8h4'/%3E%3Cpath stroke-linecap='null' d='M5 13.5h22m-22 8h22M5 5.5h22'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#bom-netlist-btn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cg fill='none' stroke='%23000' class='layer'%3E%3Crect width='29' height='29' x='1.5' y='1.5' stroke-width='2' fill='%23fff' rx='5' ry='5'/%3E%3Cpath stroke-width='2' d='M6 26l6-6v-8m13.8-6.3l-6 6v8'/%3E%3Ccircle cx='11.8' cy='9.5' r='2.8' stroke-width='2'/%3E%3Ccircle cx='19.8' cy='22.8' r='2.8' stroke-width='2'/%3E%3C/g%3E%3C/svg%3E");
      }

      button#copy {
        background-image: url("data:image/svg+xml,%3Csvg height='48' viewBox='0 0 48 48' width='48' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h48v48h-48z' fill='none'/%3E%3Cpath d='M32 2h-24c-2.21 0-4 1.79-4 4v28h4v-28h24v-4zm6 8h-22c-2.21 0-4 1.79-4 4v28c0 2.21 1.79 4 4 4h22c2.21 0 4-1.79 4-4v-28c0-2.21-1.79-4-4-4zm0 32h-22v-28h22v28z'/%3E%3C/svg%3E");
        background-position: 6px 6px;
        background-repeat: no-repeat;
        background-size: 26px 26px;
        border-radius: 6px;
        height: 40px;
        width: 40px;
        margin: 10px 5px;
      }

      button#copy:active {
        box-shadow: inset 0px 0px 5px #6c6c6c;
      }

      textarea.clipboard-temp {
        position: fixed;
        top: 0;
        left: 0;
        width: 2em;
        height: 2em;
        padding: 0;
        border: None;
        outline: None;
        box-shadow: None;
        background: transparent;
      }

      .left-most-button {
        border-right: 0;
        border-top-left-radius: 6px;
        border-bottom-left-radius: 6px;
      }

      .middle-button {
        border-right: 0;
      }

      .right-most-button {
        border-top-right-radius: 6px;
        border-bottom-right-radius: 6px;
      }

      .button-container {
        font-size: 0;
        margin: 10px 10px 10px 0px;
      }

      .dark .button-container {
        filter: invert(1);
      }

      .button-container button {
        background-size: 32px 32px;
        background-position: 5px 5px;
        background-repeat: no-repeat;
      }

      @media print {
        .hideonprint {
          display: none;
        }
      }

      canvas {
        cursor: crosshair;
      }

      canvas:active {
        cursor: grabbing;
      }

      .fileinfo {
        width: 100%;
        max-width: 1000px;
        border: none;
        padding: 5px;
      }

      .fileinfo .title {
        font-size: 20pt;
        font-weight: bold;
      }

      .fileinfo td {
        overflow: hidden;
        white-space: nowrap;
        max-width: 1px;
        width: 50%;
        text-overflow: ellipsis;
      }

      .bom {
        border-collapse: collapse;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 10pt;
        table-layout: fixed;
        width: 100%;
        margin-top: 1px;
        position: relative;
      }

      .bom th,
      .bom td {
        border: 1px solid black;
        padding: 5px;
        word-wrap: break-word;
        text-align: center;
        position: relative;
      }

      .dark .bom th,
      .dark .bom td {
        border: 1px solid #777;
      }

      .bom th {
        background-color: #cccccc;
        background-clip: padding-box;
      }

      .dark .bom th {
        background-color: #3b4749;
      }

      .bom tr.highlighted:nth-child(n) {
        background-color: #cfc;
      }

      .dark .bom tr.highlighted:nth-child(n) {
        background-color: #226022;
      }

      .bom tr:nth-child(even) {
        background-color: #f2f2f2;
      }

      .dark .bom tr:nth-child(even) {
        background-color: #313b40;
      }

      .bom tr.checked {
        color: #1cb53d;
      }

      .dark .bom tr.checked {
        color: #2cce54;
      }

      .bom tr {
        transition: background-color 0.2s;
      }

      .bom .numCol {
        width: 30px;
      }

      .bom .value {
        width: 15%;
      }

      .bom .quantity {
        width: 65px;
      }

      .bom th .sortmark {
        position: absolute;
        right: 1px;
        top: 1px;
        margin-top: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: transparent transparent #221 transparent;
        transform-origin: 50% 85%;
        transition:
          opacity 0.2s,
          transform 0.4s;
      }

      .dark .bom th .sortmark {
        filter: invert(1);
      }

      .bom th .sortmark.none {
        opacity: 0;
      }

      .bom th .sortmark.desc {
        transform: rotate(180deg);
      }

      .bom th:hover .sortmark.none {
        opacity: 0.5;
      }

      .bom .bom-checkbox {
        width: 30px;
        position: relative;
        user-select: none;
        -moz-user-select: none;
      }

      .bom .bom-checkbox:before {
        content: "";
        position: absolute;
        border-width: 15px;
        border-style: solid;
        border-color: #51829f transparent transparent transparent;
        visibility: hidden;
        top: -15px;
      }

      .bom .bom-checkbox:after {
        content: "Double click to set/unset all";
        position: absolute;
        color: white;
        top: -35px;
        left: -26px;
        background: #51829f;
        padding: 5px 15px;
        border-radius: 8px;
        white-space: nowrap;
        visibility: hidden;
      }

      .bom .bom-checkbox:hover:before,
      .bom .bom-checkbox:hover:after {
        visibility: visible;
        transition: visibility 0.2s linear 1s;
      }

      .split {
        -webkit-box-sizing: border-box;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        overflow-y: auto;
        overflow-x: hidden;
        background-color: inherit;
      }

      .split.split-horizontal,
      .gutter.gutter-horizontal {
        height: 100%;
        float: left;
      }

      .gutter {
        background-color: #ddd;
        background-repeat: no-repeat;
        background-position: 50%;
        transition: background-color 0.3s;
      }

      .dark .gutter {
        background-color: #777;
      }

      .gutter.gutter-horizontal {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxAGAgYYmwGrIIiDjrELjpo5aiZeMwF+yNnOs5KSvgAAAABJRU5ErkJggg==");
        cursor: ew-resize;
        width: 5px;
      }

      .gutter.gutter-vertical {
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAFAQMAAABo7865AAAABlBMVEVHcEzMzMzyAv2sAAAAAXRSTlMAQObYZgAAABBJREFUeF5jOAMEEAIEEFwAn3kMwcB6I2AAAAAASUVORK5CYII=");
        cursor: ns-resize;
        height: 5px;
      }

      .searchbox {
        float: left;
        height: 40px;
        margin: 10px 5px;
        padding: 12px 32px;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 18px;
        box-sizing: border-box;
        border: 1px solid #888;
        border-radius: 6px;
        outline: none;
        background-color: #eee;
        transition:
          background-color 0.2s,
          border 0.2s;
        background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABNklEQVQ4T8XSMUvDQBQH8P/LElFa/AIZHcTBQSz0I/gFstTBRR2KUC4ldDxw7h0Bl3RRUATxi4iiODgoiLNrbQYp5J6cpJJqomkX33Z37/14d/dIa33MzDuYI4johOI4XhyNRteO46zNYjDzAxE1yBZprVeZ+QbAUhXEGJMA2Ox2u4+fQIa0mPmsCgCgJYQ4t7lfgF0opQYAdv9ABkKI/UnOFCClXKjX61cA1osQY8x9kiRNKeV7IWA3oyhaSdP0FkAtjxhj3hzH2RBCPOf3pzqYHCilfAAX+URm9oMguPzeWSGQvUcMYC8rOBJCHBRdqxTo9/vbRHRqi8bj8XKv1xvODbiuW2u32/bvf0SlDv4XYOY7z/Mavu+nM1+BmQ+NMc0wDF/LprP0DbTWW0T00ul0nn4b7Q87+X4Qmfiq2wAAAABJRU5ErkJggg==");
        background-position: 10px 10px;
        background-repeat: no-repeat;
      }

      .dark .searchbox {
        background-color: #111;
        color: #eee;
      }

      .searchbox::placeholder {
        color: #ccc;
      }

      .dark .searchbox::placeholder {
        color: #666;
      }

      .filter {
        width: calc(60% - 64px);
      }

      .reflookup {
        width: calc(40% - 10px);
      }

      input[type="text"]:focus {
        background-color: white;
        border: 1px solid #333;
      }

      .dark input[type="text"]:focus {
        background-color: #333;
        border: 1px solid #ccc;
      }

      mark.highlight {
        background-color: #5050ff;
        color: #fff;
        padding: 2px;
        border-radius: 6px;
      }

      .dark mark.highlight {
        background-color: #76a6da;
        color: #111;
      }

      .menubtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 20 20'%3E%3Cpath fill='none' d='M0 0h20v20H0V0z'/%3E%3Cpath d='M15.95 10.78c.03-.25.05-.51.05-.78s-.02-.53-.06-.78l1.69-1.32c.15-.12.19-.34.1-.51l-1.6-2.77c-.1-.18-.31-.24-.49-.18l-1.99.8c-.42-.32-.86-.58-1.35-.78L12 2.34c-.03-.2-.2-.34-.4-.34H8.4c-.2 0-.36.14-.39.34l-.3 2.12c-.49.2-.94.47-1.35.78l-1.99-.8c-.18-.07-.39 0-.49.18l-1.6 2.77c-.1.18-.06.39.1.51l1.69 1.32c-.04.25-.07.52-.07.78s.02.53.06.78L2.37 12.1c-.15.12-.19.34-.1.51l1.6 2.77c.1.18.31.24.49.18l1.99-.8c.42.32.86.58 1.35.78l.3 2.12c.04.2.2.34.4.34h3.2c.2 0 .37-.14.39-.34l.3-2.12c.49-.2.94-.47 1.35-.78l1.99.8c.18.07.39 0 .49-.18l1.6-2.77c.1-.18.06-.39-.1-.51l-1.67-1.32zM10 13c-1.65 0-3-1.35-3-3s1.35-3 3-3 3 1.35 3 3-1.35 3-3 3z'/%3E%3C/svg%3E%0A");
        background-position: center;
        background-repeat: no-repeat;
      }

      .statsbtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg width='36' height='36' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M4 6h28v24H4V6zm0 8h28v8H4m9-16v24h10V5.8' fill='none' stroke='%23000' stroke-width='2'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
      }

      .iobtn {
        background-color: white;
        border: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='36' height='36'%3E%3Cpath fill='none' stroke='%23000' stroke-width='2' d='M3 33v-7l6.8-7h16.5l6.7 7v7H3zM3.2 26H33M21 9l5-5.9 5 6h-2.5V15h-5V9H21zm-4.9 0l-5 6-5-6h2.5V3h5v6h2.5z'/%3E%3Cpath fill='none' stroke='%23000' d='M6.1 29.5H10'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
      }

      .visbtn {
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24'%3E%3Cpath fill='none' stroke='%23333' d='M2.5 4.5h5v15h-5zM9.5 4.5h5v15h-5zM16.5 4.5h5v15h-5z'/%3E%3C/svg%3E");
        background-position: center;
        background-repeat: no-repeat;
        padding: 15px;
      }

      #vismenu-content {
        left: 0px;
        font-family: Verdana, sans-serif;
      }

      .dark .statsbtn,
      .dark .savebtn,
      .dark .menubtn,
      .dark .iobtn,
      .dark .visbtn {
        filter: invert(1);
      }

      .flexbox {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
      }

      .savebtn {
        background-color: #d6d6d6;
        width: auto;
        height: 30px;
        flex-grow: 1;
        margin: 5px;
        border-radius: 4px;
      }

      .savebtn:active {
        background-color: #0a0;
        color: white;
      }

      .dark .savebtn:active {
        /* This will be inverted */
        background-color: #b3b;
      }

      .stats {
        border-collapse: collapse;
        font-size: 12pt;
        table-layout: fixed;
        width: 100%;
        min-width: 450px;
      }

      .dark .stats td {
        border: 1px solid #bbb;
      }

      .stats td {
        border: 1px solid black;
        padding: 5px;
        word-wrap: break-word;
        text-align: center;
        position: relative;
      }

      #checkbox-stats div {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #checkbox-stats .bar {
        background-color: rgba(28, 251, 0, 0.6);
      }

      .menu {
        position: relative;
        display: inline-block;
        margin: 10px 10px 10px 0px;
      }

      .menu-content {
        font-size: 12pt !important;
        text-align: left !important;
        font-weight: normal !important;
        display: none;
        position: absolute;
        background-color: white;
        right: 0;
        min-width: 300px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
        z-index: 100;
        padding: 8px;
      }

      .dark .menu-content {
        background-color: #111;
      }

      .menu:hover .menu-content {
        display: block;
      }

      .menu:hover .menubtn,
      .menu:hover .iobtn,
      .menu:hover .statsbtn {
        background-color: #eee;
      }

      .menu-label {
        display: inline-block;
        padding: 8px;
        border: 1px solid #ccc;
        border-top: 0;
        width: calc(100% - 18px);
      }

      .menu-label-top {
        border-top: 1px solid #ccc;
      }

      .menu-textbox {
        float: left;
        height: 24px;
        margin: 10px 5px;
        padding: 5px 5px;
        font-family: Consolas, "DejaVu Sans Mono", Monaco, monospace;
        font-size: 14px;
        box-sizing: border-box;
        border: 1px solid #888;
        border-radius: 4px;
        outline: none;
        background-color: #eee;
        transition:
          background-color 0.2s,
          border 0.2s;
        width: calc(100% - 10px);
      }

      .menu-textbox.invalid,
      .dark .menu-textbox.invalid {
        color: red;
      }

      .dark .menu-textbox {
        background-color: #222;
        color: #eee;
      }

      .radio-container {
        margin: 4px;
      }

      .topmostdiv {
        width: 100%;
        height: 100%;
        background-color: white;
        transition: background-color 0.3s;
      }

      #top {
        height: 78px;
        border-bottom: 2px solid black;
      }

      .dark #top {
        border-bottom: 2px solid #ccc;
      }

      #dbg {
        display: block;
      }

      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: #aaa;
      }

      ::-webkit-scrollbar-thumb {
        background: #666;
        border-radius: 3px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: #555;
      }

      .slider {
        -webkit-appearance: none;
        width: 100%;
        margin: 3px 0;
        padding: 0;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
        border-radius: 3px;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider:focus {
        outline: none;
      }

      .slider::-webkit-slider-runnable-track {
        -webkit-appearance: none;
        width: 100%;
        height: 8px;
        background: #d3d3d3;
        border-radius: 3px;
        border: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
        margin-top: -4px;
      }

      .dark .slider::-webkit-slider-thumb {
        background: #3d3;
      }

      .slider::-moz-range-thumb {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
      }

      .slider::-moz-range-track {
        height: 8px;
        background: #d3d3d3;
        border-radius: 3px;
      }

      .dark .slider::-moz-range-thumb {
        background: #3d3;
      }

      .slider::-ms-track {
        width: 100%;
        height: 8px;
        border-width: 3px 0;
        background: transparent;
        border-color: transparent;
        color: transparent;
        transition: opacity 0.2s;
      }

      .slider::-ms-fill-lower {
        background: #d3d3d3;
        border: none;
        border-radius: 3px;
      }

      .slider::-ms-fill-upper {
        background: #d3d3d3;
        border: none;
        border-radius: 3px;
      }

      .slider::-ms-thumb {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #0a0;
        cursor: pointer;
        margin: 0;
      }

      .shameless-plug {
        font-size: 0.8em;
        text-align: center;
        display: block;
      }

      a {
        color: #0278a4;
      }

      .dark a {
        color: #00b9fd;
      }

      #frontcanvas,
      #backcanvas {
        touch-action: none;
      }

      .placeholder {
        border: 1px dashed #9f9fda !important;
        background-color: #edf2f7 !important;
      }

      .dragging {
        z-index: 999;
      }

      .dark .dragging > table > tbody > tr {
        background-color: #252c30;
      }

      .dark .placeholder {
        filter: invert(1);
      }

      .column-spacer {
        top: 0;
        left: 0;
        width: calc(100% - 4px);
        position: absolute;
        cursor: pointer;
        user-select: none;
        height: 100%;
      }

      .column-width-handle {
        top: 0;
        right: 0;
        width: 4px;
        position: absolute;
        cursor: col-resize;
        user-select: none;
        height: 100%;
      }

      .column-width-handle:hover {
        background-color: #4f99bd;
      }

      .help-link {
        border: 1px solid #0278a4;
        padding-inline: 0.3rem;
        border-radius: 3px;
        cursor: pointer;
      }

      .dark .help-link {
        border: 1px solid #00b9fd;
      }
    </style>
    <script type="text/javascript">
      ///////////////////////////////////////////////
      /*
  Split.js - v1.3.5
  MIT License
  https://github.com/nathancahill/Split.js
*/
      !(function (e, t) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = t())
          : "function" == typeof define && define.amd
            ? define(t)
            : (e.Split = t());
      })(this, function () {
        "use strict";
        var e = window,
          t = e.document,
          n = "addEventListener",
          i = "removeEventListener",
          r = "getBoundingClientRect",
          s = function () {
            return !1;
          },
          o = e.attachEvent && !e[n],
          a =
            ["", "-webkit-", "-moz-", "-o-"]
              .filter(function (e) {
                var n = t.createElement("div");
                return (
                  (n.style.cssText = "width:" + e + "calc(9px)"),
                  !!n.style.length
                );
              })
              .shift() + "calc",
          l = function (e) {
            return "string" == typeof e || e instanceof String
              ? t.querySelector(e)
              : e;
          };
        return function (u, c) {
          function z(e, t, n) {
            var i = A(y, t, n);
            Object.keys(i).forEach(function (t) {
              return (e.style[t] = i[t]);
            });
          }
          function h(e, t) {
            var n = B(y, t);
            Object.keys(n).forEach(function (t) {
              return (e.style[t] = n[t]);
            });
          }
          function f(e) {
            var t = E[this.a],
              n = E[this.b],
              i = t.size + n.size;
            ((t.size = (e / this.size) * i),
              (n.size = i - (e / this.size) * i),
              z(t.element, t.size, this.aGutterSize),
              z(n.element, n.size, this.bGutterSize));
          }
          function m(e) {
            var t;
            this.dragging &&
              ((t =
                "touches" in e
                  ? e.touches[0][b] - this.start
                  : e[b] - this.start) <=
              E[this.a].minSize + M + this.aGutterSize
                ? (t = E[this.a].minSize + this.aGutterSize)
                : t >= this.size - (E[this.b].minSize + M + this.bGutterSize) &&
                  (t = this.size - (E[this.b].minSize + this.bGutterSize)),
              f.call(this, t),
              c.onDrag && c.onDrag());
          }
          function g() {
            var e = E[this.a].element,
              t = E[this.b].element;
            ((this.size =
              e[r]()[y] + t[r]()[y] + this.aGutterSize + this.bGutterSize),
              (this.start = e[r]()[G]));
          }
          function d() {
            var t = this,
              n = E[t.a].element,
              r = E[t.b].element;
            (t.dragging && c.onDragEnd && c.onDragEnd(),
              (t.dragging = !1),
              e[i]("mouseup", t.stop),
              e[i]("touchend", t.stop),
              e[i]("touchcancel", t.stop),
              t.parent[i]("mousemove", t.move),
              t.parent[i]("touchmove", t.move),
              delete t.stop,
              delete t.move,
              n[i]("selectstart", s),
              n[i]("dragstart", s),
              r[i]("selectstart", s),
              r[i]("dragstart", s),
              (n.style.userSelect = ""),
              (n.style.webkitUserSelect = ""),
              (n.style.MozUserSelect = ""),
              (n.style.pointerEvents = ""),
              (r.style.userSelect = ""),
              (r.style.webkitUserSelect = ""),
              (r.style.MozUserSelect = ""),
              (r.style.pointerEvents = ""),
              (t.gutter.style.cursor = ""),
              (t.parent.style.cursor = ""));
          }
          function S(t) {
            var i = this,
              r = E[i.a].element,
              o = E[i.b].element;
            (!i.dragging && c.onDragStart && c.onDragStart(),
              t.preventDefault(),
              (i.dragging = !0),
              (i.move = m.bind(i)),
              (i.stop = d.bind(i)),
              e[n]("mouseup", i.stop),
              e[n]("touchend", i.stop),
              e[n]("touchcancel", i.stop),
              i.parent[n]("mousemove", i.move),
              i.parent[n]("touchmove", i.move),
              r[n]("selectstart", s),
              r[n]("dragstart", s),
              o[n]("selectstart", s),
              o[n]("dragstart", s),
              (r.style.userSelect = "none"),
              (r.style.webkitUserSelect = "none"),
              (r.style.MozUserSelect = "none"),
              (r.style.pointerEvents = "none"),
              (o.style.userSelect = "none"),
              (o.style.webkitUserSelect = "none"),
              (o.style.MozUserSelect = "none"),
              (o.style.pointerEvents = "none"),
              (i.gutter.style.cursor = j),
              (i.parent.style.cursor = j),
              g.call(i));
          }
          function v(e) {
            e.forEach(function (t, n) {
              if (n > 0) {
                var i = F[n - 1],
                  r = E[i.a],
                  s = E[i.b];
                ((r.size = e[n - 1]),
                  (s.size = t),
                  z(r.element, r.size, i.aGutterSize),
                  z(s.element, s.size, i.bGutterSize));
              }
            });
          }
          function p() {
            F.forEach(function (e) {
              (e.parent.removeChild(e.gutter),
                (E[e.a].element.style[y] = ""),
                (E[e.b].element.style[y] = ""));
            });
          }
          void 0 === c && (c = {});
          var y,
            b,
            G,
            E,
            w = l(u[0]).parentNode,
            D = e.getComputedStyle(w).flexDirection,
            U =
              c.sizes ||
              u.map(function () {
                return 100 / u.length;
              }),
            k = void 0 !== c.minSize ? c.minSize : 100,
            x = Array.isArray(k)
              ? k
              : u.map(function () {
                  return k;
                }),
            L = void 0 !== c.gutterSize ? c.gutterSize : 10,
            M = void 0 !== c.snapOffset ? c.snapOffset : 30,
            O = c.direction || "horizontal",
            j = c.cursor || ("horizontal" === O ? "ew-resize" : "ns-resize"),
            C =
              c.gutter ||
              function (e, n) {
                var i = t.createElement("div");
                return ((i.className = "gutter gutter-" + n), i);
              },
            A =
              c.elementStyle ||
              function (e, t, n) {
                var i = {};
                return (
                  "string" == typeof t || t instanceof String
                    ? (i[e] = t)
                    : (i[e] = o ? t + "%" : a + "(" + t + "% - " + n + "px)"),
                  i
                );
              },
            B =
              c.gutterStyle ||
              function (e, t) {
                return ((n = {}), (n[e] = t + "px"), n);
                var n;
              };
          "horizontal" === O
            ? ((y = "width"),
              "clientWidth",
              (b = "clientX"),
              (G = "left"),
              "paddingLeft")
            : "vertical" === O &&
              ((y = "height"),
              "clientHeight",
              (b = "clientY"),
              (G = "top"),
              "paddingTop");
          var F = [];
          return (
            (E = u.map(function (e, t) {
              var i,
                s = { element: l(e), size: U[t], minSize: x[t] };
              if (
                t > 0 &&
                ((i = {
                  a: t - 1,
                  b: t,
                  dragging: !1,
                  isFirst: 1 === t,
                  isLast: t === u.length - 1,
                  direction: O,
                  parent: w,
                }),
                (i.aGutterSize = L),
                (i.bGutterSize = L),
                i.isFirst && (i.aGutterSize = L / 2),
                i.isLast && (i.bGutterSize = L / 2),
                "row-reverse" === D || "column-reverse" === D)
              ) {
                var a = i.a;
                ((i.a = i.b), (i.b = a));
              }
              if (!o && t > 0) {
                var c = C(t, O);
                (h(c, L),
                  c[n]("mousedown", S.bind(i)),
                  c[n]("touchstart", S.bind(i)),
                  w.insertBefore(c, s.element),
                  (i.gutter = c));
              }
              0 === t || t === u.length - 1
                ? z(s.element, s.size, L / 2)
                : z(s.element, s.size, L);
              var f = s.element[r]()[y];
              return (f < s.minSize && (s.minSize = f), t > 0 && F.push(i), s);
            })),
            o
              ? { setSizes: v, destroy: p }
              : {
                  setSizes: v,
                  getSizes: function () {
                    return E.map(function (e) {
                      return e.size;
                    });
                  },
                  collapse: function (e) {
                    if (e === F.length) {
                      var t = F[e - 1];
                      (g.call(t), o || f.call(t, t.size - t.bGutterSize));
                    } else {
                      var n = F[e];
                      (g.call(n), o || f.call(n, n.aGutterSize));
                    }
                  },
                  destroy: p,
                }
          );
        };
      });

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
      // This work is free. You can redistribute it and/or modify it
      // under the terms of the WTFPL, Version 2
      // For more information see LICENSE.txt or http://www.wtfpl.net/
      //
      // For more information, the home page:
      // http://pieroxy.net/blog/pages/lz-string/testing.html
      //
      // LZ-based compression algorithm, version 1.4.4
      var LZString = (function () {
        var o = String.fromCharCode,
          i = {};
        var n = {
          decompressFromBase64: function (o) {
            return null == o
              ? ""
              : "" == o
                ? null
                : n._decompress(o.length, 32, function (n) {
                    return (function (o, n) {
                      if (!i[o]) {
                        i[o] = {};
                        for (var t = 0; t < o.length; t++)
                          i[o][o.charAt(t)] = t;
                      }
                      return i[o][n];
                    })(
                      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                      o.charAt(n),
                    );
                  });
          },
          _decompress: function (i, n, t) {
            var r,
              e,
              a,
              s,
              p,
              u,
              l,
              f = [],
              c = 4,
              d = 4,
              h = 3,
              v = "",
              g = [],
              m = { val: t(0), position: n, index: 1 };
            for (r = 0; r < 3; r += 1) f[r] = r;
            for (a = 0, p = Math.pow(2, 2), u = 1; u != p; )
              ((s = m.val & m.position),
                (m.position >>= 1),
                0 == m.position && ((m.position = n), (m.val = t(m.index++))),
                (a |= (s > 0 ? 1 : 0) * u),
                (u <<= 1));
            switch (a) {
              case 0:
                for (a = 0, p = Math.pow(2, 8), u = 1; u != p; )
                  ((s = m.val & m.position),
                    (m.position >>= 1),
                    0 == m.position &&
                      ((m.position = n), (m.val = t(m.index++))),
                    (a |= (s > 0 ? 1 : 0) * u),
                    (u <<= 1));
                l = o(a);
                break;
              case 1:
                for (a = 0, p = Math.pow(2, 16), u = 1; u != p; )
                  ((s = m.val & m.position),
                    (m.position >>= 1),
                    0 == m.position &&
                      ((m.position = n), (m.val = t(m.index++))),
                    (a |= (s > 0 ? 1 : 0) * u),
                    (u <<= 1));
                l = o(a);
                break;
              case 2:
                return "";
            }
            for (f[3] = l, e = l, g.push(l); ; ) {
              if (m.index > i) return "";
              for (a = 0, p = Math.pow(2, h), u = 1; u != p; )
                ((s = m.val & m.position),
                  (m.position >>= 1),
                  0 == m.position && ((m.position = n), (m.val = t(m.index++))),
                  (a |= (s > 0 ? 1 : 0) * u),
                  (u <<= 1));
              switch ((l = a)) {
                case 0:
                  for (a = 0, p = Math.pow(2, 8), u = 1; u != p; )
                    ((s = m.val & m.position),
                      (m.position >>= 1),
                      0 == m.position &&
                        ((m.position = n), (m.val = t(m.index++))),
                      (a |= (s > 0 ? 1 : 0) * u),
                      (u <<= 1));
                  ((f[d++] = o(a)), (l = d - 1), c--);
                  break;
                case 1:
                  for (a = 0, p = Math.pow(2, 16), u = 1; u != p; )
                    ((s = m.val & m.position),
                      (m.position >>= 1),
                      0 == m.position &&
                        ((m.position = n), (m.val = t(m.index++))),
                      (a |= (s > 0 ? 1 : 0) * u),
                      (u <<= 1));
                  ((f[d++] = o(a)), (l = d - 1), c--);
                  break;
                case 2:
                  return g.join("");
              }
              if ((0 == c && ((c = Math.pow(2, h)), h++), f[l])) v = f[l];
              else {
                if (l !== d) return null;
                v = e + e.charAt(0);
              }
              (g.push(v),
                (f[d++] = e + v.charAt(0)),
                (e = v),
                0 == --c && ((c = Math.pow(2, h)), h++));
            }
          },
        };
        return n;
      })();
      "function" == typeof define && define.amd
        ? define(function () {
            return LZString;
          })
        : "undefined" != typeof module && null != module
          ? (module.exports = LZString)
          : "undefined" != typeof angular &&
            null != angular &&
            angular.module("LZString", []).factory("LZString", function () {
              return LZString;
            });
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /*!
       * PEP v0.4.3 | https://github.com/jquery/PEP
       * Copyright jQuery Foundation and other contributors | http://jquery.org/license
       */
      !(function (a, b) {
        "object" == typeof exports && "undefined" != typeof module
          ? (module.exports = b())
          : "function" == typeof define && define.amd
            ? define(b)
            : (a.PointerEventsPolyfill = b());
      })(this, function () {
        "use strict";
        function a(a, b) {
          b = b || Object.create(null);
          var c = document.createEvent("Event");
          c.initEvent(a, b.bubbles || !1, b.cancelable || !1);
          for (var d, e = 2; e < m.length; e++)
            ((d = m[e]), (c[d] = b[d] || n[e]));
          c.buttons = b.buttons || 0;
          var f = 0;
          return (
            (f = b.pressure && c.buttons ? b.pressure : c.buttons ? 0.5 : 0),
            (c.x = c.clientX),
            (c.y = c.clientY),
            (c.pointerId = b.pointerId || 0),
            (c.width = b.width || 0),
            (c.height = b.height || 0),
            (c.pressure = f),
            (c.tiltX = b.tiltX || 0),
            (c.tiltY = b.tiltY || 0),
            (c.twist = b.twist || 0),
            (c.tangentialPressure = b.tangentialPressure || 0),
            (c.pointerType = b.pointerType || ""),
            (c.hwTimestamp = b.hwTimestamp || 0),
            (c.isPrimary = b.isPrimary || !1),
            c
          );
        }
        function b() {
          ((this.array = []), (this.size = 0));
        }
        function c(a, b, c, d) {
          ((this.addCallback = a.bind(d)),
            (this.removeCallback = b.bind(d)),
            (this.changedCallback = c.bind(d)),
            A && (this.observer = new A(this.mutationWatcher.bind(this))));
        }
        function d(a) {
          return "body /shadow-deep/ " + e(a);
        }
        function e(a) {
          return '[touch-action="' + a + '"]';
        }
        function f(a) {
          return "{ -ms-touch-action: " + a + "; touch-action: " + a + "; }";
        }
        function g() {
          if (F) {
            D.forEach(function (a) {
              String(a) === a
                ? ((E += e(a) + f(a) + "\n"), G && (E += d(a) + f(a) + "\n"))
                : ((E += a.selectors.map(e) + f(a.rule) + "\n"),
                  G && (E += a.selectors.map(d) + f(a.rule) + "\n"));
            });
            var a = document.createElement("style");
            ((a.textContent = E), document.head.appendChild(a));
          }
        }
        function h() {
          if (!window.PointerEvent) {
            if (
              ((window.PointerEvent = a), window.navigator.msPointerEnabled)
            ) {
              var b = window.navigator.msMaxTouchPoints;
              (Object.defineProperty(window.navigator, "maxTouchPoints", {
                value: b,
                enumerable: !0,
              }),
                u.registerSource("ms", _));
            } else
              (Object.defineProperty(window.navigator, "maxTouchPoints", {
                value: 0,
                enumerable: !0,
              }),
                u.registerSource("mouse", N),
                void 0 !== window.ontouchstart && u.registerSource("touch", V));
            u.register(document);
          }
        }
        function i(a) {
          if (!u.pointermap.has(a)) {
            var b = new Error("InvalidPointerId");
            throw ((b.name = "InvalidPointerId"), b);
          }
        }
        function j(a) {
          for (var b = a.parentNode; b && b !== a.ownerDocument; )
            b = b.parentNode;
          if (!b) {
            var c = new Error("InvalidStateError");
            throw ((c.name = "InvalidStateError"), c);
          }
        }
        function k(a) {
          var b = u.pointermap.get(a);
          return 0 !== b.buttons;
        }
        function l() {
          window.Element &&
            !Element.prototype.setPointerCapture &&
            Object.defineProperties(Element.prototype, {
              setPointerCapture: { value: W },
              releasePointerCapture: { value: X },
              hasPointerCapture: { value: Y },
            });
        }
        var m = [
            "bubbles",
            "cancelable",
            "view",
            "detail",
            "screenX",
            "screenY",
            "clientX",
            "clientY",
            "ctrlKey",
            "altKey",
            "shiftKey",
            "metaKey",
            "button",
            "relatedTarget",
            "pageX",
            "pageY",
          ],
          n = [!1, !1, null, null, 0, 0, 0, 0, !1, !1, !1, !1, 0, null, 0, 0],
          o = window.Map && window.Map.prototype.forEach,
          p = o ? Map : b;
        b.prototype = {
          set: function (a, b) {
            return void 0 === b
              ? this["delete"](a)
              : (this.has(a) || this.size++, void (this.array[a] = b));
          },
          has: function (a) {
            return void 0 !== this.array[a];
          },
          delete: function (a) {
            this.has(a) && (delete this.array[a], this.size--);
          },
          get: function (a) {
            return this.array[a];
          },
          clear: function () {
            ((this.array.length = 0), (this.size = 0));
          },
          forEach: function (a, b) {
            return this.array.forEach(function (c, d) {
              a.call(b, c, d, this);
            }, this);
          },
        };
        var q = [
            "bubbles",
            "cancelable",
            "view",
            "detail",
            "screenX",
            "screenY",
            "clientX",
            "clientY",
            "ctrlKey",
            "altKey",
            "shiftKey",
            "metaKey",
            "button",
            "relatedTarget",
            "buttons",
            "pointerId",
            "width",
            "height",
            "pressure",
            "tiltX",
            "tiltY",
            "pointerType",
            "hwTimestamp",
            "isPrimary",
            "type",
            "target",
            "currentTarget",
            "which",
            "pageX",
            "pageY",
            "timeStamp",
          ],
          r = [
            !1,
            !1,
            null,
            null,
            0,
            0,
            0,
            0,
            !1,
            !1,
            !1,
            !1,
            0,
            null,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            "",
            0,
            !1,
            "",
            null,
            null,
            0,
            0,
            0,
            0,
          ],
          s = {
            pointerover: 1,
            pointerout: 1,
            pointerenter: 1,
            pointerleave: 1,
          },
          t = "undefined" != typeof SVGElementInstance,
          u = {
            pointermap: new p(),
            eventMap: Object.create(null),
            captureInfo: Object.create(null),
            eventSources: Object.create(null),
            eventSourceList: [],
            registerSource: function (a, b) {
              var c = b,
                d = c.events;
              d &&
                (d.forEach(function (a) {
                  c[a] && (this.eventMap[a] = c[a].bind(c));
                }, this),
                (this.eventSources[a] = c),
                this.eventSourceList.push(c));
            },
            register: function (a) {
              for (
                var b, c = this.eventSourceList.length, d = 0;
                d < c && (b = this.eventSourceList[d]);
                d++
              )
                b.register.call(b, a);
            },
            unregister: function (a) {
              for (
                var b, c = this.eventSourceList.length, d = 0;
                d < c && (b = this.eventSourceList[d]);
                d++
              )
                b.unregister.call(b, a);
            },
            contains: function (a, b) {
              try {
                return a.contains(b);
              } catch (c) {
                return !1;
              }
            },
            down: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerdown", a));
            },
            move: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointermove", a));
            },
            up: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerup", a));
            },
            enter: function (a) {
              ((a.bubbles = !1), this.fireEvent("pointerenter", a));
            },
            leave: function (a) {
              ((a.bubbles = !1), this.fireEvent("pointerleave", a));
            },
            over: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerover", a));
            },
            out: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointerout", a));
            },
            cancel: function (a) {
              ((a.bubbles = !0), this.fireEvent("pointercancel", a));
            },
            leaveOut: function (a) {
              (this.out(a), this.propagate(a, this.leave, !1));
            },
            enterOver: function (a) {
              (this.over(a), this.propagate(a, this.enter, !0));
            },
            eventHandler: function (a) {
              if (!a._handledByPE) {
                var b = a.type,
                  c = this.eventMap && this.eventMap[b];
                (c && c(a), (a._handledByPE = !0));
              }
            },
            listen: function (a, b) {
              b.forEach(function (b) {
                this.addEvent(a, b);
              }, this);
            },
            unlisten: function (a, b) {
              b.forEach(function (b) {
                this.removeEvent(a, b);
              }, this);
            },
            addEvent: function (a, b) {
              a.addEventListener(b, this.boundHandler);
            },
            removeEvent: function (a, b) {
              a.removeEventListener(b, this.boundHandler);
            },
            makeEvent: function (b, c) {
              this.captureInfo[c.pointerId] && (c.relatedTarget = null);
              var d = new a(b, c);
              return (
                c.preventDefault && (d.preventDefault = c.preventDefault),
                (d._target = d._target || c.target),
                d
              );
            },
            fireEvent: function (a, b) {
              var c = this.makeEvent(a, b);
              return this.dispatchEvent(c);
            },
            cloneEvent: function (a) {
              for (var b, c = Object.create(null), d = 0; d < q.length; d++)
                ((b = q[d]),
                  (c[b] = a[b] || r[d]),
                  !t ||
                    ("target" !== b && "relatedTarget" !== b) ||
                    (c[b] instanceof SVGElementInstance &&
                      (c[b] = c[b].correspondingUseElement)));
              return (
                a.preventDefault &&
                  (c.preventDefault = function () {
                    a.preventDefault();
                  }),
                c
              );
            },
            getTarget: function (a) {
              var b = this.captureInfo[a.pointerId];
              return b
                ? a._target !== b && a.type in s
                  ? void 0
                  : b
                : a._target;
            },
            propagate: function (a, b, c) {
              for (
                var d = a.target, e = [];
                d !== document && !d.contains(a.relatedTarget);

              )
                if ((e.push(d), (d = d.parentNode), !d)) return;
              (c && e.reverse(),
                e.forEach(function (c) {
                  ((a.target = c), b.call(this, a));
                }, this));
            },
            setCapture: function (b, c, d) {
              (this.captureInfo[b] && this.releaseCapture(b, d),
                (this.captureInfo[b] = c),
                (this.implicitRelease = this.releaseCapture.bind(this, b, d)),
                document.addEventListener("pointerup", this.implicitRelease),
                document.addEventListener(
                  "pointercancel",
                  this.implicitRelease,
                ));
              var e = new a("gotpointercapture");
              ((e.pointerId = b),
                (e._target = c),
                d || this.asyncDispatchEvent(e));
            },
            releaseCapture: function (b, c) {
              var d = this.captureInfo[b];
              if (d) {
                ((this.captureInfo[b] = void 0),
                  document.removeEventListener(
                    "pointerup",
                    this.implicitRelease,
                  ),
                  document.removeEventListener(
                    "pointercancel",
                    this.implicitRelease,
                  ));
                var e = new a("lostpointercapture");
                ((e.pointerId = b),
                  (e._target = d),
                  c || this.asyncDispatchEvent(e));
              }
            },
            dispatchEvent: /*scope.external.dispatchEvent || */ function (a) {
              var b = this.getTarget(a);
              if (b) return b.dispatchEvent(a);
            },
            asyncDispatchEvent: function (a) {
              requestAnimationFrame(this.dispatchEvent.bind(this, a));
            },
          };
        u.boundHandler = u.eventHandler.bind(u);
        var v = {
            shadow: function (a) {
              if (a) return a.shadowRoot || a.webkitShadowRoot;
            },
            canTarget: function (a) {
              return a && Boolean(a.elementFromPoint);
            },
            targetingShadow: function (a) {
              var b = this.shadow(a);
              if (this.canTarget(b)) return b;
            },
            olderShadow: function (a) {
              var b = a.olderShadowRoot;
              if (!b) {
                var c = a.querySelector("shadow");
                c && (b = c.olderShadowRoot);
              }
              return b;
            },
            allShadows: function (a) {
              for (var b = [], c = this.shadow(a); c; )
                (b.push(c), (c = this.olderShadow(c)));
              return b;
            },
            searchRoot: function (a, b, c) {
              if (a) {
                var d,
                  e,
                  f = a.elementFromPoint(b, c);
                for (e = this.targetingShadow(f); e; ) {
                  if ((d = e.elementFromPoint(b, c))) {
                    var g = this.targetingShadow(d);
                    return this.searchRoot(g, b, c) || d;
                  }
                  e = this.olderShadow(e);
                }
                return f;
              }
            },
            owner: function (a) {
              for (var b = a; b.parentNode; ) b = b.parentNode;
              return (
                b.nodeType !== Node.DOCUMENT_NODE &&
                  b.nodeType !== Node.DOCUMENT_FRAGMENT_NODE &&
                  (b = document),
                b
              );
            },
            findTarget: function (a) {
              var b = a.clientX,
                c = a.clientY,
                d = this.owner(a.target);
              return (
                d.elementFromPoint(b, c) || (d = document),
                this.searchRoot(d, b, c)
              );
            },
          },
          w = Array.prototype.forEach.call.bind(Array.prototype.forEach),
          x = Array.prototype.map.call.bind(Array.prototype.map),
          y = Array.prototype.slice.call.bind(Array.prototype.slice),
          z = Array.prototype.filter.call.bind(Array.prototype.filter),
          A = window.MutationObserver || window.WebKitMutationObserver,
          B = "[touch-action]",
          C = {
            subtree: !0,
            childList: !0,
            attributes: !0,
            attributeOldValue: !0,
            attributeFilter: ["touch-action"],
          };
        c.prototype = {
          watchSubtree: function (a) {
            //
            this.observer && v.canTarget(a) && this.observer.observe(a, C);
          },
          enableOnSubtree: function (a) {
            (this.watchSubtree(a),
              a === document && "complete" !== document.readyState
                ? this.installOnLoad()
                : this.installNewSubtree(a));
          },
          installNewSubtree: function (a) {
            w(this.findElements(a), this.addElement, this);
          },
          findElements: function (a) {
            return a.querySelectorAll ? a.querySelectorAll(B) : [];
          },
          removeElement: function (a) {
            this.removeCallback(a);
          },
          addElement: function (a) {
            this.addCallback(a);
          },
          elementChanged: function (a, b) {
            this.changedCallback(a, b);
          },
          concatLists: function (a, b) {
            return a.concat(y(b));
          },
          installOnLoad: function () {
            document.addEventListener(
              "readystatechange",
              function () {
                "complete" === document.readyState &&
                  this.installNewSubtree(document);
              }.bind(this),
            );
          },
          isElement: function (a) {
            return a.nodeType === Node.ELEMENT_NODE;
          },
          flattenMutationTree: function (a) {
            var b = x(a, this.findElements, this);
            return (
              b.push(z(a, this.isElement)),
              b.reduce(this.concatLists, [])
            );
          },
          mutationWatcher: function (a) {
            a.forEach(this.mutationHandler, this);
          },
          mutationHandler: function (a) {
            if ("childList" === a.type) {
              var b = this.flattenMutationTree(a.addedNodes);
              b.forEach(this.addElement, this);
              var c = this.flattenMutationTree(a.removedNodes);
              c.forEach(this.removeElement, this);
            } else
              "attributes" === a.type &&
                this.elementChanged(a.target, a.oldValue);
          },
        };
        var D = [
            "none",
            "auto",
            "pan-x",
            "pan-y",
            { rule: "pan-x pan-y", selectors: ["pan-x pan-y", "pan-y pan-x"] },
          ],
          E = "",
          F = window.PointerEvent || window.MSPointerEvent,
          G = !window.ShadowDOMPolyfill && document.head.createShadowRoot,
          H = u.pointermap,
          I = 25,
          J = [1, 4, 2, 8, 16],
          K = !1;
        try {
          K = 1 === new MouseEvent("test", { buttons: 1 }).buttons;
        } catch (L) {}
        var M,
          N = {
            POINTER_ID: 1,
            POINTER_TYPE: "mouse",
            events: [
              "mousedown",
              "mousemove",
              "mouseup",
              "mouseover",
              "mouseout",
            ],
            register: function (a) {
              u.listen(a, this.events);
            },
            unregister: function (a) {
              u.unlisten(a, this.events);
            },
            lastTouches: [],
            isEventSimulatedFromTouch: function (a) {
              for (
                var b,
                  c = this.lastTouches,
                  d = a.clientX,
                  e = a.clientY,
                  f = 0,
                  g = c.length;
                f < g && (b = c[f]);
                f++
              ) {
                var h = Math.abs(d - b.x),
                  i = Math.abs(e - b.y);
                if (h <= I && i <= I) return !0;
              }
            },
            prepareEvent: function (a) {
              var b = u.cloneEvent(a),
                c = b.preventDefault;
              return (
                (b.preventDefault = function () {
                  (a.preventDefault(), c());
                }),
                (b.pointerId = this.POINTER_ID),
                (b.isPrimary = !0),
                (b.pointerType = this.POINTER_TYPE),
                b
              );
            },
            prepareButtonsForMove: function (a, b) {
              var c = H.get(this.POINTER_ID);
              (0 !== b.which && c ? (a.buttons = c.buttons) : (a.buttons = 0),
                (b.buttons = a.buttons));
            },
            mousedown: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = H.get(this.POINTER_ID),
                  c = this.prepareEvent(a);
                (K ||
                  ((c.buttons = J[c.button]),
                  b && (c.buttons |= b.buttons),
                  (a.buttons = c.buttons)),
                  H.set(this.POINTER_ID, a),
                  b && 0 !== b.buttons ? u.move(c) : u.down(c));
              }
            },
            mousemove: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  H.set(this.POINTER_ID, a),
                  u.move(b));
              }
            },
            mouseup: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = H.get(this.POINTER_ID),
                  c = this.prepareEvent(a);
                if (!K) {
                  var d = J[c.button];
                  ((c.buttons = b ? b.buttons & ~d : 0),
                    (a.buttons = c.buttons));
                }
                (H.set(this.POINTER_ID, a),
                  (c.buttons &= ~J[c.button]),
                  0 === c.buttons ? u.up(c) : u.move(c));
              }
            },
            mouseover: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  H.set(this.POINTER_ID, a),
                  u.enterOver(b));
              }
            },
            mouseout: function (a) {
              if (!this.isEventSimulatedFromTouch(a)) {
                var b = this.prepareEvent(a);
                (K || this.prepareButtonsForMove(b, a),
                  (b.button = -1),
                  u.leaveOut(b));
              }
            },
            cancel: function (a) {
              var b = this.prepareEvent(a);
              (u.cancel(b), this.deactivateMouse());
            },
            deactivateMouse: function () {
              H["delete"](this.POINTER_ID);
            },
          },
          O = u.captureInfo,
          P = v.findTarget.bind(v),
          Q = v.allShadows.bind(v),
          R = u.pointermap,
          S = 2500,
          T = 200,
          U = "touch-action",
          V = {
            events: ["touchstart", "touchmove", "touchend", "touchcancel"],
            register: function (a) {
              M.enableOnSubtree(a);
            },
            unregister: function () {},
            elementAdded: function (a) {
              var b = a.getAttribute(U),
                c = this.touchActionToScrollType(b);
              c &&
                ((a._scrollType = c),
                u.listen(a, this.events),
                Q(a).forEach(function (a) {
                  ((a._scrollType = c), u.listen(a, this.events));
                }, this));
            },
            elementRemoved: function (a) {
              ((a._scrollType = void 0),
                u.unlisten(a, this.events),
                Q(a).forEach(function (a) {
                  ((a._scrollType = void 0), u.unlisten(a, this.events));
                }, this));
            },
            elementChanged: function (a, b) {
              var c = a.getAttribute(U),
                d = this.touchActionToScrollType(c),
                e = this.touchActionToScrollType(b);
              d && e
                ? ((a._scrollType = d),
                  Q(a).forEach(function (a) {
                    a._scrollType = d;
                  }, this))
                : e
                  ? this.elementRemoved(a)
                  : d && this.elementAdded(a);
            },
            scrollTypes: {
              EMITTER: "none",
              XSCROLLER: "pan-x",
              YSCROLLER: "pan-y",
              SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/,
            },
            touchActionToScrollType: function (a) {
              var b = a,
                c = this.scrollTypes;
              return "none" === b
                ? "none"
                : b === c.XSCROLLER
                  ? "X"
                  : b === c.YSCROLLER
                    ? "Y"
                    : c.SCROLLER.exec(b)
                      ? "XY"
                      : void 0;
            },
            POINTER_TYPE: "touch",
            firstTouch: null,
            isPrimaryTouch: function (a) {
              return this.firstTouch === a.identifier;
            },
            setPrimaryTouch: function (a) {
              (0 === R.size || (1 === R.size && R.has(1))) &&
                ((this.firstTouch = a.identifier),
                (this.firstXY = { X: a.clientX, Y: a.clientY }),
                (this.scrolling = !1),
                this.cancelResetClickCount());
            },
            removePrimaryPointer: function (a) {
              a.isPrimary &&
                ((this.firstTouch = null),
                (this.firstXY = null),
                this.resetClickCount());
            },
            clickCount: 0,
            resetId: null,
            resetClickCount: function () {
              var a = function () {
                ((this.clickCount = 0), (this.resetId = null));
              }.bind(this);
              this.resetId = setTimeout(a, T);
            },
            cancelResetClickCount: function () {
              this.resetId && clearTimeout(this.resetId);
            },
            typeToButtons: function (a) {
              var b = 0;
              return (("touchstart" !== a && "touchmove" !== a) || (b = 1), b);
            },
            touchToPointer: function (a) {
              var b = this.currentTouchEvent,
                c = u.cloneEvent(a),
                d = (c.pointerId = a.identifier + 2);
              ((c.target = O[d] || P(c)),
                (c.bubbles = !0),
                (c.cancelable = !0),
                (c.detail = this.clickCount),
                (c.button = 0),
                (c.buttons = this.typeToButtons(b.type)),
                (c.width = 2 * (a.radiusX || a.webkitRadiusX || 0)),
                (c.height = 2 * (a.radiusY || a.webkitRadiusY || 0)),
                (c.pressure = a.force || a.webkitForce || 0.5),
                (c.isPrimary = this.isPrimaryTouch(a)),
                (c.pointerType = this.POINTER_TYPE),
                (c.altKey = b.altKey),
                (c.ctrlKey = b.ctrlKey),
                (c.metaKey = b.metaKey),
                (c.shiftKey = b.shiftKey));
              var e = this;
              return (
                (c.preventDefault = function () {
                  ((e.scrolling = !1), (e.firstXY = null), b.preventDefault());
                }),
                c
              );
            },
            processTouches: function (a, b) {
              var c = a.changedTouches;
              this.currentTouchEvent = a;
              for (var d, e = 0; e < c.length; e++)
                ((d = c[e]), b.call(this, this.touchToPointer(d)));
            },
            shouldScroll: function (a) {
              if (this.firstXY) {
                var b,
                  c = a.currentTarget._scrollType;
                if ("none" === c) b = !1;
                else if ("XY" === c) b = !0;
                else {
                  var d = a.changedTouches[0],
                    e = c,
                    f = "Y" === c ? "X" : "Y",
                    g = Math.abs(d["client" + e] - this.firstXY[e]),
                    h = Math.abs(d["client" + f] - this.firstXY[f]);
                  b = g >= h;
                }
                return ((this.firstXY = null), b);
              }
            },
            findTouch: function (a, b) {
              for (var c, d = 0, e = a.length; d < e && (c = a[d]); d++)
                if (c.identifier === b) return !0;
            },
            vacuumTouches: function (a) {
              var b = a.touches;
              if (R.size >= b.length) {
                var c = [];
                (R.forEach(function (a, d) {
                  if (1 !== d && !this.findTouch(b, d - 2)) {
                    var e = a.out;
                    c.push(e);
                  }
                }, this),
                  c.forEach(this.cancelOut, this));
              }
            },
            touchstart: function (a) {
              (this.vacuumTouches(a),
                this.setPrimaryTouch(a.changedTouches[0]),
                this.dedupSynthMouse(a),
                this.scrolling ||
                  (this.clickCount++, this.processTouches(a, this.overDown)));
            },
            overDown: function (a) {
              (R.set(a.pointerId, {
                target: a.target,
                out: a,
                outTarget: a.target,
              }),
                u.enterOver(a),
                u.down(a));
            },
            touchmove: function (a) {
              this.scrolling ||
                (this.shouldScroll(a)
                  ? ((this.scrolling = !0), this.touchcancel(a))
                  : (a.preventDefault(),
                    this.processTouches(a, this.moveOverOut)));
            },
            moveOverOut: function (a) {
              var b = a,
                c = R.get(b.pointerId);
              if (c) {
                var d = c.out,
                  e = c.outTarget;
                (u.move(b),
                  d &&
                    e !== b.target &&
                    ((d.relatedTarget = b.target),
                    (b.relatedTarget = e),
                    (d.target = e),
                    b.target
                      ? (u.leaveOut(d), u.enterOver(b))
                      : ((b.target = e),
                        (b.relatedTarget = null),
                        this.cancelOut(b))),
                  (c.out = b),
                  (c.outTarget = b.target));
              }
            },
            touchend: function (a) {
              (this.dedupSynthMouse(a), this.processTouches(a, this.upOut));
            },
            upOut: function (a) {
              (this.scrolling || (u.up(a), u.leaveOut(a)),
                this.cleanUpPointer(a));
            },
            touchcancel: function (a) {
              this.processTouches(a, this.cancelOut);
            },
            cancelOut: function (a) {
              (u.cancel(a), u.leaveOut(a), this.cleanUpPointer(a));
            },
            cleanUpPointer: function (a) {
              (R["delete"](a.pointerId), this.removePrimaryPointer(a));
            },
            dedupSynthMouse: function (a) {
              var b = N.lastTouches,
                c = a.changedTouches[0];
              if (this.isPrimaryTouch(c)) {
                var d = { x: c.clientX, y: c.clientY };
                b.push(d);
                var e = function (a, b) {
                  var c = a.indexOf(b);
                  c > -1 && a.splice(c, 1);
                }.bind(null, b, d);
                setTimeout(e, S);
              }
            },
          };
        M = new c(V.elementAdded, V.elementRemoved, V.elementChanged, V);
        var W,
          X,
          Y,
          Z = u.pointermap,
          $ =
            window.MSPointerEvent &&
            "number" == typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,
          _ = {
            events: [
              "MSPointerDown",
              "MSPointerMove",
              "MSPointerUp",
              "MSPointerOut",
              "MSPointerOver",
              "MSPointerCancel",
              "MSGotPointerCapture",
              "MSLostPointerCapture",
            ],
            register: function (a) {
              u.listen(a, this.events);
            },
            unregister: function (a) {
              u.unlisten(a, this.events);
            },
            POINTER_TYPES: ["", "unavailable", "touch", "pen", "mouse"],
            prepareEvent: function (a) {
              var b = a;
              return (
                $ &&
                  ((b = u.cloneEvent(a)),
                  (b.pointerType = this.POINTER_TYPES[a.pointerType])),
                b
              );
            },
            cleanup: function (a) {
              Z["delete"](a);
            },
            MSPointerDown: function (a) {
              Z.set(a.pointerId, a);
              var b = this.prepareEvent(a);
              u.down(b);
            },
            MSPointerMove: function (a) {
              var b = this.prepareEvent(a);
              u.move(b);
            },
            MSPointerUp: function (a) {
              var b = this.prepareEvent(a);
              (u.up(b), this.cleanup(a.pointerId));
            },
            MSPointerOut: function (a) {
              var b = this.prepareEvent(a);
              u.leaveOut(b);
            },
            MSPointerOver: function (a) {
              var b = this.prepareEvent(a);
              u.enterOver(b);
            },
            MSPointerCancel: function (a) {
              var b = this.prepareEvent(a);
              (u.cancel(b), this.cleanup(a.pointerId));
            },
            MSLostPointerCapture: function (a) {
              var b = u.makeEvent("lostpointercapture", a);
              u.dispatchEvent(b);
            },
            MSGotPointerCapture: function (a) {
              var b = u.makeEvent("gotpointercapture", a);
              u.dispatchEvent(b);
            },
          },
          aa = window.navigator;
        (aa.msPointerEnabled
          ? ((W = function (a) {
              (i(a),
                j(this),
                k(a) &&
                  (u.setCapture(a, this, !0), this.msSetPointerCapture(a)));
            }),
            (X = function (a) {
              (i(a), u.releaseCapture(a, !0), this.msReleasePointerCapture(a));
            }))
          : ((W = function (a) {
              (i(a), j(this), k(a) && u.setCapture(a, this));
            }),
            (X = function (a) {
              (i(a), u.releaseCapture(a));
            })),
          (Y = function (a) {
            return !!u.captureInfo[a];
          }),
          g(),
          h(),
          l());
        var ba = {
          dispatcher: u,
          Installer: c,
          PointerEvent: a,
          PointerMap: p,
          targetFinding: v,
        };
        return ba;
      });

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      var config = {
        dark_mode: false,
        show_pads: true,
        show_fabrication: false,
        show_silkscreen: true,
        highlight_pin1: false,
        redraw_on_drag: true,
        board_rotation: 0,
        checkboxes: "Sourced,Placed",
        bom_view: "left-right",
        layer_view: "FB",
        fields: ["Value", "Footprint"],
      };
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      var pcbdata = JSON.parse(
        LZString.decompressFromBase64(
          "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nbU7tnfU7aTbQ79nfQ6d7ZM6brXDazneZa5nVwBunZc6m7R465xF47gLSk6/LUHbdnZvaXneM6B7Tk7wrV/b8nbyaOnXQA/ncnbenSs7saGgzNcXc6JHXU7DbRC6AnXpbDnbC6pneg6vnTFbMLaUavqCi6nLe7btHVc7dHc1tV7Bs6hnbi7c7Q07nnYg7oXcE6JbaE6WHSo6QAB07loNS6Z7bS7XHQC6GtmUxmXfc6Crey7RnVC7zHTC73nVbblHT/bmAA1bmrf86+ndaz+BMvboHR3bjHU865XZy6FXdy7I7by7TnaPbVHSfbLLZq70XXftBpvNjyHb1aYHTK7DXXs7jXUE6UHUw60HZ87LXWw6J7dw7bXVzaDzcuxcaNNinXSvb9XcM7ZXe66ZHSa6vXcc6fXdbbbHWPbJ7RwFUXcs7g3Qpbmtp1tsXVs7XXTObTHYS65HUc7WnXy7VXSABCnf/bonRAApAEs66XU3adeWG6oHfzao3ay6n7fnaxnfG6WnSc7SXX668DVw6g3cMbSClAUW3Vna23Q868XTG7IXR67mnaW7e3b67wnWw749RPaAACo36od2a2gERKccN3eO510Tugt03mot2i2kt3Euj53Jur40EGog0Zuht3EO7yGjujZ3629t1SOjl1xuz109upN0qulN2qOtcDWWh/U3usV13u0N07usd3t2h+3PujJ0F2153ZOpV3wumZ0PWyJ0OOmu3Sset2Aeu11qJB9132p92Tutl1uumd1vuud1nu5V02Or40XOgD3xO7a0Ou3d0gu++2HW6N14egl0nuiZ1U2uF15O+D3fOil2dO4V1fW2e3lO/4gZyTD26u1t3genD0du492v2xV0sekl2Lu1h1VulG3iWkOioeij2/2Hm33BR90uu8F3Tuxj0Se010l28119upd3qulq00uhu23uu11xXM03VO/QBSIJgBSIA12Fuow2922D1sesl2uG+/Wbu9y2KWg+FSunF2iel91Gugj0MO+d2fukj0Ie+x1FOmu10AJT18e7N3kpER00ell1+eyD1du993Be/T0ye/l1yegB3iW9G0eeibGKWlhQ+e/N2aehj2ZO6D1Eu5z1tO/l14Gnh3GekV2metD1ZujnKqxcFJCe1S2Jew90nW191NOoL1EeuD2ue1R08O2UEme0B30uip2KW1JxFesF1d2rT1le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",
        ),
      );
      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* Utility functions */

      var storagePrefix =
        "KiCad_HTML_BOM__" +
        pcbdata.metadata.title +
        "__" +
        pcbdata.metadata.revision +
        "__#";
      var storage;

      function initStorage(key) {
        try {
          window.localStorage.getItem("blank");
          storage = window.localStorage;
        } catch (e) {
          // localStorage not available
        }
        if (!storage) {
          try {
            window.sessionStorage.getItem("blank");
            storage = window.sessionStorage;
          } catch (e) {
            // sessionStorage also not available
          }
        }
      }

      function readStorage(key) {
        if (storage) {
          return storage.getItem(storagePrefix + key);
        } else {
          return null;
        }
      }

      function writeStorage(key, value) {
        if (storage) {
          storage.setItem(storagePrefix + key, value);
        }
      }

      function fancyDblClickHandler(el, onsingle, ondouble) {
        return function () {
          if (el.getAttribute("data-dblclick") == null) {
            el.setAttribute("data-dblclick", 1);
            setTimeout(function () {
              if (el.getAttribute("data-dblclick") == 1) {
                onsingle();
              }
              el.removeAttribute("data-dblclick");
            }, 200);
          } else {
            el.removeAttribute("data-dblclick");
            ondouble();
          }
        };
      }

      function smoothScrollToRow(rowid) {
        document.getElementById(rowid).scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "nearest",
        });
      }

      function focusInputField(input) {
        input.scrollIntoView(false);
        input.focus();
        input.select();
      }

      function saveBomTable(output) {
        var text = "";
        for (var node of bomhead.childNodes[0].childNodes) {
          if (node.firstChild) {
            text +=
              output == "csv"
                ? `"${node.firstChild.nodeValue}"`
                : node.firstChild.nodeValue;
          }
          if (node != bomhead.childNodes[0].lastChild) {
            text += output == "csv" ? "," : "\t";
          }
        }
        text += "\n";
        for (var row of bombody.childNodes) {
          for (var cell of row.childNodes) {
            let val = "";
            for (var node of cell.childNodes) {
              if (node.nodeName == "INPUT") {
                if (node.checked) {
                  val += "✓";
                }
              } else if (node.nodeName == "MARK") {
                val += node.firstChild.nodeValue;
              } else {
                val += node.nodeValue;
              }
            }
            if (output == "csv") {
              val = val.replace(/\"/g, '\"\"'); // pair of double-quote characters
              if (isNumeric(val)) {
                val = +val; // use number
              } else {
                val = `"${val}"`; // enclosed within double-quote
              }
            }
            text += val;
            if (cell != row.lastChild) {
              text += output == "csv" ? "," : "\t";
            }
          }
          text += "\n";
        }

        if (output != "clipboard") {
          // To file: csv or txt
          var blob = new Blob([text], {
            type: `text/${output}`,
          });
          saveFile(`${pcbdata.metadata.title}.${output}`, blob);
        } else {
          // To clipboard
          var textArea = document.createElement("textarea");
          textArea.classList.add("clipboard-temp");
          textArea.value = text;

          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();

          try {
            if (document.execCommand("copy")) {
              console.log("Bom copied to clipboard.");
            }
          } catch (err) {
            console.log("Can not copy to clipboard.");
          }

          document.body.removeChild(textArea);
        }
      }

      function isNumeric(str) {
        /* https://stackoverflow.com/a/175787 */
        return typeof str != "string"
          ? false
          : !isNaN(str) && !isNaN(parseFloat(str));
      }

      function removeGutterNode(node) {
        for (var i = 0; i < node.childNodes.length; i++) {
          if (
            node.childNodes[i].classList &&
            node.childNodes[i].classList.contains("gutter")
          ) {
            node.removeChild(node.childNodes[i]);
            break;
          }
        }
      }

      function cleanGutters() {
        removeGutterNode(document.getElementById("bot"));
        removeGutterNode(document.getElementById("canvasdiv"));
      }

      var units = {
        prefixes: {
          giga: ["G", "g", "giga", "Giga", "GIGA"],
          mega: ["M", "mega", "Mega", "MEGA"],
          kilo: ["K", "k", "kilo", "Kilo", "KILO"],
          milli: ["m", "milli", "Milli", "MILLI"],
          micro: ["U", "u", "micro", "Micro", "MICRO", "μ", "µ"], // different utf8 μ
          nano: ["N", "n", "nano", "Nano", "NANO"],
          pico: ["P", "p", "pico", "Pico", "PICO"],
        },
        unitsShort: ["R", "r", "Ω", "F", "f", "H", "h"],
        unitsLong: [
          "OHM",
          "Ohm",
          "ohm",
          "ohms",
          "FARAD",
          "Farad",
          "farad",
          "HENRY",
          "Henry",
          "henry",
        ],
        getMultiplier: function (s) {
          if (this.prefixes.giga.includes(s)) return 1e9;
          if (this.prefixes.mega.includes(s)) return 1e6;
          if (this.prefixes.kilo.includes(s)) return 1e3;
          if (this.prefixes.milli.includes(s)) return 1e-3;
          if (this.prefixes.micro.includes(s)) return 1e-6;
          if (this.prefixes.nano.includes(s)) return 1e-9;
          if (this.prefixes.pico.includes(s)) return 1e-12;
          return 1;
        },
        valueRegex: null,
      };

      function initUtils() {
        var allPrefixes = units.prefixes.giga
          .concat(units.prefixes.mega)
          .concat(units.prefixes.kilo)
          .concat(units.prefixes.milli)
          .concat(units.prefixes.micro)
          .concat(units.prefixes.nano)
          .concat(units.prefixes.pico);
        var allUnits = units.unitsShort.concat(units.unitsLong);
        units.valueRegex = new RegExp(
          "^([0-9\.]+)" +
            "\\s*(" +
            allPrefixes.join("|") +
            ")?" +
            "(" +
            allUnits.join("|") +
            ")?" +
            "(\\b.*)?$",
          "",
        );
        units.valueAltRegex = new RegExp(
          "^([0-9]*)" +
            "(" +
            units.unitsShort.join("|") +
            ")?" +
            "([GgMmKkUuNnPp])?" +
            "([0-9]*)" +
            "(\\b.*)?$",
          "",
        );
        if (config.fields.includes("Value")) {
          var index = config.fields.indexOf("Value");
          pcbdata.bom["parsedValues"] = {};
          for (var id in pcbdata.bom.fields) {
            pcbdata.bom.parsedValues[id] = parseValue(
              pcbdata.bom.fields[id][index],
            );
          }
        }
      }

      function parseValue(val, ref) {
        var inferUnit = (unit, ref) => {
          if (unit) {
            unit = unit.toLowerCase();
            if (unit == "Ω" || unit == "ohm" || unit == "ohms") {
              unit = "r";
            }
            unit = unit[0];
          } else {
            ref = /^([a-z]+)\d+$/i.exec(ref);
            if (ref) {
              ref = ref[1].toLowerCase();
              if (ref == "c") unit = "f";
              else if (ref == "l") unit = "h";
              else if (ref == "r" || ref == "rv") unit = "r";
              else unit = null;
            }
          }
          return unit;
        };
        val = val.replace(/,/g, "");
        var match = units.valueRegex.exec(val);
        var unit;
        if (match) {
          val = parseFloat(match[1]);
          if (match[2]) {
            val = val * units.getMultiplier(match[2]);
          }
          unit = inferUnit(match[3], ref);
          if (!unit) return null;
          else
            return {
              val: val,
              unit: unit,
              extra: match[4],
            };
        }
        match = units.valueAltRegex.exec(val);
        if (match && (match[1] || match[4])) {
          val = parseFloat(match[1] + "." + match[4]);
          if (match[3]) {
            val = val * units.getMultiplier(match[3]);
          }
          unit = inferUnit(match[2], ref);
          if (!unit) return null;
          else
            return {
              val: val,
              unit: unit,
              extra: match[5],
            };
        }
        return null;
      }

      function valueCompare(a, b, stra, strb) {
        if (a === null && b === null) {
          // Failed to parse both values, compare them as strings.
          if (stra != strb) return stra > strb ? 1 : -1;
          else return 0;
        } else if (a === null) {
          return 1;
        } else if (b === null) {
          return -1;
        } else {
          if (a.unit != b.unit) return a.unit > b.unit ? 1 : -1;
          else if (a.val != b.val) return a.val > b.val ? 1 : -1;
          else if (a.extra != b.extra) return a.extra > b.extra ? 1 : -1;
          else return 0;
        }
      }

      function validateSaveImgDimension(element) {
        var valid = false;
        var intValue = 0;
        if (/^[1-9]\d*$/.test(element.value)) {
          intValue = parseInt(element.value);
          if (intValue <= 16000) {
            valid = true;
          }
        }
        if (valid) {
          element.classList.remove("invalid");
        } else {
          element.classList.add("invalid");
        }
        return intValue;
      }

      function saveImage(layer) {
        var width = validateSaveImgDimension(
          document.getElementById("render-save-width"),
        );
        var height = validateSaveImgDimension(
          document.getElementById("render-save-height"),
        );
        var bgcolor = null;
        if (!document.getElementById("render-save-transparent").checked) {
          var style = getComputedStyle(topmostdiv);
          bgcolor = style.getPropertyValue("background-color");
        }
        if (!width || !height) return;

        // Prepare image
        var canvas = document.createElement("canvas");
        var layerdict = {
          transform: {
            x: 0,
            y: 0,
            s: 1,
            panx: 0,
            pany: 0,
            zoom: 1,
          },
          bg: canvas,
          fab: canvas,
          silk: canvas,
          highlight: canvas,
          layer: layer,
        };
        // Do the rendering
        recalcLayerScale(layerdict, width, height);
        prepareLayer(layerdict);
        clearCanvas(canvas, bgcolor);
        drawBackground(layerdict, false);
        drawHighlightsOnLayer(layerdict, false);

        // Save image
        var imgdata = canvas.toDataURL("image/png");

        var filename = pcbdata.metadata.title;
        if (pcbdata.metadata.revision) {
          filename += `.${pcbdata.metadata.revision}`;
        }
        filename += `.${layer}.png`;
        saveFile(filename, dataURLtoBlob(imgdata));
      }

      function saveSettings() {
        var data = {
          type: "InteractiveHtmlBom settings",
          version: 1,
          pcbmetadata: pcbdata.metadata,
          settings: settings,
        };
        var blob = new Blob([JSON.stringify(data, null, 4)], {
          type: "application/json",
        });
        saveFile(`${pcbdata.metadata.title}.settings.json`, blob);
      }

      function loadSettings() {
        var input = document.createElement("input");
        input.type = "file";
        input.accept = ".settings.json";
        input.onchange = function (e) {
          var file = e.target.files[0];
          var reader = new FileReader();
          reader.onload = (readerEvent) => {
            var content = readerEvent.target.result;
            var newSettings;
            try {
              newSettings = JSON.parse(content);
            } catch (e) {
              alert("Selected file is not InteractiveHtmlBom settings file.");
              return;
            }
            if (newSettings.type != "InteractiveHtmlBom settings") {
              alert("Selected file is not InteractiveHtmlBom settings file.");
              return;
            }
            var metadataMatches = newSettings.hasOwnProperty("pcbmetadata");
            if (metadataMatches) {
              for (var k in pcbdata.metadata) {
                if (
                  !newSettings.pcbmetadata.hasOwnProperty(k) ||
                  newSettings.pcbmetadata[k] != pcbdata.metadata[k]
                ) {
                  metadataMatches = false;
                }
              }
            }
            if (!metadataMatches) {
              var currentMetadata = JSON.stringify(pcbdata.metadata, null, 4);
              var fileMetadata = JSON.stringify(
                newSettings.pcbmetadata,
                null,
                4,
              );
              if (
                !confirm(
                  `Settins file metadata does not match current metadata.\n\n` +
                    `Page metadata:\n${currentMetadata}\n\n` +
                    `Settings file metadata:\n${fileMetadata}\n\n` +
                    `Press OK if you would like to import settings anyway.`,
                )
              ) {
                return;
              }
            }
            overwriteSettings(newSettings.settings);
          };
          reader.readAsText(file, "UTF-8");
        };
        input.click();
      }

      function overwriteSettings(newSettings) {
        initDone = false;
        Object.assign(settings, newSettings);
        writeStorage("bomlayout", settings.bomlayout);
        writeStorage("bommode", settings.bommode);
        writeStorage("canvaslayout", settings.canvaslayout);
        writeStorage("bomCheckboxes", settings.checkboxes.join(","));
        document.getElementById("bomCheckboxes").value =
          settings.checkboxes.join(",");
        for (var checkbox of settings.checkboxes) {
          writeStorage(
            "checkbox_" + checkbox,
            settings.checkboxStoredRefs[checkbox],
          );
        }
        writeStorage("markWhenChecked", settings.markWhenChecked);
        padsVisible(settings.renderPads);
        document.getElementById("padsCheckbox").checked = settings.renderPads;
        fabricationVisible(settings.renderFabrication);
        document.getElementById("fabricationCheckbox").checked =
          settings.renderFabrication;
        silkscreenVisible(settings.renderSilkscreen);
        document.getElementById("silkscreenCheckbox").checked =
          settings.renderSilkscreen;
        referencesVisible(settings.renderReferences);
        document.getElementById("referencesCheckbox").checked =
          settings.renderReferences;
        valuesVisible(settings.renderValues);
        document.getElementById("valuesCheckbox").checked =
          settings.renderValues;
        tracksVisible(settings.renderTracks);
        document.getElementById("tracksCheckbox").checked =
          settings.renderTracks;
        zonesVisible(settings.renderZones);
        document.getElementById("zonesCheckbox").checked = settings.renderZones;
        dnpOutline(settings.renderDnpOutline);
        document.getElementById("dnpOutlineCheckbox").checked =
          settings.renderDnpOutline;
        setRedrawOnDrag(settings.redrawOnDrag);
        document.getElementById("dragCheckbox").checked = settings.redrawOnDrag;
        setDarkMode(settings.darkMode);
        document.getElementById("darkmodeCheckbox").checked = settings.darkMode;
        setHighlightPin1(settings.highlightpin1);
        document.getElementById("highlightpin1Checkbox").checked =
          settings.highlightpin1;
        showFootprints(settings.show_footprints);
        writeStorage("boardRotation", settings.boardRotation);
        document.getElementById("boardRotation").value =
          settings.boardRotation / 5;
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
        initDone = true;
        prepCheckboxes();
        changeBomLayout(settings.bomlayout);
      }

      function saveFile(filename, blob) {
        var link = document.createElement("a");
        var objurl = URL.createObjectURL(blob);
        link.download = filename;
        link.href = objurl;
        link.click();
      }

      function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(","),
          mime = arr[0].match(/:(.*?);/)[1],
          bstr = atob(arr[1]),
          n = bstr.length,
          u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {
          type: mime,
        });
      }

      var settings = {
        canvaslayout: "default",
        bomlayout: "default",
        bommode: "grouped",
        checkboxes: [],
        checkboxStoredRefs: {},
        darkMode: false,
        highlightpin1: false,
        redrawOnDrag: true,
        boardRotation: 0,
        renderPads: true,
        renderReferences: true,
        renderValues: true,
        renderSilkscreen: true,
        renderFabrication: true,
        renderDnpOutline: false,
        renderTracks: true,
        renderZones: true,
        columnOrder: [],
        hiddenColumns: [],
      };

      function initDefaults() {
        settings.bomlayout = readStorage("bomlayout");
        if (settings.bomlayout === null) {
          settings.bomlayout = config.bom_view;
        }
        if (
          !["bom-only", "left-right", "top-bottom"].includes(settings.bomlayout)
        ) {
          settings.bomlayout = config.bom_view;
        }
        settings.bommode = readStorage("bommode");
        if (settings.bommode === null) {
          settings.bommode = "grouped";
        }
        if (!["grouped", "ungrouped", "netlist"].includes(settings.bommode)) {
          settings.bommode = "grouped";
        }
        settings.canvaslayout = readStorage("canvaslayout");
        if (settings.canvaslayout === null) {
          settings.canvaslayout = config.layer_view;
        }
        var bomCheckboxes = readStorage("bomCheckboxes");
        if (bomCheckboxes === null) {
          bomCheckboxes = config.checkboxes;
        }
        settings.checkboxes = bomCheckboxes.split(",").filter((e) => e);
        document.getElementById("bomCheckboxes").value = bomCheckboxes;

        settings.markWhenChecked = readStorage("markWhenChecked") || "";
        populateMarkWhenCheckedOptions();

        function initBooleanSetting(storageString, def, elementId, func) {
          var b = readStorage(storageString);
          if (b === null) {
            b = def;
          } else {
            b = b == "true";
          }
          document.getElementById(elementId).checked = b;
          func(b);
        }

        initBooleanSetting(
          "padsVisible",
          config.show_pads,
          "padsCheckbox",
          padsVisible,
        );
        initBooleanSetting(
          "fabricationVisible",
          config.show_fabrication,
          "fabricationCheckbox",
          fabricationVisible,
        );
        initBooleanSetting(
          "silkscreenVisible",
          config.show_silkscreen,
          "silkscreenCheckbox",
          silkscreenVisible,
        );
        initBooleanSetting(
          "referencesVisible",
          true,
          "referencesCheckbox",
          referencesVisible,
        );
        initBooleanSetting(
          "valuesVisible",
          true,
          "valuesCheckbox",
          valuesVisible,
        );
        if ("tracks" in pcbdata) {
          initBooleanSetting(
            "tracksVisible",
            true,
            "tracksCheckbox",
            tracksVisible,
          );
          initBooleanSetting(
            "zonesVisible",
            true,
            "zonesCheckbox",
            zonesVisible,
          );
        } else {
          document.getElementById("tracksAndZonesCheckboxes").style.display =
            "none";
          tracksVisible(false);
          zonesVisible(false);
        }
        initBooleanSetting(
          "dnpOutline",
          false,
          "dnpOutlineCheckbox",
          dnpOutline,
        );
        initBooleanSetting(
          "redrawOnDrag",
          config.redraw_on_drag,
          "dragCheckbox",
          setRedrawOnDrag,
        );
        initBooleanSetting(
          "darkmode",
          config.dark_mode,
          "darkmodeCheckbox",
          setDarkMode,
        );
        initBooleanSetting(
          "highlightpin1",
          config.highlight_pin1,
          "highlightpin1Checkbox",
          setHighlightPin1,
        );

        var fields = ["checkboxes", "References"]
          .concat(config.fields)
          .concat(["Quantity"]);
        var hcols = JSON.parse(readStorage("hiddenColumns"));
        if (hcols === null) {
          hcols = [];
        }
        settings.hiddenColumns = hcols.filter((e) => fields.includes(e));

        var cord = JSON.parse(readStorage("columnOrder"));
        if (cord === null) {
          cord = fields;
        } else {
          cord = cord.filter((e) => fields.includes(e));
          if (cord.length != fields.length) cord = fields;
        }
        settings.columnOrder = cord;

        settings.boardRotation = readStorage("boardRotation");
        if (settings.boardRotation === null) {
          settings.boardRotation = config.board_rotation * 5;
        } else {
          settings.boardRotation = parseInt(settings.boardRotation);
        }
        document.getElementById("boardRotation").value =
          settings.boardRotation / 5;
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
      }

      // Helper classes for user js callbacks.

      const IBOM_EVENT_TYPES = {
        ALL: "all",
        HIGHLIGHT_EVENT: "highlightEvent",
        CHECKBOX_CHANGE_EVENT: "checkboxChangeEvent",
        BOM_BODY_CHANGE_EVENT: "bomBodyChangeEvent",
      };

      const EventHandler = {
        callbacks: {},
        init: function () {
          for (eventType of Object.values(IBOM_EVENT_TYPES))
            this.callbacks[eventType] = [];
        },
        registerCallback: function (eventType, callback) {
          this.callbacks[eventType].push(callback);
        },
        emitEvent: function (eventType, eventArgs) {
          event = {
            eventType: eventType,
            args: eventArgs,
          };
          var callback;
          for (callback of this.callbacks[eventType]) callback(event);
          for (callback of this.callbacks[IBOM_EVENT_TYPES.ALL])
            callback(event);
        },
      };
      EventHandler.init();

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* PCB rendering code */

      var emptyContext2d = document.createElement("canvas").getContext("2d");

      function deg2rad(deg) {
        return (deg * Math.PI) / 180;
      }

      function calcFontPoint(linepoint, text, offsetx, offsety, tilt) {
        var point = [
          linepoint[0] * text.width + offsetx,
          linepoint[1] * text.height + offsety,
        ];
        // This approximates pcbnew behavior with how text tilts depending on horizontal justification
        point[0] -=
          (linepoint[1] + 0.5 * (1 + text.justify[0])) * text.height * tilt;
        return point;
      }

      function drawText(ctx, text, color) {
        if ("ref" in text && !settings.renderReferences) return;
        if ("val" in text && !settings.renderValues) return;
        ctx.save();
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = text.thickness;
        if ("svgpath" in text) {
          ctx.stroke(new Path2D(text.svgpath));
          ctx.restore();
          return;
        }
        if ("polygons" in text) {
          ctx.fill(getPolygonsPath(text));
          ctx.restore();
          return;
        }
        ctx.translate(...text.pos);
        ctx.translate(text.thickness * 0.5, 0);
        var angle = -text.angle;
        if (text.attr.includes("mirrored")) {
          ctx.scale(-1, 1);
          angle = -angle;
        }
        var tilt = 0;
        if (text.attr.includes("italic")) {
          tilt = 0.125;
        }
        var interline = text.height * 1.5 + text.thickness;
        var txt = text.text.split("\n");
        // KiCad ignores last empty line.
        if (txt[txt.length - 1] == "") txt.pop();
        ctx.rotate(deg2rad(angle));
        var offsety = ((1 - text.justify[1]) / 2) * text.height; // One line offset
        offsety -= (((txt.length - 1) * (text.justify[1] + 1)) / 2) * interline; // Multiline offset
        for (var i in txt) {
          var lineWidth = text.thickness + (interline / 2) * tilt;
          for (var j = 0; j < txt[i].length; j++) {
            if (txt[i][j] == "\t") {
              var fourSpaces = 4 * pcbdata.font_data[" "].w * text.width;
              lineWidth += fourSpaces - (lineWidth % fourSpaces);
            } else {
              if (txt[i][j] == "~") {
                j++;
                if (j == txt[i].length) break;
              }
              lineWidth += pcbdata.font_data[txt[i][j]].w * text.width;
            }
          }
          var offsetx = (-lineWidth * (text.justify[0] + 1)) / 2;
          var inOverbar = false;
          for (var j = 0; j < txt[i].length; j++) {
            if (txt[i][j] == "\t") {
              var fourSpaces = 4 * pcbdata.font_data[" "].w * text.width;
              offsetx += fourSpaces - (offsetx % fourSpaces);
              continue;
            } else if (txt[i][j] == "~") {
              j++;
              if (j == txt[i].length) break;
              if (txt[i][j] != "~") {
                inOverbar = !inOverbar;
              }
            }
            var glyph = pcbdata.font_data[txt[i][j]];
            if (inOverbar) {
              var overbarStart = [offsetx, -text.height * 1.4 + offsety];
              var overbarEnd = [
                offsetx + text.width * glyph.w,
                overbarStart[1],
              ];

              if (!lastHadOverbar) {
                overbarStart[0] += text.height * 1.4 * tilt;
                lastHadOverbar = true;
              }
              ctx.beginPath();
              ctx.moveTo(...overbarStart);
              ctx.lineTo(...overbarEnd);
              ctx.stroke();
            } else {
              lastHadOverbar = false;
            }
            for (var line of glyph.l) {
              ctx.beginPath();
              ctx.moveTo(
                ...calcFontPoint(line[0], text, offsetx, offsety, tilt),
              );
              for (var k = 1; k < line.length; k++) {
                ctx.lineTo(
                  ...calcFontPoint(line[k], text, offsetx, offsety, tilt),
                );
              }
              ctx.stroke();
            }
            offsetx += glyph.w * text.width;
          }
          offsety += interline;
        }
        ctx.restore();
      }

      function drawedge(ctx, scalefactor, edge, color) {
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = Math.max(1 / scalefactor, edge.width);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        if ("svgpath" in edge) {
          ctx.stroke(new Path2D(edge.svgpath));
        } else {
          ctx.beginPath();
          if (edge.type == "segment") {
            ctx.moveTo(...edge.start);
            ctx.lineTo(...edge.end);
          }
          if (edge.type == "rect") {
            ctx.moveTo(...edge.start);
            ctx.lineTo(edge.start[0], edge.end[1]);
            ctx.lineTo(...edge.end);
            ctx.lineTo(edge.end[0], edge.start[1]);
            ctx.lineTo(...edge.start);
          }
          if (edge.type == "arc") {
            ctx.arc(
              ...edge.start,
              edge.radius,
              deg2rad(edge.startangle),
              deg2rad(edge.endangle),
            );
          }
          if (edge.type == "circle") {
            ctx.arc(...edge.start, edge.radius, 0, 2 * Math.PI);
            ctx.closePath();
          }
          if (edge.type == "curve") {
            ctx.moveTo(...edge.start);
            ctx.bezierCurveTo(...edge.cpa, ...edge.cpb, ...edge.end);
          }
          if ("filled" in edge && edge.filled) ctx.fill();
          else ctx.stroke();
        }
      }

      function getChamferedRectPath(size, radius, chamfpos, chamfratio) {
        // chamfpos is a bitmask, left = 1, right = 2, bottom left = 4, bottom right = 8
        var path = new Path2D();
        var width = size[0];
        var height = size[1];
        var x = width * -0.5;
        var y = height * -0.5;
        var chamfOffset = Math.min(width, height) * chamfratio;
        path.moveTo(x, 0);
        if (chamfpos & 4) {
          path.lineTo(x, y + height - chamfOffset);
          path.lineTo(x + chamfOffset, y + height);
          path.lineTo(0, y + height);
        } else {
          path.arcTo(x, y + height, x + width, y + height, radius);
        }
        if (chamfpos & 8) {
          path.lineTo(x + width - chamfOffset, y + height);
          path.lineTo(x + width, y + height - chamfOffset);
          path.lineTo(x + width, 0);
        } else {
          path.arcTo(x + width, y + height, x + width, y, radius);
        }
        if (chamfpos & 2) {
          path.lineTo(x + width, y + chamfOffset);
          path.lineTo(x + width - chamfOffset, y);
          path.lineTo(0, y);
        } else {
          path.arcTo(x + width, y, x, y, radius);
        }
        if (chamfpos & 1) {
          path.lineTo(x + chamfOffset, y);
          path.lineTo(x, y + chamfOffset);
          path.lineTo(x, 0);
        } else {
          path.arcTo(x, y, x, y + height, radius);
        }
        path.closePath();
        return path;
      }

      function getOblongPath(size) {
        return getChamferedRectPath(size, Math.min(size[0], size[1]) / 2, 0, 0);
      }

      function getPolygonsPath(shape) {
        if (shape.path2d) {
          return shape.path2d;
        }
        if ("svgpath" in shape) {
          shape.path2d = new Path2D(shape.svgpath);
        } else {
          var path = new Path2D();
          for (var polygon of shape.polygons) {
            path.moveTo(...polygon[0]);
            for (var i = 1; i < polygon.length; i++) {
              path.lineTo(...polygon[i]);
            }
            path.closePath();
          }
          shape.path2d = path;
        }
        return shape.path2d;
      }

      function drawPolygonShape(ctx, scalefactor, shape, color) {
        ctx.save();
        if (!("svgpath" in shape)) {
          ctx.translate(...shape.pos);
          ctx.rotate(deg2rad(-shape.angle));
        }
        if ("filled" in shape && !shape.filled) {
          ctx.strokeStyle = color;
          ctx.lineWidth = Math.max(1 / scalefactor, shape.width);
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.stroke(getPolygonsPath(shape));
        } else {
          ctx.fillStyle = color;
          ctx.fill(getPolygonsPath(shape));
        }
        ctx.restore();
      }

      function drawDrawing(ctx, scalefactor, drawing, color) {
        if (
          ["segment", "arc", "circle", "curve", "rect"].includes(drawing.type)
        ) {
          drawedge(ctx, scalefactor, drawing, color);
        } else if (drawing.type == "polygon") {
          drawPolygonShape(ctx, scalefactor, drawing, color);
        } else {
          drawText(ctx, drawing, color);
        }
      }

      function getCirclePath(radius) {
        var path = new Path2D();
        path.arc(0, 0, radius, 0, 2 * Math.PI);
        path.closePath();
        return path;
      }

      function getCachedPadPath(pad) {
        if (!pad.path2d) {
          // if path2d is not set, build one and cache it on pad object
          if (pad.shape == "rect") {
            pad.path2d = new Path2D();
            pad.path2d.rect(...pad.size.map((c) => -c * 0.5), ...pad.size);
          } else if (pad.shape == "oval") {
            pad.path2d = getOblongPath(pad.size);
          } else if (pad.shape == "circle") {
            pad.path2d = getCirclePath(pad.size[0] / 2);
          } else if (pad.shape == "roundrect") {
            pad.path2d = getChamferedRectPath(pad.size, pad.radius, 0, 0);
          } else if (pad.shape == "chamfrect") {
            pad.path2d = getChamferedRectPath(
              pad.size,
              pad.radius,
              pad.chamfpos,
              pad.chamfratio,
            );
          } else if (pad.shape == "custom") {
            pad.path2d = getPolygonsPath(pad);
          }
        }
        return pad.path2d;
      }

      function drawPad(ctx, pad, color, outline) {
        ctx.save();
        ctx.translate(...pad.pos);
        ctx.rotate(-deg2rad(pad.angle));
        if (pad.offset) {
          ctx.translate(...pad.offset);
        }
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        var path = getCachedPadPath(pad);
        if (outline) {
          ctx.stroke(path);
        } else {
          ctx.fill(path);
        }
        ctx.restore();
      }

      function drawPadHole(ctx, pad, padHoleColor) {
        if (pad.type != "th") return;
        ctx.save();
        ctx.translate(...pad.pos);
        ctx.rotate(-deg2rad(pad.angle));
        ctx.fillStyle = padHoleColor;
        if (pad.drillshape == "oblong") {
          ctx.fill(getOblongPath(pad.drillsize));
        } else {
          ctx.fill(getCirclePath(pad.drillsize[0] / 2));
        }
        ctx.restore();
      }

      function drawFootprint(
        ctx,
        layer,
        scalefactor,
        footprint,
        colors,
        highlight,
        outline,
      ) {
        if (highlight) {
          // draw bounding box
          if (footprint.layer == layer) {
            ctx.save();
            ctx.globalAlpha = 0.2;
            ctx.translate(...footprint.bbox.pos);
            ctx.rotate(deg2rad(-footprint.bbox.angle));
            ctx.translate(...footprint.bbox.relpos);
            ctx.fillStyle = colors.pad;
            ctx.fillRect(0, 0, ...footprint.bbox.size);
            ctx.globalAlpha = 1;
            ctx.strokeStyle = colors.pad;
            ctx.strokeRect(0, 0, ...footprint.bbox.size);
            ctx.restore();
          }
        }
        // draw drawings
        for (var drawing of footprint.drawings) {
          if (drawing.layer == layer) {
            drawDrawing(ctx, scalefactor, drawing.drawing, colors.pad);
          }
        }
        // draw pads
        if (settings.renderPads) {
          for (var pad of footprint.pads) {
            if (pad.layers.includes(layer)) {
              drawPad(ctx, pad, colors.pad, outline);
              if (pad.pin1 && settings.highlightpin1) {
                drawPad(ctx, pad, colors.outline, true);
              }
            }
          }
          for (var pad of footprint.pads) {
            drawPadHole(ctx, pad, colors.padHole);
          }
        }
      }

      function drawEdgeCuts(canvas, scalefactor) {
        var ctx = canvas.getContext("2d");
        var edgecolor =
          getComputedStyle(topmostdiv).getPropertyValue("--pcb-edge-color");
        for (var edge of pcbdata.edges) {
          drawDrawing(ctx, scalefactor, edge, edgecolor);
        }
      }

      function drawFootprints(canvas, layer, scalefactor, highlight) {
        var ctx = canvas.getContext("2d");
        ctx.lineWidth = 3 / scalefactor;
        var style = getComputedStyle(topmostdiv);

        var colors = {
          pad: style.getPropertyValue("--pad-color"),
          padHole: style.getPropertyValue("--pad-hole-color"),
          outline: style.getPropertyValue("--pin1-outline-color"),
        };

        for (var i = 0; i < pcbdata.footprints.length; i++) {
          var mod = pcbdata.footprints[i];
          var outline =
            settings.renderDnpOutline && pcbdata.bom.skipped.includes(i);
          var h = highlightedFootprints.includes(i);
          var d = markedFootprints.has(i);
          if (highlight) {
            if (h && d) {
              colors.pad = style.getPropertyValue("--pad-color-highlight-both");
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight-both",
              );
            } else if (h) {
              colors.pad = style.getPropertyValue("--pad-color-highlight");
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight",
              );
            } else if (d) {
              colors.pad = style.getPropertyValue(
                "--pad-color-highlight-marked",
              );
              colors.outline = style.getPropertyValue(
                "--pin1-outline-color-highlight-marked",
              );
            }
          }
          if (h || d || !highlight) {
            drawFootprint(
              ctx,
              layer,
              scalefactor,
              mod,
              colors,
              highlight,
              outline,
            );
          }
        }
      }

      function drawBgLayer(
        layername,
        canvas,
        layer,
        scalefactor,
        edgeColor,
        polygonColor,
        textColor,
      ) {
        var ctx = canvas.getContext("2d");
        for (var d of pcbdata.drawings[layername][layer]) {
          if (["segment", "arc", "circle", "curve", "rect"].includes(d.type)) {
            drawedge(ctx, scalefactor, d, edgeColor);
          } else if (d.type == "polygon") {
            drawPolygonShape(ctx, scalefactor, d, polygonColor);
          } else {
            drawText(ctx, d, textColor);
          }
        }
      }

      function drawTracks(canvas, layer, color, highlight) {
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = color;
        ctx.lineCap = "round";
        for (var track of pcbdata.tracks[layer]) {
          if (highlight && highlightedNet != track.net) continue;
          ctx.lineWidth = track.width;
          ctx.beginPath();
          if ("radius" in track) {
            ctx.arc(
              ...track.center,
              track.radius,
              deg2rad(track.startangle),
              deg2rad(track.endangle),
            );
          } else {
            ctx.moveTo(...track.start);
            ctx.lineTo(...track.end);
          }
          ctx.stroke();
        }
      }

      function drawZones(canvas, layer, color, highlight) {
        ctx = canvas.getContext("2d");
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineJoin = "round";
        for (var zone of pcbdata.zones[layer]) {
          if (!zone.path2d) {
            zone.path2d = getPolygonsPath(zone);
          }
          if (highlight && highlightedNet != zone.net) continue;
          ctx.fill(zone.path2d);
          if (zone.width > 0) {
            ctx.lineWidth = zone.width;
            ctx.stroke(zone.path2d);
          }
        }
      }

      function clearCanvas(canvas, color = null) {
        var ctx = canvas.getContext("2d");
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (color) {
          ctx.fillStyle = color;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
          if (!window.matchMedia("print").matches)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        ctx.restore();
      }

      function drawNets(canvas, layer, highlight) {
        var style = getComputedStyle(topmostdiv);
        if (settings.renderTracks) {
          var trackColor = style.getPropertyValue(
            highlight ? "--track-color-highlight" : "--track-color",
          );
          drawTracks(canvas, layer, trackColor, highlight);
        }
        if (settings.renderZones) {
          var zoneColor = style.getPropertyValue(
            highlight ? "--zone-color-highlight" : "--zone-color",
          );
          drawZones(canvas, layer, zoneColor, highlight);
        }
        if (highlight && settings.renderPads) {
          var padColor = style.getPropertyValue("--pad-color-highlight");
          var padHoleColor = style.getPropertyValue("--pad-hole-color");
          var ctx = canvas.getContext("2d");
          for (var footprint of pcbdata.footprints) {
            // draw pads
            var padDrawn = false;
            for (var pad of footprint.pads) {
              if (highlightedNet != pad.net) continue;
              if (pad.layers.includes(layer)) {
                drawPad(ctx, pad, padColor, false);
                padDrawn = true;
              }
            }
            if (padDrawn) {
              // redraw all pad holes because some pads may overlap
              for (var pad of footprint.pads) {
                drawPadHole(ctx, pad, padHoleColor);
              }
            }
          }
        }
      }

      function drawHighlightsOnLayer(canvasdict, clear = true) {
        if (clear) {
          clearCanvas(canvasdict.highlight);
        }
        if (markedFootprints.size > 0 || highlightedFootprints.length > 0) {
          drawFootprints(
            canvasdict.highlight,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            true,
          );
        }
        if (highlightedNet !== null) {
          drawNets(canvasdict.highlight, canvasdict.layer, true);
        }
      }

      function drawHighlights() {
        drawHighlightsOnLayer(allcanvas.front);
        drawHighlightsOnLayer(allcanvas.back);
      }

      function drawBackground(canvasdict, clear = true) {
        if (clear) {
          clearCanvas(canvasdict.bg);
          clearCanvas(canvasdict.fab);
          clearCanvas(canvasdict.silk);
        }

        drawNets(canvasdict.bg, canvasdict.layer, false);
        drawFootprints(
          canvasdict.bg,
          canvasdict.layer,
          canvasdict.transform.s * canvasdict.transform.zoom,
          false,
        );

        drawEdgeCuts(
          canvasdict.bg,
          canvasdict.transform.s * canvasdict.transform.zoom,
        );

        var style = getComputedStyle(topmostdiv);
        var edgeColor = style.getPropertyValue("--silkscreen-edge-color");
        var polygonColor = style.getPropertyValue("--silkscreen-polygon-color");
        var textColor = style.getPropertyValue("--silkscreen-text-color");
        if (settings.renderSilkscreen) {
          drawBgLayer(
            "silkscreen",
            canvasdict.silk,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            edgeColor,
            polygonColor,
            textColor,
          );
        }
        edgeColor = style.getPropertyValue("--fabrication-edge-color");
        polygonColor = style.getPropertyValue("--fabrication-polygon-color");
        textColor = style.getPropertyValue("--fabrication-text-color");
        if (settings.renderFabrication) {
          drawBgLayer(
            "fabrication",
            canvasdict.fab,
            canvasdict.layer,
            canvasdict.transform.s * canvasdict.transform.zoom,
            edgeColor,
            polygonColor,
            textColor,
          );
        }
      }

      function prepareCanvas(canvas, flip, transform) {
        var ctx = canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(transform.zoom, transform.zoom);
        ctx.translate(transform.panx, transform.pany);
        if (flip) {
          ctx.scale(-1, 1);
        }
        ctx.translate(transform.x, transform.y);
        ctx.rotate(deg2rad(settings.boardRotation));
        ctx.scale(transform.s, transform.s);
      }

      function prepareLayer(canvasdict) {
        var flip = canvasdict.layer == "B";
        for (var c of ["bg", "fab", "silk", "highlight"]) {
          prepareCanvas(canvasdict[c], flip, canvasdict.transform);
        }
      }

      function rotateVector(v, angle) {
        angle = deg2rad(angle);
        return [
          v[0] * Math.cos(angle) - v[1] * Math.sin(angle),
          v[0] * Math.sin(angle) + v[1] * Math.cos(angle),
        ];
      }

      function applyRotation(bbox) {
        var corners = [
          [bbox.minx, bbox.miny],
          [bbox.minx, bbox.maxy],
          [bbox.maxx, bbox.miny],
          [bbox.maxx, bbox.maxy],
        ];
        corners = corners.map((v) => rotateVector(v, settings.boardRotation));
        return {
          minx: corners.reduce((a, v) => Math.min(a, v[0]), Infinity),
          miny: corners.reduce((a, v) => Math.min(a, v[1]), Infinity),
          maxx: corners.reduce((a, v) => Math.max(a, v[0]), -Infinity),
          maxy: corners.reduce((a, v) => Math.max(a, v[1]), -Infinity),
        };
      }

      function recalcLayerScale(layerdict, width, height) {
        var bbox = applyRotation(pcbdata.edges_bbox);
        var scalefactor =
          0.98 *
          Math.min(
            width / (bbox.maxx - bbox.minx),
            height / (bbox.maxy - bbox.miny),
          );
        if (scalefactor < 0.1) {
          scalefactor = 1;
        }
        layerdict.transform.s = scalefactor;
        var flip = layerdict.layer == "B";
        if (flip) {
          layerdict.transform.x =
            -((bbox.maxx + bbox.minx) * scalefactor + width) * 0.5;
        } else {
          layerdict.transform.x =
            -((bbox.maxx + bbox.minx) * scalefactor - width) * 0.5;
        }
        layerdict.transform.y =
          -((bbox.maxy + bbox.miny) * scalefactor - height) * 0.5;
        for (var c of ["bg", "fab", "silk", "highlight"]) {
          canvas = layerdict[c];
          canvas.width = width;
          canvas.height = height;
          canvas.style.width = width / devicePixelRatio + "px";
          canvas.style.height = height / devicePixelRatio + "px";
        }
      }

      function redrawCanvas(layerdict) {
        prepareLayer(layerdict);
        drawBackground(layerdict);
        drawHighlightsOnLayer(layerdict);
      }

      function resizeCanvas(layerdict) {
        var canvasdivid = {
          F: "frontcanvas",
          B: "backcanvas",
        }[layerdict.layer];
        var width =
          document.getElementById(canvasdivid).clientWidth * devicePixelRatio;
        var height =
          document.getElementById(canvasdivid).clientHeight * devicePixelRatio;
        recalcLayerScale(layerdict, width, height);
        redrawCanvas(layerdict);
      }

      function resizeAll() {
        resizeCanvas(allcanvas.front);
        resizeCanvas(allcanvas.back);
      }

      function pointWithinDistanceToSegment(x, y, x1, y1, x2, y2, d) {
        var A = x - x1;
        var B = y - y1;
        var C = x2 - x1;
        var D = y2 - y1;

        var dot = A * C + B * D;
        var len_sq = C * C + D * D;
        var dx, dy;
        if (len_sq == 0) {
          // start and end of the segment coincide
          dx = x - x1;
          dy = y - y1;
        } else {
          var param = dot / len_sq;
          var xx, yy;
          if (param < 0) {
            xx = x1;
            yy = y1;
          } else if (param > 1) {
            xx = x2;
            yy = y2;
          } else {
            xx = x1 + param * C;
            yy = y1 + param * D;
          }
          dx = x - xx;
          dy = y - yy;
        }
        return dx * dx + dy * dy <= d * d;
      }

      function modulo(n, mod) {
        return ((n % mod) + mod) % mod;
      }

      function pointWithinDistanceToArc(
        x,
        y,
        xc,
        yc,
        radius,
        startangle,
        endangle,
        d,
      ) {
        var dx = x - xc;
        var dy = y - yc;
        var r_sq = dx * dx + dy * dy;
        var rmin = Math.max(0, radius - d);
        var rmax = radius + d;

        if (r_sq < rmin * rmin || r_sq > rmax * rmax) return false;

        var angle1 = modulo(deg2rad(startangle), 2 * Math.PI);
        var dx1 = xc + radius * Math.cos(angle1) - x;
        var dy1 = yc + radius * Math.sin(angle1) - y;
        if (dx1 * dx1 + dy1 * dy1 <= d * d) return true;

        var angle2 = modulo(deg2rad(endangle), 2 * Math.PI);
        var dx2 = xc + radius * Math.cos(angle2) - x;
        var dy2 = yc + radius * Math.sin(angle2) - y;
        if (dx2 * dx2 + dy2 * dy2 <= d * d) return true;

        var angle = modulo(Math.atan2(dy, dx), 2 * Math.PI);
        if (angle1 > angle2) return angle >= angle2 || angle <= angle1;
        else return angle >= angle1 && angle <= angle2;
      }

      function pointWithinPad(x, y, pad) {
        var v = [x - pad.pos[0], y - pad.pos[1]];
        v = rotateVector(v, pad.angle);
        if (pad.offset) {
          v[0] -= pad.offset[0];
          v[1] -= pad.offset[1];
        }
        return emptyContext2d.isPointInPath(getCachedPadPath(pad), ...v);
      }

      function netHitScan(layer, x, y) {
        // Check track segments
        if (settings.renderTracks && pcbdata.tracks) {
          for (var track of pcbdata.tracks[layer]) {
            if ("radius" in track) {
              if (
                pointWithinDistanceToArc(
                  x,
                  y,
                  ...track.center,
                  track.radius,
                  track.startangle,
                  track.endangle,
                  track.width / 2,
                )
              ) {
                return track.net;
              }
            } else {
              if (
                pointWithinDistanceToSegment(
                  x,
                  y,
                  ...track.start,
                  ...track.end,
                  track.width / 2,
                )
              ) {
                return track.net;
              }
            }
          }
        }
        // Check pads
        if (settings.renderPads) {
          for (var footprint of pcbdata.footprints) {
            for (var pad of footprint.pads) {
              if (pad.layers.includes(layer) && pointWithinPad(x, y, pad)) {
                return pad.net;
              }
            }
          }
        }
        return null;
      }

      function pointWithinFootprintBbox(x, y, bbox) {
        var v = [x - bbox.pos[0], y - bbox.pos[1]];
        v = rotateVector(v, bbox.angle);
        return (
          bbox.relpos[0] <= v[0] &&
          v[0] <= bbox.relpos[0] + bbox.size[0] &&
          bbox.relpos[1] <= v[1] &&
          v[1] <= bbox.relpos[1] + bbox.size[1]
        );
      }

      function bboxHitScan(layer, x, y) {
        var result = [];
        for (var i = 0; i < pcbdata.footprints.length; i++) {
          var footprint = pcbdata.footprints[i];
          if (footprint.layer == layer) {
            if (pointWithinFootprintBbox(x, y, footprint.bbox)) {
              result.push(i);
            }
          }
        }
        return result;
      }

      function handlePointerDown(e, layerdict) {
        if (e.button != 0 && e.button != 1) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();

        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        layerdict.pointerStates[e.pointerId] = {
          distanceTravelled: 0,
          lastX: e.offsetX,
          lastY: e.offsetY,
          downTime: Date.now(),
        };
      }

      function handleMouseClick(e, layerdict) {
        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        var x = e.offsetX;
        var y = e.offsetY;
        var t = layerdict.transform;
        if (layerdict.layer == "B") {
          x = ((devicePixelRatio * x) / t.zoom - t.panx + t.x) / -t.s;
        } else {
          x = ((devicePixelRatio * x) / t.zoom - t.panx - t.x) / t.s;
        }
        y = ((devicePixelRatio * y) / t.zoom - t.y - t.pany) / t.s;
        var v = rotateVector([x, y], -settings.boardRotation);
        if ("nets" in pcbdata) {
          var net = netHitScan(layerdict.layer, ...v);
          if (net !== highlightedNet) {
            netClicked(net);
          }
        }
        if (highlightedNet === null) {
          var footprints = bboxHitScan(layerdict.layer, ...v);
          if (footprints.length > 0) {
            footprintsClicked(footprints);
          }
        }
      }

      function handlePointerLeave(e, layerdict) {
        e.preventDefault();
        e.stopPropagation();

        if (!settings.redrawOnDrag) {
          redrawCanvas(layerdict);
        }

        delete layerdict.pointerStates[e.pointerId];
      }

      function resetTransform(layerdict) {
        layerdict.transform.panx = 0;
        layerdict.transform.pany = 0;
        layerdict.transform.zoom = 1;
        redrawCanvas(layerdict);
      }

      function handlePointerUp(e, layerdict) {
        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        e.preventDefault();
        e.stopPropagation();

        if (e.button == 2) {
          // Reset pan and zoom on right click.
          resetTransform(layerdict);
          layerdict.anotherPointerTapped = false;
          return;
        }

        // We haven't necessarily had a pointermove event since the interaction started, so make sure we update this now
        var ptr = layerdict.pointerStates[e.pointerId];
        ptr.distanceTravelled +=
          Math.abs(e.offsetX - ptr.lastX) + Math.abs(e.offsetY - ptr.lastY);

        if (
          e.button == 0 &&
          ptr.distanceTravelled < 10 &&
          Date.now() - ptr.downTime <= 500
        ) {
          if (Object.keys(layerdict.pointerStates).length == 1) {
            if (layerdict.anotherPointerTapped) {
              // This is the second pointer coming off of a two-finger tap
              resetTransform(layerdict);
            } else {
              // This is just a regular tap
              handleMouseClick(e, layerdict);
            }
            layerdict.anotherPointerTapped = false;
          } else {
            // This is the first finger coming off of what could become a two-finger tap
            layerdict.anotherPointerTapped = true;
          }
        } else {
          if (!settings.redrawOnDrag) {
            redrawCanvas(layerdict);
          }
          layerdict.anotherPointerTapped = false;
        }

        delete layerdict.pointerStates[e.pointerId];
      }

      function handlePointerMove(e, layerdict) {
        if (!layerdict.pointerStates.hasOwnProperty(e.pointerId)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();

        if (!e.hasOwnProperty("offsetX")) {
          // The polyfill doesn't set this properly
          e.offsetX = e.pageX - e.currentTarget.offsetLeft;
          e.offsetY = e.pageY - e.currentTarget.offsetTop;
        }

        var thisPtr = layerdict.pointerStates[e.pointerId];

        var dx = e.offsetX - thisPtr.lastX;
        var dy = e.offsetY - thisPtr.lastY;

        // If this number is low on pointer up, we count the action as a click
        thisPtr.distanceTravelled += Math.abs(dx) + Math.abs(dy);

        if (Object.keys(layerdict.pointerStates).length == 1) {
          // This is a simple drag
          layerdict.transform.panx +=
            (devicePixelRatio * dx) / layerdict.transform.zoom;
          layerdict.transform.pany +=
            (devicePixelRatio * dy) / layerdict.transform.zoom;
        } else if (Object.keys(layerdict.pointerStates).length == 2) {
          var otherPtr = Object.values(layerdict.pointerStates).filter(
            (ptr) => ptr != thisPtr,
          )[0];

          var oldDist = Math.sqrt(
            Math.pow(thisPtr.lastX - otherPtr.lastX, 2) +
              Math.pow(thisPtr.lastY - otherPtr.lastY, 2),
          );
          var newDist = Math.sqrt(
            Math.pow(e.offsetX - otherPtr.lastX, 2) +
              Math.pow(e.offsetY - otherPtr.lastY, 2),
          );

          var scaleFactor = newDist / oldDist;

          if (scaleFactor != NaN) {
            layerdict.transform.zoom *= scaleFactor;

            var zoomd = (1 - scaleFactor) / layerdict.transform.zoom;
            layerdict.transform.panx +=
              devicePixelRatio * otherPtr.lastX * zoomd;
            layerdict.transform.pany +=
              devicePixelRatio * otherPtr.lastY * zoomd;
          }
        }

        thisPtr.lastX = e.offsetX;
        thisPtr.lastY = e.offsetY;

        if (settings.redrawOnDrag) {
          redrawCanvas(layerdict);
        }
      }

      function handleMouseWheel(e, layerdict) {
        e.preventDefault();
        e.stopPropagation();
        var t = layerdict.transform;
        var wheeldelta = e.deltaY;
        if (e.deltaMode == 1) {
          // FF only, scroll by lines
          wheeldelta *= 30;
        } else if (e.deltaMode == 2) {
          wheeldelta *= 300;
        }
        var m = Math.pow(1.1, -wheeldelta / 40);
        // Limit amount of zoom per tick.
        if (m > 2) {
          m = 2;
        } else if (m < 0.5) {
          m = 0.5;
        }
        t.zoom *= m;
        var zoomd = (1 - m) / t.zoom;
        t.panx += devicePixelRatio * e.offsetX * zoomd;
        t.pany += devicePixelRatio * e.offsetY * zoomd;
        redrawCanvas(layerdict);
      }

      function addMouseHandlers(div, layerdict) {
        div.addEventListener("pointerdown", function (e) {
          handlePointerDown(e, layerdict);
        });
        div.addEventListener("pointermove", function (e) {
          handlePointerMove(e, layerdict);
        });
        div.addEventListener("pointerup", function (e) {
          handlePointerUp(e, layerdict);
        });
        var pointerleave = function (e) {
          handlePointerLeave(e, layerdict);
        };
        div.addEventListener("pointercancel", pointerleave);
        div.addEventListener("pointerleave", pointerleave);
        div.addEventListener("pointerout", pointerleave);

        div.onwheel = function (e) {
          handleMouseWheel(e, layerdict);
        };
        for (var element of [
          div,
          layerdict.bg,
          layerdict.fab,
          layerdict.silk,
          layerdict.highlight,
        ]) {
          element.addEventListener(
            "contextmenu",
            function (e) {
              e.preventDefault();
            },
            false,
          );
        }
      }

      function setRedrawOnDrag(value) {
        settings.redrawOnDrag = value;
        writeStorage("redrawOnDrag", value);
      }

      function setBoardRotation(value) {
        settings.boardRotation = value * 5;
        writeStorage("boardRotation", settings.boardRotation);
        document.getElementById("rotationDegree").textContent =
          settings.boardRotation;
        resizeAll();
      }

      function initRender() {
        allcanvas = {
          front: {
            transform: {
              x: 0,
              y: 0,
              s: 1,
              panx: 0,
              pany: 0,
              zoom: 1,
            },
            pointerStates: {},
            anotherPointerTapped: false,
            bg: document.getElementById("F_bg"),
            fab: document.getElementById("F_fab"),
            silk: document.getElementById("F_slk"),
            highlight: document.getElementById("F_hl"),
            layer: "F",
          },
          back: {
            transform: {
              x: 0,
              y: 0,
              s: 1,
              panx: 0,
              pany: 0,
              zoom: 1,
            },
            pointerStates: {},
            anotherPointerTapped: false,
            bg: document.getElementById("B_bg"),
            fab: document.getElementById("B_fab"),
            silk: document.getElementById("B_slk"),
            highlight: document.getElementById("B_hl"),
            layer: "B",
          },
        };
        addMouseHandlers(
          document.getElementById("frontcanvas"),
          allcanvas.front,
        );
        addMouseHandlers(document.getElementById("backcanvas"), allcanvas.back);
      }

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /*
       * Table reordering via Drag'n'Drop
       * Inspired by: https://htmldom.dev/drag-and-drop-table-column
       */

      function setBomHandlers() {
        const bom = document.getElementById("bomtable");

        let dragName;
        let placeHolderElements;
        let draggingElement;
        let forcePopulation;
        let xOffset;
        let yOffset;
        let wasDragged;

        const mouseUpHandler = function (e) {
          // Delete dragging element
          draggingElement.remove();

          // Make BOM selectable again
          bom.style.removeProperty("userSelect");

          // Remove listeners
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);

          if (wasDragged) {
            // Redraw whole BOM
            populateBomTable();
          }
        };

        const mouseMoveHandler = function (e) {
          // Notice the dragging
          wasDragged = true;

          // Make the dragged element visible
          draggingElement.style.removeProperty("display");

          // Set elements position to mouse position
          draggingElement.style.left = `${e.screenX - xOffset}px`;
          draggingElement.style.top = `${e.screenY - yOffset}px`;

          // Forced redrawing of BOM table
          if (forcePopulation) {
            forcePopulation = false;
            // Copy array
            phe = Array.from(placeHolderElements);
            // populate BOM table again
            populateBomHeader(dragName, phe);
            populateBomBody(dragName, phe);
          }

          // Set up array of hidden columns
          var hiddenColumns = Array.from(settings.hiddenColumns);
          // In the ungrouped mode, quantity don't exist
          if (settings.bommode === "ungrouped") hiddenColumns.push("Quantity");
          // If no checkbox fields can be found, we consider them hidden
          if (settings.checkboxes.length == 0) hiddenColumns.push("checkboxes");

          // Get table headers and group them into checkboxes, extrafields and normal headers
          const bh = document.getElementById("bomhead");
          headers = Array.from(bh.querySelectorAll("th"));
          headers.shift(); // numCol is not part of the columnOrder
          headerGroups = [];
          lastCompoundClass = null;
          for (i = 0; i < settings.columnOrder.length; i++) {
            cElem = settings.columnOrder[i];
            if (hiddenColumns.includes(cElem)) {
              // Hidden columns appear as a dummy element
              headerGroups.push([]);
              continue;
            }
            elem = headers.filter((e) => getColumnOrderName(e) === cElem)[0];
            if (elem.classList.contains("bom-checkbox")) {
              if (lastCompoundClass === "bom-checkbox") {
                cbGroup = headerGroups.pop();
                cbGroup.push(elem);
                headerGroups.push(cbGroup);
              } else {
                lastCompoundClass = "bom-checkbox";
                headerGroups.push([elem]);
              }
            } else {
              headerGroups.push([elem]);
            }
          }

          // Copy settings.columnOrder
          var columns = Array.from(settings.columnOrder);

          // Set up array with indices of hidden columns
          var hiddenIndices = hiddenColumns.map((e) =>
            settings.columnOrder.indexOf(e),
          );
          var dragIndex = columns.indexOf(dragName);
          var swapIndex = dragIndex;
          var swapDone = false;

          // Check if the current dragged element is swapable with the left or right element
          if (dragIndex > 0) {
            // Get left headers boundingbox
            swapIndex = dragIndex - 1;
            while (hiddenIndices.includes(swapIndex) && swapIndex > 0)
              swapIndex--;
            if (!hiddenIndices.includes(swapIndex)) {
              box = getBoundingClientRectFromMultiple(headerGroups[swapIndex]);
              if (e.clientX < box.left + window.scrollX + box.width / 2) {
                swapElement = columns[dragIndex];
                columns.splice(dragIndex, 1);
                columns.splice(swapIndex, 0, swapElement);
                forcePopulation = true;
                swapDone = true;
              }
            }
          }
          if (!swapDone && dragIndex < headerGroups.length - 1) {
            // Get right headers boundingbox
            swapIndex = dragIndex + 1;
            while (hiddenIndices.includes(swapIndex)) swapIndex++;
            if (swapIndex < headerGroups.length) {
              box = getBoundingClientRectFromMultiple(headerGroups[swapIndex]);
              if (e.clientX > box.left + window.scrollX + box.width / 2) {
                swapElement = columns[dragIndex];
                columns.splice(dragIndex, 1);
                columns.splice(swapIndex, 0, swapElement);
                forcePopulation = true;
                swapDone = true;
              }
            }
          }

          // Write back change to storage
          if (swapDone) {
            settings.columnOrder = columns;
            writeStorage("columnOrder", JSON.stringify(columns));
          }
        };

        const mouseDownHandler = function (e) {
          var target = e.target;
          if (target.tagName.toLowerCase() != "td")
            target = target.parentElement;

          // Used to check if a dragging has ever happened
          wasDragged = false;

          // Create new element which will be displayed as the dragged column
          draggingElement = document.createElement("div");
          draggingElement.classList.add("dragging");
          draggingElement.style.display = "none";
          draggingElement.style.position = "absolute";
          draggingElement.style.overflow = "hidden";

          // Get bomhead and bombody elements
          const bh = document.getElementById("bomhead");
          const bb = document.getElementById("bombody");

          // Get all compound headers for the current column
          var compoundHeaders;
          if (target.classList.contains("bom-checkbox")) {
            compoundHeaders = Array.from(
              bh.querySelectorAll("th.bom-checkbox"),
            );
          } else {
            compoundHeaders = [target];
          }

          // Create new table which will display the column
          var newTable = document.createElement("table");
          newTable.classList.add("bom");
          newTable.style.background = "white";
          draggingElement.append(newTable);

          // Create new header element
          var newHeader = document.createElement("thead");
          newTable.append(newHeader);

          // Set up array for storing all placeholder elements
          placeHolderElements = [];

          // Add all compound headers to the new thead element and placeholders
          compoundHeaders.forEach(function (h) {
            clone = cloneElementWithDimensions(h);
            newHeader.append(clone);
            placeHolderElements.push(clone);
          });

          // Create new body element
          var newBody = document.createElement("tbody");
          newTable.append(newBody);

          // Get indices for compound headers
          var idxs = compoundHeaders.map((e) => getBomTableHeaderIndex(e));

          // For each row in the BOM body...
          var rows = bb.querySelectorAll("tr");
          rows.forEach(function (row) {
            // ..get the cells for the compound column
            const tds = row.querySelectorAll("td");
            var copytds = idxs.map((i) => tds[i]);
            // Add them to the new element and the placeholders
            var newRow = document.createElement("tr");
            copytds.forEach(function (td) {
              clone = cloneElementWithDimensions(td);
              newRow.append(clone);
              placeHolderElements.push(clone);
            });
            newBody.append(newRow);
          });

          // Compute width for compound header
          var width = compoundHeaders.reduce(
            (acc, x) => acc + x.clientWidth,
            0,
          );
          draggingElement.style.width = `${width}px`;

          // Insert the new dragging element and disable selection on BOM
          bom.insertBefore(draggingElement, null);
          bom.style.userSelect = "none";

          // Determine the mouse position offset
          xOffset =
            e.screenX -
            compoundHeaders.reduce(
              (acc, x) => Math.min(acc, x.offsetLeft),
              compoundHeaders[0].offsetLeft,
            );
          yOffset = e.screenY - compoundHeaders[0].offsetTop;

          // Get name for the column in settings.columnOrder
          dragName = getColumnOrderName(target);

          // Change text and class for placeholder elements
          placeHolderElements = placeHolderElements.map(function (e) {
            newElem = cloneElementWithDimensions(e);
            newElem.textContent = "";
            newElem.classList.add("placeholder");
            return newElem;
          });

          // On next mouse move, the whole BOM needs to be redrawn to show the placeholders
          forcePopulation = true;

          // Add listeners for move and up on mouse
          document.addEventListener("mousemove", mouseMoveHandler);
          document.addEventListener("mouseup", mouseUpHandler);
        };

        // In netlist mode, there is nothing to reorder
        if (settings.bommode === "netlist") return;

        // Add mouseDownHandler to every column except the numCol
        bom.querySelectorAll("th").forEach(function (head) {
          if (!head.classList.contains("numCol")) {
            head.onmousedown = mouseDownHandler;
          }
        });
      }

      function getBoundingClientRectFromMultiple(elements) {
        var elems = Array.from(elements);

        if (elems.length == 0) return null;

        var box = elems.shift().getBoundingClientRect();

        elems.forEach(function (elem) {
          var elembox = elem.getBoundingClientRect();
          box.left = Math.min(elembox.left, box.left);
          box.top = Math.min(elembox.top, box.top);
          box.width += elembox.width;
          box.height = Math.max(elembox.height, box.height);
        });

        return box;
      }

      function cloneElementWithDimensions(elem) {
        var newElem = elem.cloneNode(true);
        newElem.style.height = window.getComputedStyle(elem).height;
        newElem.style.width = window.getComputedStyle(elem).width;
        return newElem;
      }

      function getBomTableHeaderIndex(elem) {
        const bh = document.getElementById("bomhead");
        const ths = Array.from(bh.querySelectorAll("th"));
        return ths.indexOf(elem);
      }

      function getColumnOrderName(elem) {
        var cname = elem.getAttribute("col_name");
        if (cname === "bom-checkbox") return "checkboxes";
        else return cname;
      }

      function resizableGrid(tablehead) {
        var cols = tablehead.firstElementChild.children;
        var rowWidth = tablehead.offsetWidth;

        for (var i = 1; i < cols.length; i++) {
          if (cols[i].classList.contains("bom-checkbox")) continue;
          cols[i].style.width =
            ((cols[i].clientWidth - paddingDiff(cols[i])) * 100) / rowWidth +
            "%";
        }

        for (var i = 1; i < cols.length - 1; i++) {
          var div = document.createElement("div");
          div.className = "column-width-handle";
          cols[i].appendChild(div);
          setListeners(div);
        }

        function setListeners(div) {
          var startX, curCol, nxtCol, curColWidth, nxtColWidth, rowWidth;

          div.addEventListener("mousedown", function (e) {
            e.preventDefault();
            e.stopPropagation();

            curCol = e.target.parentElement;
            nxtCol = curCol.nextElementSibling;
            startX = e.pageX;

            var padding = paddingDiff(curCol);

            rowWidth = curCol.parentElement.offsetWidth;
            curColWidth = curCol.clientWidth - padding;
            nxtColWidth = nxtCol.clientWidth - padding;
          });

          document.addEventListener("mousemove", function (e) {
            if (startX) {
              var diffX = e.pageX - startX;
              diffX = -Math.min(-diffX, curColWidth - 20);
              diffX = Math.min(diffX, nxtColWidth - 20);

              curCol.style.width =
                ((curColWidth + diffX) * 100) / rowWidth + "%";
              nxtCol.style.width =
                ((nxtColWidth - diffX) * 100) / rowWidth + "%";
              console.log(
                `${curColWidth + nxtColWidth} ${((curColWidth + diffX) * 100) / rowWidth + ((nxtColWidth - diffX) * 100) / rowWidth}`,
              );
            }
          });

          document.addEventListener("mouseup", function (e) {
            curCol = undefined;
            nxtCol = undefined;
            startX = undefined;
            nxtColWidth = undefined;
            curColWidth = undefined;
          });
        }

        function paddingDiff(col) {
          if (getStyleVal(col, "box-sizing") == "border-box") {
            return 0;
          }

          var padLeft = getStyleVal(col, "padding-left");
          var padRight = getStyleVal(col, "padding-right");
          return parseInt(padLeft) + parseInt(padRight);
        }

        function getStyleVal(elm, css) {
          return window.getComputedStyle(elm, null).getPropertyValue(css);
        }
      }

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
      /* DOM manipulation and misc code */

      var bomsplit;
      var canvassplit;
      var initDone = false;
      var bomSortFunction = null;
      var currentSortColumn = null;
      var currentSortOrder = null;
      var currentHighlightedRowId;
      var highlightHandlers = [];
      var footprintIndexToHandler = {};
      var netsToHandler = {};
      var markedFootprints = new Set();
      var highlightedFootprints = [];
      var highlightedNet = null;
      var lastClicked;

      function dbg(html) {
        dbgdiv.innerHTML = html;
      }

      function redrawIfInitDone() {
        if (initDone) {
          redrawCanvas(allcanvas.front);
          redrawCanvas(allcanvas.back);
        }
      }

      function padsVisible(value) {
        writeStorage("padsVisible", value);
        settings.renderPads = value;
        redrawIfInitDone();
      }

      function referencesVisible(value) {
        writeStorage("referencesVisible", value);
        settings.renderReferences = value;
        redrawIfInitDone();
      }

      function valuesVisible(value) {
        writeStorage("valuesVisible", value);
        settings.renderValues = value;
        redrawIfInitDone();
      }

      function tracksVisible(value) {
        writeStorage("tracksVisible", value);
        settings.renderTracks = value;
        redrawIfInitDone();
      }

      function zonesVisible(value) {
        writeStorage("zonesVisible", value);
        settings.renderZones = value;
        redrawIfInitDone();
      }

      function dnpOutline(value) {
        writeStorage("dnpOutline", value);
        settings.renderDnpOutline = value;
        redrawIfInitDone();
      }

      function setDarkMode(value) {
        if (value) {
          topmostdiv.classList.add("dark");
        } else {
          topmostdiv.classList.remove("dark");
        }
        writeStorage("darkmode", value);
        settings.darkMode = value;
        redrawIfInitDone();
      }

      function setShowBOMColumn(field, value) {
        if (field === "references") {
          var rl = document.getElementById("reflookup");
          rl.disabled = !value;
          if (!value) {
            rl.value = "";
            updateRefLookup("");
          }
        }

        var n = settings.hiddenColumns.indexOf(field);
        if (value) {
          if (n != -1) {
            settings.hiddenColumns.splice(n, 1);
          }
        } else {
          if (n == -1) {
            settings.hiddenColumns.push(field);
          }
        }

        writeStorage("hiddenColumns", JSON.stringify(settings.hiddenColumns));

        if (initDone) {
          populateBomTable();
        }

        redrawIfInitDone();
      }

      function setFullscreen(value) {
        if (value) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      }

      function fabricationVisible(value) {
        writeStorage("fabricationVisible", value);
        settings.renderFabrication = value;
        redrawIfInitDone();
      }

      function silkscreenVisible(value) {
        writeStorage("silkscreenVisible", value);
        settings.renderSilkscreen = value;
        redrawIfInitDone();
      }

      function setHighlightPin1(value) {
        writeStorage("highlightpin1", value);
        settings.highlightpin1 = value;
        redrawIfInitDone();
      }

      function getStoredCheckboxRefs(checkbox) {
        function convert(ref) {
          var intref = parseInt(ref);
          if (isNaN(intref)) {
            for (var i = 0; i < pcbdata.footprints.length; i++) {
              if (pcbdata.footprints[i].ref == ref) {
                return i;
              }
            }
            return -1;
          } else {
            return intref;
          }
        }
        if (!(checkbox in settings.checkboxStoredRefs)) {
          var val = readStorage("checkbox_" + checkbox);
          settings.checkboxStoredRefs[checkbox] = val ? val : "";
        }
        if (!settings.checkboxStoredRefs[checkbox]) {
          return new Set();
        } else {
          return new Set(
            settings.checkboxStoredRefs[checkbox]
              .split(",")
              .map((r) => convert(r))
              .filter((a) => a >= 0),
          );
        }
      }

      function getCheckboxState(checkbox, references) {
        var storedRefsSet = getStoredCheckboxRefs(checkbox);
        var currentRefsSet = new Set(references.map((r) => r[1]));
        // Get difference of current - stored
        var difference = new Set(currentRefsSet);
        for (ref of storedRefsSet) {
          difference.delete(ref);
        }
        if (difference.size == 0) {
          // All the current refs are stored
          return "checked";
        } else if (difference.size == currentRefsSet.size) {
          // None of the current refs are stored
          return "unchecked";
        } else {
          // Some of the refs are stored
          return "indeterminate";
        }
      }

      function setBomCheckboxState(checkbox, element, references) {
        var state = getCheckboxState(checkbox, references);
        element.checked = state == "checked";
        element.indeterminate = state == "indeterminate";
      }

      function createCheckboxChangeHandler(checkbox, references, row) {
        return function () {
          refsSet = getStoredCheckboxRefs(checkbox);
          var markWhenChecked = settings.markWhenChecked == checkbox;
          eventArgs = {
            checkbox: checkbox,
            refs: references,
          };
          if (this.checked) {
            // checkbox ticked
            for (var ref of references) {
              refsSet.add(ref[1]);
            }
            if (markWhenChecked) {
              row.classList.add("checked");
              for (var ref of references) {
                markedFootprints.add(ref[1]);
              }
              drawHighlights();
            }
            eventArgs.state = "checked";
          } else {
            // checkbox unticked
            for (var ref of references) {
              refsSet.delete(ref[1]);
            }
            if (markWhenChecked) {
              row.classList.remove("checked");
              for (var ref of references) {
                markedFootprints.delete(ref[1]);
              }
              drawHighlights();
            }
            eventArgs.state = "unchecked";
          }
          settings.checkboxStoredRefs[checkbox] = [...refsSet].join(",");
          writeStorage(
            "checkbox_" + checkbox,
            settings.checkboxStoredRefs[checkbox],
          );
          updateCheckboxStats(checkbox);
          EventHandler.emitEvent(
            IBOM_EVENT_TYPES.CHECKBOX_CHANGE_EVENT,
            eventArgs,
          );
        };
      }

      function clearHighlightedFootprints() {
        if (currentHighlightedRowId) {
          document
            .getElementById(currentHighlightedRowId)
            .classList.remove("highlighted");
          currentHighlightedRowId = null;
          highlightedFootprints = [];
          highlightedNet = null;
        }
      }

      function createRowHighlightHandler(rowid, refs, net) {
        return function () {
          if (currentHighlightedRowId) {
            if (currentHighlightedRowId == rowid) {
              return;
            }
            document
              .getElementById(currentHighlightedRowId)
              .classList.remove("highlighted");
          }
          document.getElementById(rowid).classList.add("highlighted");
          currentHighlightedRowId = rowid;
          highlightedFootprints = refs ? refs.map((r) => r[1]) : [];
          highlightedNet = net;
          drawHighlights();
          EventHandler.emitEvent(IBOM_EVENT_TYPES.HIGHLIGHT_EVENT, {
            rowid: rowid,
            refs: refs,
            net: net,
          });
        };
      }

      function entryMatches(entry) {
        if (settings.bommode == "netlist") {
          // entry is just a net name
          return entry.toLowerCase().indexOf(filter) >= 0;
        }
        // check refs
        if (!settings.hiddenColumns.includes("references")) {
          for (var ref of entry) {
            if (ref[0].toLowerCase().indexOf(filter) >= 0) {
              return true;
            }
          }
        }
        // check fields
        for (var i in config.fields) {
          var f = config.fields[i];
          if (!settings.hiddenColumns.includes(f)) {
            for (var ref of entry) {
              if (
                pcbdata.bom.fields[ref[1]][i].toLowerCase().indexOf(filter) >= 0
              ) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function findRefInEntry(entry) {
        return entry.filter((r) => r[0].toLowerCase() == reflookup);
      }

      function highlightFilter(s) {
        if (!filter) {
          return s;
        }
        var parts = s.toLowerCase().split(filter);
        if (parts.length == 1) {
          return s;
        }
        var r = "";
        var pos = 0;
        for (var i in parts) {
          if (i > 0) {
            r +=
              '<mark class="highlight">' +
              s.substring(pos, pos + filter.length) +
              "</mark>";
            pos += filter.length;
          }
          r += s.substring(pos, pos + parts[i].length);
          pos += parts[i].length;
        }
        return r;
      }

      function checkboxSetUnsetAllHandler(checkboxname) {
        return function () {
          var checkboxnum = 0;
          while (
            checkboxnum < settings.checkboxes.length &&
            settings.checkboxes[checkboxnum].toLowerCase() !=
              checkboxname.toLowerCase()
          ) {
            checkboxnum++;
          }
          if (checkboxnum >= settings.checkboxes.length) {
            return;
          }
          var allset = true;
          var checkbox;
          var row;
          for (row of bombody.childNodes) {
            checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
            if (!checkbox.checked || checkbox.indeterminate) {
              allset = false;
              break;
            }
          }
          for (row of bombody.childNodes) {
            checkbox = row.childNodes[checkboxnum + 1].childNodes[0];
            checkbox.checked = !allset;
            checkbox.indeterminate = false;
            checkbox.onchange();
          }
        };
      }

      function createColumnHeader(name, cls, comparator, is_checkbox = false) {
        var th = document.createElement("TH");
        th.innerHTML = name;
        th.classList.add(cls);
        if (is_checkbox) th.setAttribute("col_name", "bom-checkbox");
        else th.setAttribute("col_name", name);
        var span = document.createElement("SPAN");
        span.classList.add("sortmark");
        span.classList.add("none");
        th.appendChild(span);
        var spacer = document.createElement("div");
        spacer.className = "column-spacer";
        th.appendChild(spacer);
        spacer.onclick = function () {
          if (currentSortColumn && th !== currentSortColumn) {
            // Currently sorted by another column
            currentSortColumn.childNodes[1].classList.remove(currentSortOrder);
            currentSortColumn.childNodes[1].classList.add("none");
            currentSortColumn = null;
            currentSortOrder = null;
          }
          if (currentSortColumn && th === currentSortColumn) {
            // Already sorted by this column
            if (currentSortOrder == "asc") {
              // Sort by this column, descending order
              bomSortFunction = function (a, b) {
                return -comparator(a, b);
              };
              currentSortColumn.childNodes[1].classList.remove("asc");
              currentSortColumn.childNodes[1].classList.add("desc");
              currentSortOrder = "desc";
            } else {
              // Unsort
              bomSortFunction = null;
              currentSortColumn.childNodes[1].classList.remove("desc");
              currentSortColumn.childNodes[1].classList.add("none");
              currentSortColumn = null;
              currentSortOrder = null;
            }
          } else {
            // Sort by this column, ascending order
            bomSortFunction = comparator;
            currentSortColumn = th;
            currentSortColumn.childNodes[1].classList.remove("none");
            currentSortColumn.childNodes[1].classList.add("asc");
            currentSortOrder = "asc";
          }
          populateBomBody();
        };
        if (is_checkbox) {
          spacer.onclick = fancyDblClickHandler(
            spacer,
            spacer.onclick,
            checkboxSetUnsetAllHandler(name),
          );
        }
        return th;
      }

      function populateBomHeader(
        placeHolderColumn = null,
        placeHolderElements = null,
      ) {
        while (bomhead.firstChild) {
          bomhead.removeChild(bomhead.firstChild);
        }
        var tr = document.createElement("TR");
        var th = document.createElement("TH");
        th.classList.add("numCol");

        var vismenu = document.createElement("div");
        vismenu.id = "vismenu";
        vismenu.classList.add("menu");

        var visbutton = document.createElement("div");
        visbutton.classList.add("visbtn");
        visbutton.classList.add("hideonprint");

        var viscontent = document.createElement("div");
        viscontent.classList.add("menu-content");
        viscontent.id = "vismenu-content";

        settings.columnOrder.forEach((column) => {
          if (typeof column !== "string") return;

          // Skip empty columns
          if (column === "checkboxes" && settings.checkboxes.length == 0)
            return;
          else if (column === "Quantity" && settings.bommode == "ungrouped")
            return;

          var label = document.createElement("label");
          label.classList.add("menu-label");

          var input = document.createElement("input");
          input.classList.add("visibility_checkbox");
          input.type = "checkbox";
          input.onchange = function (e) {
            setShowBOMColumn(column, e.target.checked);
          };
          input.checked = !settings.hiddenColumns.includes(column);

          label.appendChild(input);
          if (column.length > 0)
            label.append(column[0].toUpperCase() + column.slice(1));

          viscontent.appendChild(label);
        });

        viscontent.childNodes[0].classList.add("menu-label-top");

        vismenu.appendChild(visbutton);
        if (settings.bommode != "netlist") {
          vismenu.appendChild(viscontent);
          th.appendChild(vismenu);
        }
        tr.appendChild(th);

        var checkboxCompareClosure = function (checkbox) {
          return (a, b) => {
            var stateA = getCheckboxState(checkbox, a);
            var stateB = getCheckboxState(checkbox, b);
            if (stateA > stateB) return -1;
            if (stateA < stateB) return 1;
            return 0;
          };
        };
        var stringFieldCompareClosure = function (fieldIndex) {
          return (a, b) => {
            var fa = pcbdata.bom.fields[a[0][1]][fieldIndex];
            var fb = pcbdata.bom.fields[b[0][1]][fieldIndex];
            if (fa != fb) return fa > fb ? 1 : -1;
            else return 0;
          };
        };
        var referenceRegex = /(?<prefix>[^0-9]+)(?<number>[0-9]+)/;
        var compareRefs = (a, b) => {
          var ra = referenceRegex.exec(a);
          var rb = referenceRegex.exec(b);
          if (ra === null || rb === null) {
            if (a != b) return a > b ? 1 : -1;
            return 0;
          } else {
            if (ra.groups.prefix != rb.groups.prefix) {
              return ra.groups.prefix > rb.groups.prefix ? 1 : -1;
            }
            if (ra.groups.number != rb.groups.number) {
              return parseInt(ra.groups.number) > parseInt(rb.groups.number)
                ? 1
                : -1;
            }
            return 0;
          }
        };
        if (settings.bommode == "netlist") {
          th = createColumnHeader("Net name", "bom-netname", (a, b) => {
            if (a > b) return -1;
            if (a < b) return 1;
            return 0;
          });
          tr.appendChild(th);
        } else {
          // Filter hidden columns
          var columns = settings.columnOrder.filter(
            (e) => !settings.hiddenColumns.includes(e),
          );
          var valueIndex = config.fields.indexOf("Value");
          var footprintIndex = config.fields.indexOf("Footprint");
          columns.forEach((column) => {
            if (column === placeHolderColumn) {
              var n = 1;
              if (column === "checkboxes") n = settings.checkboxes.length;
              for (i = 0; i < n; i++) {
                td = placeHolderElements.shift();
                tr.appendChild(td);
              }
              return;
            } else if (column === "checkboxes") {
              for (var checkbox of settings.checkboxes) {
                th = createColumnHeader(
                  checkbox,
                  "bom-checkbox",
                  checkboxCompareClosure(checkbox),
                  true,
                );
                tr.appendChild(th);
              }
            } else if (column === "References") {
              tr.appendChild(
                createColumnHeader("References", "references", (a, b) => {
                  var i = 0;
                  while (i < a.length && i < b.length) {
                    if (a[i] != b[i]) return compareRefs(a[i][0], b[i][0]);
                    i++;
                  }
                  return a.length - b.length;
                }),
              );
            } else if (column === "Value") {
              tr.appendChild(
                createColumnHeader("Value", "value", (a, b) => {
                  var ra = a[0][1],
                    rb = b[0][1];
                  return valueCompare(
                    pcbdata.bom.parsedValues[ra],
                    pcbdata.bom.parsedValues[rb],
                    pcbdata.bom.fields[ra][valueIndex],
                    pcbdata.bom.fields[rb][valueIndex],
                  );
                }),
              );
              return;
            } else if (column === "Footprint") {
              tr.appendChild(
                createColumnHeader(
                  "Footprint",
                  "footprint",
                  stringFieldCompareClosure(footprintIndex),
                ),
              );
            } else if (column === "Quantity" && settings.bommode == "grouped") {
              tr.appendChild(
                createColumnHeader("Quantity", "quantity", (a, b) => {
                  return a.length - b.length;
                }),
              );
            } else {
              // Other fields
              var i = config.fields.indexOf(column);
              if (i < 0) return;
              tr.appendChild(
                createColumnHeader(
                  column,
                  `field${i + 1}`,
                  stringFieldCompareClosure(i),
                ),
              );
            }
          });
        }
        bomhead.appendChild(tr);
      }

      function populateBomBody(
        placeholderColumn = null,
        placeHolderElements = null,
      ) {
        while (bom.firstChild) {
          bom.removeChild(bom.firstChild);
        }
        highlightHandlers = [];
        footprintIndexToHandler = {};
        netsToHandler = {};
        currentHighlightedRowId = null;
        var first = true;
        if (settings.bommode == "netlist") {
          bomtable = pcbdata.nets.slice();
        } else {
          switch (settings.canvaslayout) {
            case "F":
              bomtable = pcbdata.bom.F.slice();
              break;
            case "FB":
              bomtable = pcbdata.bom.both.slice();
              break;
            case "B":
              bomtable = pcbdata.bom.B.slice();
              break;
          }
          if (settings.bommode == "ungrouped") {
            // expand bom table
            expandedTable = [];
            for (var bomentry of bomtable) {
              for (var ref of bomentry) {
                expandedTable.push([ref]);
              }
            }
            bomtable = expandedTable;
          }
        }
        if (bomSortFunction) {
          bomtable = bomtable.sort(bomSortFunction);
        }
        for (var i in bomtable) {
          var bomentry = bomtable[i];
          if (filter && !entryMatches(bomentry)) {
            continue;
          }
          var references = null;
          var netname = null;
          var tr = document.createElement("TR");
          var td = document.createElement("TD");
          var rownum = +i + 1;
          tr.id = "bomrow" + rownum;
          td.textContent = rownum;
          tr.appendChild(td);
          if (settings.bommode == "netlist") {
            netname = bomentry;
            td = document.createElement("TD");
            td.innerHTML = highlightFilter(
              netname ? netname : "&lt;no net&gt;",
            );
            tr.appendChild(td);
          } else {
            if (reflookup) {
              references = findRefInEntry(bomentry);
              if (references.length == 0) {
                continue;
              }
            } else {
              references = bomentry;
            }
            // Filter hidden columns
            var columns = settings.columnOrder.filter(
              (e) => !settings.hiddenColumns.includes(e),
            );
            columns.forEach((column) => {
              if (column === placeholderColumn) {
                var n = 1;
                if (column === "checkboxes") n = settings.checkboxes.length;
                for (i = 0; i < n; i++) {
                  td = placeHolderElements.shift();
                  tr.appendChild(td);
                }
                return;
              } else if (column === "checkboxes") {
                for (var checkbox of settings.checkboxes) {
                  if (checkbox) {
                    td = document.createElement("TD");
                    var input = document.createElement("input");
                    input.type = "checkbox";
                    input.onchange = createCheckboxChangeHandler(
                      checkbox,
                      references,
                      tr,
                    );
                    setBomCheckboxState(checkbox, input, references);
                    if (input.checked && settings.markWhenChecked == checkbox) {
                      tr.classList.add("checked");
                    }
                    td.appendChild(input);
                    tr.appendChild(td);
                  }
                }
              } else if (column === "References") {
                td = document.createElement("TD");
                td.innerHTML = highlightFilter(
                  references.map((r) => r[0]).join(", "),
                );
                tr.appendChild(td);
              } else if (
                column === "Quantity" &&
                settings.bommode == "grouped"
              ) {
                // Quantity
                td = document.createElement("TD");
                td.textContent = references.length;
                tr.appendChild(td);
              } else {
                // All the other fields
                var field_index = config.fields.indexOf(column);
                if (field_index < 0) return;
                var valueSet = new Set();
                references
                  .map((r) => r[1])
                  .forEach((id) =>
                    valueSet.add(pcbdata.bom.fields[id][field_index]),
                  );
                td = document.createElement("TD");
                td.innerHTML = highlightFilter(Array.from(valueSet).join(", "));
                tr.appendChild(td);
              }
            });
          }
          bom.appendChild(tr);
          var handler = createRowHighlightHandler(tr.id, references, netname);
          tr.onmousemove = handler;
          highlightHandlers.push({
            id: tr.id,
            handler: handler,
          });
          if (references !== null) {
            for (var refIndex of references.map((r) => r[1])) {
              footprintIndexToHandler[refIndex] = handler;
            }
          }
          if (netname !== null) {
            netsToHandler[netname] = handler;
          }
          if ((filter || reflookup) && first) {
            handler();
            first = false;
          }
        }
        EventHandler.emitEvent(IBOM_EVENT_TYPES.BOM_BODY_CHANGE_EVENT, {
          filter: filter,
          reflookup: reflookup,
          checkboxes: settings.checkboxes,
          bommode: settings.bommode,
        });
      }

      function highlightPreviousRow() {
        if (!currentHighlightedRowId) {
          highlightHandlers[highlightHandlers.length - 1].handler();
        } else {
          if (
            highlightHandlers.length > 1 &&
            highlightHandlers[0].id == currentHighlightedRowId
          ) {
            highlightHandlers[highlightHandlers.length - 1].handler();
          } else {
            for (var i = 0; i < highlightHandlers.length - 1; i++) {
              if (highlightHandlers[i + 1].id == currentHighlightedRowId) {
                highlightHandlers[i].handler();
                break;
              }
            }
          }
        }
        smoothScrollToRow(currentHighlightedRowId);
      }

      function highlightNextRow() {
        if (!currentHighlightedRowId) {
          highlightHandlers[0].handler();
        } else {
          if (
            highlightHandlers.length > 1 &&
            highlightHandlers[highlightHandlers.length - 1].id ==
              currentHighlightedRowId
          ) {
            highlightHandlers[0].handler();
          } else {
            for (var i = 1; i < highlightHandlers.length; i++) {
              if (highlightHandlers[i - 1].id == currentHighlightedRowId) {
                highlightHandlers[i].handler();
                break;
              }
            }
          }
        }
        smoothScrollToRow(currentHighlightedRowId);
      }

      function populateBomTable() {
        populateBomHeader();
        populateBomBody();
        setBomHandlers();
        resizableGrid(bomhead);
      }

      function footprintsClicked(footprintIndexes) {
        var lastClickedIndex = footprintIndexes.indexOf(lastClicked);
        for (var i = 1; i <= footprintIndexes.length; i++) {
          var refIndex =
            footprintIndexes[(lastClickedIndex + i) % footprintIndexes.length];
          if (refIndex in footprintIndexToHandler) {
            lastClicked = refIndex;
            footprintIndexToHandler[refIndex]();
            smoothScrollToRow(currentHighlightedRowId);
            break;
          }
        }
      }

      function netClicked(net) {
        if (net in netsToHandler) {
          netsToHandler[net]();
          smoothScrollToRow(currentHighlightedRowId);
        } else {
          clearHighlightedFootprints();
          highlightedNet = net;
          drawHighlights();
        }
      }

      function updateFilter(input) {
        filter = input.toLowerCase();
        populateBomTable();
      }

      function updateRefLookup(input) {
        reflookup = input.toLowerCase();
        populateBomTable();
      }

      function changeCanvasLayout(layout) {
        document.getElementById("fl-btn").classList.remove("depressed");
        document.getElementById("fb-btn").classList.remove("depressed");
        document.getElementById("bl-btn").classList.remove("depressed");
        switch (layout) {
          case "F":
            document.getElementById("fl-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.collapse(1);
            }
            break;
          case "B":
            document.getElementById("bl-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.collapse(0);
            }
            break;
          default:
            document.getElementById("fb-btn").classList.add("depressed");
            if (settings.bomlayout != "bom-only") {
              canvassplit.setSizes([50, 50]);
            }
        }
        settings.canvaslayout = layout;
        writeStorage("canvaslayout", layout);
        resizeAll();
        changeBomMode(settings.bommode);
      }

      function populateMetadata() {
        document.getElementById("title").innerHTML = pcbdata.metadata.title;
        document.getElementById("revision").innerHTML =
          "Rev: " + pcbdata.metadata.revision;
        document.getElementById("company").innerHTML = pcbdata.metadata.company;
        document.getElementById("filedate").innerHTML = pcbdata.metadata.date;
        if (pcbdata.metadata.title != "") {
          document.title = pcbdata.metadata.title + " BOM";
        }
        // Calculate board stats
        var fp_f = 0,
          fp_b = 0,
          pads_f = 0,
          pads_b = 0,
          pads_th = 0;
        for (var i = 0; i < pcbdata.footprints.length; i++) {
          if (pcbdata.bom.skipped.includes(i)) continue;
          var mod = pcbdata.footprints[i];
          if (mod.layer == "F") {
            fp_f++;
          } else {
            fp_b++;
          }
          for (var pad of mod.pads) {
            if (pad.type == "th") {
              pads_th++;
            } else {
              if (pad.layers.includes("F")) {
                pads_f++;
              }
              if (pad.layers.includes("B")) {
                pads_b++;
              }
            }
          }
        }
        document.getElementById("stats-components-front").innerHTML = fp_f;
        document.getElementById("stats-components-back").innerHTML = fp_b;
        document.getElementById("stats-components-total").innerHTML =
          fp_f + fp_b;
        document.getElementById("stats-groups-front").innerHTML =
          pcbdata.bom.F.length;
        document.getElementById("stats-groups-back").innerHTML =
          pcbdata.bom.B.length;
        document.getElementById("stats-groups-total").innerHTML =
          pcbdata.bom.both.length;
        document.getElementById("stats-smd-pads-front").innerHTML = pads_f;
        document.getElementById("stats-smd-pads-back").innerHTML = pads_b;
        document.getElementById("stats-smd-pads-total").innerHTML =
          pads_f + pads_b;
        document.getElementById("stats-th-pads").innerHTML = pads_th;
        // Update version string
        document.getElementById("github-link").innerHTML =
          "InteractiveHtmlBom&nbsp;" +
          /^v\d+\.\d+/.exec(pcbdata.ibom_version)[0];
      }

      function changeBomLayout(layout) {
        document.getElementById("bom-btn").classList.remove("depressed");
        document.getElementById("lr-btn").classList.remove("depressed");
        document.getElementById("tb-btn").classList.remove("depressed");
        switch (layout) {
          case "bom-only":
            document.getElementById("bom-btn").classList.add("depressed");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            document.getElementById("frontcanvas").style.display = "none";
            document.getElementById("backcanvas").style.display = "none";
            document.getElementById("bot").style.height = "";
            break;
          case "top-bottom":
            document.getElementById("tb-btn").classList.add("depressed");
            document.getElementById("frontcanvas").style.display = "";
            document.getElementById("backcanvas").style.display = "";
            document.getElementById("bot").style.height = "calc(100% - 80px)";
            document
              .getElementById("bomdiv")
              .classList.remove("split-horizontal");
            document
              .getElementById("canvasdiv")
              .classList.remove("split-horizontal");
            document
              .getElementById("frontcanvas")
              .classList.add("split-horizontal");
            document
              .getElementById("backcanvas")
              .classList.add("split-horizontal");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            bomsplit = Split(["#bomdiv", "#canvasdiv"], {
              sizes: [50, 50],
              onDragEnd: resizeAll,
              direction: "vertical",
              gutterSize: 5,
            });
            canvassplit = Split(["#frontcanvas", "#backcanvas"], {
              sizes: [50, 50],
              gutterSize: 5,
              onDragEnd: resizeAll,
            });
            break;
          case "left-right":
            document.getElementById("lr-btn").classList.add("depressed");
            document.getElementById("frontcanvas").style.display = "";
            document.getElementById("backcanvas").style.display = "";
            document.getElementById("bot").style.height = "calc(100% - 80px)";
            document.getElementById("bomdiv").classList.add("split-horizontal");
            document
              .getElementById("canvasdiv")
              .classList.add("split-horizontal");
            document
              .getElementById("frontcanvas")
              .classList.remove("split-horizontal");
            document
              .getElementById("backcanvas")
              .classList.remove("split-horizontal");
            if (bomsplit) {
              bomsplit.destroy();
              bomsplit = null;
              canvassplit.destroy();
              canvassplit = null;
            }
            bomsplit = Split(["#bomdiv", "#canvasdiv"], {
              sizes: [50, 50],
              onDragEnd: resizeAll,
              gutterSize: 5,
            });
            canvassplit = Split(["#frontcanvas", "#backcanvas"], {
              sizes: [50, 50],
              gutterSize: 5,
              direction: "vertical",
              onDragEnd: resizeAll,
            });
        }
        settings.bomlayout = layout;
        writeStorage("bomlayout", layout);
        changeCanvasLayout(settings.canvaslayout);
      }

      function changeBomMode(mode) {
        document
          .getElementById("bom-grouped-btn")
          .classList.remove("depressed");
        document
          .getElementById("bom-ungrouped-btn")
          .classList.remove("depressed");
        document
          .getElementById("bom-netlist-btn")
          .classList.remove("depressed");
        var chkbxs = document.getElementsByClassName("visibility_checkbox");

        switch (mode) {
          case "grouped":
            document
              .getElementById("bom-grouped-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = false;
            }
            break;
          case "ungrouped":
            document
              .getElementById("bom-ungrouped-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = false;
            }
            break;
          case "netlist":
            document
              .getElementById("bom-netlist-btn")
              .classList.add("depressed");
            for (var i = 0; i < chkbxs.length; i++) {
              chkbxs[i].disabled = true;
            }
        }

        writeStorage("bommode", mode);
        if (mode != settings.bommode) {
          settings.bommode = mode;
          bomSortFunction = null;
          currentSortColumn = null;
          currentSortOrder = null;
          clearHighlightedFootprints();
        }
        populateBomTable();
      }

      function focusFilterField() {
        focusInputField(document.getElementById("filter"));
      }

      function focusRefLookupField() {
        focusInputField(document.getElementById("reflookup"));
      }

      function toggleBomCheckbox(bomrowid, checkboxnum) {
        if (!bomrowid || checkboxnum > settings.checkboxes.length) {
          return;
        }
        var bomrow = document.getElementById(bomrowid);
        var checkbox = bomrow.childNodes[checkboxnum].childNodes[0];
        checkbox.checked = !checkbox.checked;
        checkbox.indeterminate = false;
        checkbox.onchange();
      }

      function checkBomCheckbox(bomrowid, checkboxname) {
        var checkboxnum = 0;
        while (
          checkboxnum < settings.checkboxes.length &&
          settings.checkboxes[checkboxnum].toLowerCase() !=
            checkboxname.toLowerCase()
        ) {
          checkboxnum++;
        }
        if (!bomrowid || checkboxnum >= settings.checkboxes.length) {
          return;
        }
        var bomrow = document.getElementById(bomrowid);
        var checkbox = bomrow.childNodes[checkboxnum + 1].childNodes[0];
        checkbox.checked = true;
        checkbox.indeterminate = false;
        checkbox.onchange();
      }

      function setBomCheckboxes(value) {
        writeStorage("bomCheckboxes", value);
        settings.checkboxes = value
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e);
        prepCheckboxes();
        populateMarkWhenCheckedOptions();
        setMarkWhenChecked(settings.markWhenChecked);
      }

      function setMarkWhenChecked(value) {
        writeStorage("markWhenChecked", value);
        settings.markWhenChecked = value;
        markedFootprints.clear();
        for (var ref of value ? getStoredCheckboxRefs(value) : []) {
          markedFootprints.add(ref);
        }
        populateBomTable();
        drawHighlights();
      }

      function prepCheckboxes() {
        var table = document.getElementById("checkbox-stats");
        while (table.childElementCount > 1) {
          table.removeChild(table.lastChild);
        }
        if (settings.checkboxes.length) {
          table.style.display = "";
        } else {
          table.style.display = "none";
        }
        for (var checkbox of settings.checkboxes) {
          var tr = document.createElement("TR");
          var td = document.createElement("TD");
          td.innerHTML = checkbox;
          tr.appendChild(td);
          td = document.createElement("TD");
          td.id = "checkbox-stats-" + checkbox;
          var progressbar = document.createElement("div");
          progressbar.classList.add("bar");
          td.appendChild(progressbar);
          var text = document.createElement("div");
          text.classList.add("text");
          td.appendChild(text);
          tr.appendChild(td);
          table.appendChild(tr);
          updateCheckboxStats(checkbox);
        }
      }

      function populateMarkWhenCheckedOptions() {
        var container = document.getElementById("markWhenCheckedContainer");

        if (settings.checkboxes.length == 0) {
          container.parentElement.style.display = "none";
          return;
        }

        container.innerHTML = "";
        container.parentElement.style.display = "inline-block";

        function createOption(name, displayName) {
          var id = "markWhenChecked-" + name;

          var div = document.createElement("div");
          div.classList.add("radio-container");

          var input = document.createElement("input");
          input.type = "radio";
          input.name = "markWhenChecked";
          input.value = name;
          input.id = id;
          input.onchange = () => setMarkWhenChecked(name);
          div.appendChild(input);

          // Preserve the selected element when the checkboxes change
          if (name == settings.markWhenChecked) {
            input.checked = true;
          }

          var label = document.createElement("label");
          label.innerHTML = displayName;
          label.htmlFor = id;
          div.appendChild(label);

          container.appendChild(div);
        }
        createOption("", "None");
        for (var checkbox of settings.checkboxes) {
          createOption(checkbox, checkbox);
        }
      }

      function updateCheckboxStats(checkbox) {
        var checked = getStoredCheckboxRefs(checkbox).size;
        var total = pcbdata.footprints.length - pcbdata.bom.skipped.length;
        var percent = (checked * 100.0) / total;
        var td = document.getElementById("checkbox-stats-" + checkbox);
        td.firstChild.style.width = percent + "%";
        td.lastChild.innerHTML =
          checked + "/" + total + " (" + Math.round(percent) + "%)";
      }

      function constrain(number, min, max) {
        return Math.min(Math.max(parseInt(number), min), max);
      }

      document.onkeydown = function (e) {
        switch (e.key) {
          case "n":
            if (document.activeElement.type == "text") {
              return;
            }
            if (currentHighlightedRowId !== null) {
              checkBomCheckbox(currentHighlightedRowId, "placed");
              highlightNextRow();
              e.preventDefault();
            }
            break;
          case "ArrowUp":
            highlightPreviousRow();
            e.preventDefault();
            break;
          case "ArrowDown":
            highlightNextRow();
            e.preventDefault();
            break;
          case "ArrowLeft":
          case "ArrowRight":
            if (document.activeElement.type != "text") {
              e.preventDefault();
              let boardRotationElement =
                document.getElementById("boardRotation");
              settings.boardRotation = parseInt(boardRotationElement.value); // degrees / 5
              if (e.key == "ArrowLeft") {
                settings.boardRotation += 3; // 15 degrees
              } else {
                settings.boardRotation -= 3;
              }
              settings.boardRotation = constrain(
                settings.boardRotation,
                boardRotationElement.min,
                boardRotationElement.max,
              );
              boardRotationElement.value = settings.boardRotation;
              setBoardRotation(settings.boardRotation);
            }
            break;
          default:
            break;
        }
        if (e.altKey) {
          switch (e.key) {
            case "f":
              focusFilterField();
              e.preventDefault();
              break;
            case "r":
              focusRefLookupField();
              e.preventDefault();
              break;
            case "z":
              changeBomLayout("bom-only");
              e.preventDefault();
              break;
            case "x":
              changeBomLayout("left-right");
              e.preventDefault();
              break;
            case "c":
              changeBomLayout("top-bottom");
              e.preventDefault();
              break;
            case "v":
              changeCanvasLayout("F");
              e.preventDefault();
              break;
            case "b":
              changeCanvasLayout("FB");
              e.preventDefault();
              break;
            case "n":
              changeCanvasLayout("B");
              e.preventDefault();
              break;
            default:
              break;
          }
          if (e.key >= "1" && e.key <= "9") {
            toggleBomCheckbox(currentHighlightedRowId, parseInt(e.key));
            e.preventDefault();
          }
        }
      };

      function hideNetlistButton() {
        document
          .getElementById("bom-ungrouped-btn")
          .classList.remove("middle-button");
        document
          .getElementById("bom-ungrouped-btn")
          .classList.add("right-most-button");
        document.getElementById("bom-netlist-btn").style.display = "none";
      }

      window.onload = function (e) {
        initUtils();
        initRender();
        initStorage();
        initDefaults();
        cleanGutters();
        populateMetadata();
        dbgdiv = document.getElementById("dbg");
        bom = document.getElementById("bombody");
        bomhead = document.getElementById("bomhead");
        filter = "";
        reflookup = "";
        if (!("nets" in pcbdata)) {
          hideNetlistButton();
        }
        initDone = true;
        setBomCheckboxes(document.getElementById("bomCheckboxes").value);
        // Triggers render
        changeBomLayout(settings.bomlayout);

        // Users may leave fullscreen without touching the checkbox. Uncheck.
        document.addEventListener("fullscreenchange", () => {
          if (!document.fullscreenElement)
            document.getElementById("fullscreenCheckbox").checked = false;
        });
      };

      window.onresize = resizeAll;
      window.matchMedia("print").addListener(resizeAll);

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////

      ///////////////////////////////////////////////
    </script>
  </head>

  <body>
    <div id="topmostdiv" class="topmostdiv">
      <div id="top">
        <div style="float: right; height: 100%">
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="menubtn"></button>
            <div class="menu-content">
              <label
                class="menu-label menu-label-top"
                style="width: calc(50% - 18px)"
              >
                <input
                  id="darkmodeCheckbox"
                  type="checkbox"
                  onchange="setDarkMode(this.checked)"
                />
                Dark mode </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label menu-label-top"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="fullscreenCheckbox"
                  type="checkbox"
                  onchange="setFullscreen(this.checked)"
                />
                Full Screen
              </label>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="fabricationCheckbox"
                  type="checkbox"
                  checked
                  onchange="fabricationVisible(this.checked)"
                />
                Fab layer </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="silkscreenCheckbox"
                  type="checkbox"
                  checked
                  onchange="silkscreenVisible(this.checked)"
                />
                Silkscreen
              </label>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="referencesCheckbox"
                  type="checkbox"
                  checked
                  onchange="referencesVisible(this.checked)"
                />
                References </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="valuesCheckbox"
                  type="checkbox"
                  checked
                  onchange="valuesVisible(this.checked)"
                />
                Values
              </label>
              <div id="tracksAndZonesCheckboxes">
                <label class="menu-label" style="width: calc(50% - 18px)">
                  <input
                    id="tracksCheckbox"
                    type="checkbox"
                    checked
                    onchange="tracksVisible(this.checked)"
                  />
                  Tracks </label
                ><!-- This comment eats space! All of it!
            --><label
                  class="menu-label"
                  style="width: calc(50% - 17px); border-left: 0"
                >
                  <input
                    id="zonesCheckbox"
                    type="checkbox"
                    checked
                    onchange="zonesVisible(this.checked)"
                  />
                  Zones
                </label>
              </div>
              <label class="menu-label" style="width: calc(50% - 18px)">
                <input
                  id="padsCheckbox"
                  type="checkbox"
                  checked
                  onchange="padsVisible(this.checked)"
                />
                Pads </label
              ><!-- This comment eats space! All of it!
          --><label
                class="menu-label"
                style="width: calc(50% - 17px); border-left: 0"
              >
                <input
                  id="dnpOutlineCheckbox"
                  type="checkbox"
                  checked
                  onchange="dnpOutline(this.checked)"
                />
                DNP outlined
              </label>
              <label class="menu-label">
                <input
                  id="highlightpin1Checkbox"
                  type="checkbox"
                  onchange="setHighlightPin1(this.checked)"
                />
                Highlight first pin
              </label>
              <label class="menu-label">
                <input
                  id="dragCheckbox"
                  type="checkbox"
                  checked
                  onchange="setRedrawOnDrag(this.checked)"
                />
                Continuous redraw on drag
              </label>
              <label class="menu-label">
                <span>Board rotation</span>
                <span style="float: right"
                  ><span id="rotationDegree">0</span>&#176;</span
                >
                <input
                  id="boardRotation"
                  type="range"
                  min="-36"
                  max="36"
                  value="0"
                  class="slider"
                  oninput="setBoardRotation(this.value)"
                />
              </label>
              <label class="menu-label">
                <div style="margin-left: 5px">Bom checkboxes</div>
                <input
                  id="bomCheckboxes"
                  class="menu-textbox"
                  type="text"
                  oninput="setBomCheckboxes(this.value)"
                />
              </label>
              <label class="menu-label">
                <div style="margin-left: 5px">Mark when checked</div>
                <div id="markWhenCheckedContainer"></div>
              </label>
              <label class="menu-label">
                <span class="shameless-plug">
                  <span>Created using</span>
                  <a
                    id="github-link"
                    target="blank"
                    href="https://github.com/openscopeproject/InteractiveHtmlBom"
                    >InteractiveHtmlBom</a
                  >
                  <a
                    target="blank"
                    title="Mouse and keyboard help"
                    href="https://github.com/openscopeproject/InteractiveHtmlBom/wiki/Usage#bom-page-mouse-actions"
                    style="text-decoration: none"
                    ><label class="help-link">?</label></a
                  >
                </span>
              </label>
            </div>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="fl-btn"
              class="left-most-button"
              onclick="changeCanvasLayout('F')"
              title="Front only"
            >
              F
            </button>
            <button
              id="fb-btn"
              class="middle-button"
              onclick="changeCanvasLayout('FB')"
              title="Front and Back"
            >
              FB
            </button>
            <button
              id="bl-btn"
              class="right-most-button"
              onclick="changeCanvasLayout('B')"
              title="Back only"
            >
              B
            </button>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="bom-btn"
              class="left-most-button"
              onclick="changeBomLayout('bom-only')"
              title="BOM only"
            ></button>
            <button
              id="lr-btn"
              class="middle-button"
              onclick="changeBomLayout('left-right')"
              title="BOM left, drawings right"
            ></button>
            <button
              id="tb-btn"
              class="right-most-button"
              onclick="changeBomLayout('top-bottom')"
              title="BOM top, drawings bot"
            ></button>
          </div>
          <div
            class="button-container hideonprint"
            style="float: right; position: relative; top: 8px"
          >
            <button
              id="bom-grouped-btn"
              class="left-most-button"
              onclick="changeBomMode('grouped')"
              title="Grouped BOM"
            ></button>
            <button
              id="bom-ungrouped-btn"
              class="middle-button"
              onclick="changeBomMode('ungrouped')"
              title="Ungrouped BOM"
            ></button>
            <button
              id="bom-netlist-btn"
              class="right-most-button"
              onclick="changeBomMode('netlist')"
              title="Netlist"
            ></button>
          </div>
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="statsbtn"></button>
            <div class="menu-content">
              <table class="stats">
                <tbody>
                  <tr>
                    <td width="40%">Board stats</td>
                    <td>Front</td>
                    <td>Back</td>
                    <td>Total</td>
                  </tr>
                  <tr>
                    <td>Components</td>
                    <td id="stats-components-front">~</td>
                    <td id="stats-components-back">~</td>
                    <td id="stats-components-total">~</td>
                  </tr>
                  <tr>
                    <td>Groups</td>
                    <td id="stats-groups-front">~</td>
                    <td id="stats-groups-back">~</td>
                    <td id="stats-groups-total">~</td>
                  </tr>
                  <tr>
                    <td>SMD pads</td>
                    <td id="stats-smd-pads-front">~</td>
                    <td id="stats-smd-pads-back">~</td>
                    <td id="stats-smd-pads-total">~</td>
                  </tr>
                  <tr>
                    <td>TH pads</td>
                    <td colspan="3" id="stats-th-pads">~</td>
                  </tr>
                </tbody>
              </table>
              <table class="stats">
                <col width="40%" />
                <col />
                <tbody id="checkbox-stats">
                  <tr>
                    <td colspan="2" style="border-top: 0">Checkboxes</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="hideonprint menu" style="float: right; top: 8px">
            <button class="iobtn"></button>
            <div class="menu-content">
              <div class="menu-label menu-label-top">
                <div style="margin-left: 5px">Save board image</div>
                <div class="flexbox">
                  <input
                    id="render-save-width"
                    class="menu-textbox"
                    type="text"
                    value="1000"
                    placeholder="Width"
                    style="flex-grow: 1; width: 50px"
                    oninput="validateSaveImgDimension(this)"
                  />
                  <span>X</span>
                  <input
                    id="render-save-height"
                    class="menu-textbox"
                    type="text"
                    value="1000"
                    placeholder="Height"
                    style="flex-grow: 1; width: 50px"
                    oninput="validateSaveImgDimension(this)"
                  />
                </div>
                <label>
                  <input id="render-save-transparent" type="checkbox" />
                  Transparent background
                </label>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveImage('F')">
                    Front
                  </button>
                  <button class="savebtn" onclick="saveImage('B')">Back</button>
                </div>
              </div>
              <div class="menu-label">
                <span style="margin-left: 5px">Config and checkbox state</span>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveSettings()">
                    Export
                  </button>
                  <button class="savebtn" onclick="loadSettings()">
                    Import
                  </button>
                </div>
              </div>
              <div class="menu-label">
                <span style="margin-left: 5px">Save bom table as</span>
                <div class="flexbox">
                  <button class="savebtn" onclick="saveBomTable('csv')">
                    csv
                  </button>
                  <button class="savebtn" onclick="saveBomTable('txt')">
                    txt
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div id="fileinfodiv" style="overflow: auto">
          <table class="fileinfo">
            <tbody>
              <tr>
                <td id="title" class="title" style="width: 70%">Title</td>
                <td id="revision" class="title" style="width: 30%">Revision</td>
              </tr>
              <tr>
                <td id="company">Company</td>
                <td id="filedate">Date</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div id="bot" class="split" style="height: calc(100% - 80px)">
        <div id="bomdiv" class="split split-horizontal">
          <div style="width: 100%">
            <input
              id="reflookup"
              class="textbox searchbox reflookup hideonprint"
              type="text"
              placeholder="Ref lookup"
              oninput="updateRefLookup(this.value)"
            />
            <input
              id="filter"
              class="textbox searchbox filter hideonprint"
              type="text"
              placeholder="Filter"
              oninput="updateFilter(this.value)"
            />
            <div
              class="button-container hideonprint"
              style="float: left; margin: 0"
            >
              <button
                id="copy"
                title="Copy bom table to clipboard"
                onclick="saveBomTable('clipboard')"
              ></button>
            </div>
          </div>
          <div id="dbg"></div>
          <table class="bom" id="bomtable">
            <thead id="bomhead"></thead>
            <tbody id="bombody"></tbody>
          </table>
        </div>
        <div id="canvasdiv" class="split split-horizontal">
          <div
            id="frontcanvas"
            class="split"
            touch-action="none"
            style="overflow: hidden"
          >
            <div style="position: relative; width: 100%; height: 100%">
              <canvas
                id="F_bg"
                style="position: absolute; left: 0; top: 0; z-index: 0"
              ></canvas>
              <canvas
                id="F_fab"
                style="position: absolute; left: 0; top: 0; z-index: 1"
              ></canvas>
              <canvas
                id="F_slk"
                style="position: absolute; left: 0; top: 0; z-index: 2"
              ></canvas>
              <canvas
                id="F_hl"
                style="position: absolute; left: 0; top: 0; z-index: 3"
              ></canvas>
            </div>
          </div>
          <div
            id="backcanvas"
            class="split"
            touch-action="none"
            style="overflow: hidden"
          >
            <div style="position: relative; width: 100%; height: 100%">
              <canvas
                id="B_bg"
                style="position: absolute; left: 0; top: 0; z-index: 0"
              ></canvas>
              <canvas
                id="B_fab"
                style="position: absolute; left: 0; top: 0; z-index: 1"
              ></canvas>
              <canvas
                id="B_slk"
                style="position: absolute; left: 0; top: 0; z-index: 2"
              ></canvas>
              <canvas
                id="B_hl"
                style="position: absolute; left: 0; top: 0; z-index: 3"
              ></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
